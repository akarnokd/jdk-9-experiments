-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\awt\desktop\AboutEvent.java
/**
 * Event sent when the application is asked to open its about window.
 *
 * @see AboutHandler#handleAbout
 *
 * @since 9
 */
public final class AboutEvent extends AppEvent {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\awt\desktop\AboutHandler.java
/**
 * An implementer receives notification when the app is asked to show its about
 * dialog.
 *
 * @see java.awt.Desktop#setAboutHandler(java.awt.desktop.AboutHandler)
 *
 * @since 9
 */
public interface AboutHandler {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\awt\desktop\AppEvent.java
/**
 * AppEvents are sent to listeners and handlers installed on the
 * {@link java.awt.Desktop}.
 *
 * @since 9
 */
public class AppEvent extends EventObject {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\awt\desktop\AppForegroundEvent.java
/**
 * Event sent when the application has become the foreground app, and when it is
 * no longer the foreground app.
 *
 * @see AppForegroundListener#appRaisedToForeground(AppEvent.AppForegroundEvent)
 * @see AppForegroundListener#appMovedToBackground(AppEvent.AppForegroundEvent)
 *
 * @since 9
 */
public final class AppForegroundEvent extends AppEvent {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\awt\desktop\AppForegroundListener.java
/**
 * Implementors are notified when the app becomes the foreground app and when it
 * is no longer the foreground app. This notification is useful for hiding and
 * showing transient UI like palette windows which should be hidden when the app
 * is in the background.
 *
 * @since 9
 */
public interface AppForegroundListener extends SystemEventListener {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\awt\desktop\AppHiddenEvent.java
/**
 * Event sent when the application has been hidden or shown.
 *
 * @see AppHiddenListener#appHidden(AppEvent.AppHiddenEvent)
 * @see AppHiddenListener#appUnhidden(AppEvent.AppHiddenEvent)
 *
 * @since 9
 */
public final class AppHiddenEvent extends AppEvent {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\awt\desktop\AppHiddenListener.java
/**
 * Implementors are notified when the app is hidden or shown by the user. This
 * notification is helpful for discontinuing a costly animation if it's not
 * visible to the user.
 *
 * @since 9
 */
public interface AppHiddenListener extends SystemEventListener {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\awt\desktop\AppReopenedEvent.java
/**
 * Event sent when the application is asked to re-open itself.
 *
 * @see AppReopenedListener#appReopened(AppEvent.AppReopenedEvent)
 *
 * @since 9
 */
public final class AppReopenedEvent extends AppEvent {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\awt\desktop\AppReopenedListener.java
/**
 * Implementors receive notification when the app has been asked to open again.
 *
 * This notification is useful for showing a new document when your app has no open windows.
 *
 * @since 9
 */
public interface AppReopenedListener extends SystemEventListener {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\awt\desktop\FilesEvent.java
/**
 * Auxiliary event containing a list of files.
 *
 * @since 9
 */
public class FilesEvent extends AppEvent {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\awt\desktop\OpenFilesEvent.java
/**
 * Event sent when the app is asked to open a list of files.
 *
 * @see OpenFilesHandler#openFiles
 *
 * @since 9
 */
public final class OpenFilesEvent extends FilesEvent {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\awt\desktop\OpenFilesHandler.java
/**
 * An implementor is notified when the application is asked to open a list of files.
 *
 * @see java.awt.Desktop#setOpenFileHandler(java.awt.desktop.OpenFilesHandler)
 *
 * @since 9
 */
public interface OpenFilesHandler {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\awt\desktop\OpenURIEvent.java
/**
 * Event sent when the app is asked to open a {@code URI}.
 *
 * @see OpenURIHandler#openURI(AppEvent.OpenURIEvent)
 *
 * @since 9
 */
public final class OpenURIEvent extends AppEvent {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\awt\desktop\OpenURIHandler.java
/**
 * An implementor is notified when the application is asked to open a URI.
 *
 * @see java.awt.Desktop#setOpenURIHandler(java.awt.desktop.OpenURIHandler)
 *
 * @since 9
 */
public interface OpenURIHandler {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\awt\desktop\PreferencesEvent.java
/**
 * Event sent when the application is asked to open its preferences window.
 *
 * @see PreferencesHandler#handlePreferences
 *
 * @since 9
 */
public final class PreferencesEvent extends AppEvent {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\awt\desktop\PreferencesHandler.java
/**
 * An implementor is notified when the app is asked to show its preferences UI.
 *
 * @see java.awt.Desktop#setPreferencesHandler(java.awt.desktop.PreferencesHandler)
 *
 * @since 9
 */
public interface PreferencesHandler {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\awt\desktop\PrintFilesEvent.java
/**
 * Event sent when the app is asked to print a list of files.
 *
 * @see PrintFilesHandler#printFiles(AppEvent.PrintFilesEvent)
 * @since 9
 */
public final class PrintFilesEvent extends FilesEvent {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\awt\desktop\PrintFilesHandler.java
/**
 * An implementor can respond to requests to print documents that the app has been registered to handle.
 *
 * @see java.awt.Desktop#setPrintFileHandler(java.awt.desktop.PrintFilesHandler)
 *
 * @since 9
 */
public interface PrintFilesHandler {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\awt\desktop\QuitEvent.java
/**
 * Event sent when the application is asked to quit.
 *
 * @see QuitHandler#handleQuitRequestWith(AppEvent.QuitEvent, QuitResponse)
 *
 * @since 9
 */
public final class QuitEvent extends AppEvent {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\awt\desktop\QuitHandler.java
/**
 * An implementor determines if requests to quit this application should proceed or cancel.
 *
 * @see java.awt.Desktop#setQuitHandler(java.awt.desktop.QuitHandler)
 * @see java.awt.Desktop#setQuitStrategy(java.awt.desktop.QuitStrategy)
 *
 * @since 9
 */
public interface QuitHandler {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\awt\desktop\QuitResponse.java
/**
 * Used to respond to a request to quit the application.
 *
 * @see java.awt.Desktop#setQuitHandler(java.awt.desktop.QuitHandler)
 * @see java.awt.desktop.QuitHandler
 * @see java.awt.Desktop#setQuitStrategy(java.awt.desktop.QuitStrategy)
 *
 * @since 9
 */
public interface QuitResponse {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\awt\desktop\QuitStrategy.java
/**
 * The strategy used to shut down the application, if Sudden Termination is not enabled.
 *
 * @see java.awt.Desktop#setQuitHandler(java.awt.desktop.QuitHandler)
 * @see java.awt.Desktop#setQuitStrategy(java.awt.desktop.QuitStrategy)
 * @see java.awt.Desktop#enableSuddenTermination()
 * @see java.awt.Desktop#disableSuddenTermination()
 *
 * @since 9
 */
public enum QuitStrategy {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\awt\desktop\ScreenSleepEvent.java
/**
 * Event sent when the displays attached to the system enter and exit power save
 * sleep.
 *
 * @see ScreenSleepListener#screenAboutToSleep(AppEvent.ScreenSleepEvent)
 * @see ScreenSleepListener#screenAwoke(AppEvent.ScreenSleepEvent)
 *
 * @since 9
 */
public final class ScreenSleepEvent extends AppEvent {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\awt\desktop\ScreenSleepListener.java
/**
 * Implementors receive notification when the displays attached to the system have entered power save sleep.
 *
 * This notification is useful for discontinuing a costly animation, or indicating that the user is no longer present on a network service.
 *
 * @since 9
 */
public interface ScreenSleepListener extends SystemEventListener {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\awt\desktop\SystemEventListener.java
/**
 * Common interface for all event listener sub-types.
 *
 * Implementors may implement multiple sub-types, but only need to call
 * {@link java.awt.Desktop#addAppEventListener(SystemEventListener)} once to
 * receive all notifications.
 *
 * @since 9
 */
public interface SystemEventListener extends EventListener {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\awt\desktop\SystemSleepEvent.java
/**
 * Event sent when the system enters and exits power save sleep.
 *
 * @see SystemSleepListener#systemAboutToSleep(AppEvent.SystemSleepEvent)
 * @see SystemSleepListener#systemAwoke(AppEvent.SystemSleepEvent)
 *
 * @since 9
 */
public final class SystemSleepEvent extends AppEvent {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\awt\desktop\SystemSleepListener.java
/**
 * Implementors receive notification as the system is entering sleep, and after
 * the system wakes.
 *
 * This notification is useful for disconnecting from network services prior to
 * sleep, or re-establishing a connection if the network configuration has
 * changed during sleep.
 *
 * @since 9
 */
public interface SystemSleepListener extends SystemEventListener {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\awt\desktop\UserSessionEvent.java
/**
 * Event sent when the user session has been changed.
 *
 * Some systems may provide a reason of a user session change.
 *
 * @see UserSessionListener#userSessionActivated(AppEvent.UserSessionEvent)
 * @see UserSessionListener#userSessionDeactivated(AppEvent.UserSessionEvent)
 *
 * @since 9
 */
public final class UserSessionEvent extends AppEvent {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\awt\desktop\UserSessionListener.java
/**
 * Implementors receive notification when the user session changes.
 *
 * This notification is useful for discontinuing a costly animation,
 * or indicating that the user is no longer present on a network service.
 *
 * Some systems may provide a reason of the user session change.
 *
 * @see UserSessionEvent.Reason#UNSPECIFIED
 * @see UserSessionEvent.Reason#CONSOLE
 * @see UserSessionEvent.Reason#REMOTE
 * @see UserSessionEvent.Reason#LOCK
 *
 * @since 9
 */
public interface UserSessionListener extends SystemEventListener {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\awt\Desktop.java
        /**
         * Represents an AppForegroundListener
         * @see java.awt.desktop.AppForegroundListener
         * @since 9
         */
        APP_EVENT_FOREGROUND,

        /**
         * Represents an AppHiddenListener
         * @see java.awt.desktop.AppHiddenListener
         * @since 9
         */
        APP_EVENT_HIDDEN,

        /**
         * Represents an AppReopenedListener
         * @see java.awt.desktop.AppReopenedListener
         * @since 9
         */
        APP_EVENT_REOPENED,

        /**
         * Represents a ScreenSleepListener
         * @see java.awt.desktop.ScreenSleepListener
         * @since 9
         */
        APP_EVENT_SCREEN_SLEEP,

        /**
         * Represents a SystemSleepListener
         * @see java.awt.desktop.SystemSleepListener
         * @since 9
         */
        APP_EVENT_SYSTEM_SLEEP,

        /**
         * Represents a UserSessionListener
         * @see java.awt.desktop.UserSessionListener
         * @since 9
         */
        APP_EVENT_USER_SESSION,

        /**
         * Represents an AboutHandler
         * @see #setAboutHandler(java.awt.desktop.AboutHandler)
         * @since 9
         */
        APP_ABOUT,

        /**
         * Represents a PreferencesHandler
         * @see #setPreferencesHandler(java.awt.desktop.PreferencesHandler)
         * @since 9
         */
        APP_PREFERENCES,

        /**
         * Represents an OpenFilesHandler
         * @see #setOpenFileHandler(java.awt.desktop.OpenFilesHandler)
         * @since 9
         */
        APP_OPEN_FILE,

        /**
         * Represents a PrintFilesHandler
         * @see #setPrintFileHandler(java.awt.desktop.PrintFilesHandler)
         * @since 9
         */
        APP_PRINT_FILE,

        /**
         * Represents an OpenURIHandler
         * @see #setOpenURIHandler(java.awt.desktop.OpenURIHandler)
         * @since 9
         */
        APP_OPEN_URI,

        /**
         * Represents a QuitHandler
         * @see #setQuitHandler(java.awt.desktop.QuitHandler)
         * @since 9
         */
        APP_QUIT_HANDLER,

        /**
         * Represents a QuitStrategy
         * @see #setQuitStrategy(java.awt.desktop.QuitStrategy)
         * @since 9
         */
        APP_QUIT_STRATEGY,

        /**
         * Represents a SuddenTermination
         * @see #enableSuddenTermination()
         * @since 9
         */
        APP_SUDDEN_TERMINATION,

        /**
         * Represents a requestForeground
         * @see #requestForeground(boolean)
         * @since 9
         */
        APP_REQUEST_FOREGROUND,

        /**
         * Represents a HelpViewer
         * @see #openHelpViewer()
         * @since 9
         */
        APP_HELP_VIEWER,

        /**
         * Represents a menu bar
         * @see #setDefaultMenuBar(javax.swing.JMenuBar)
         * @since 9
         */
        APP_MENU_BAR,

        /**
         * Represents a browse file directory
         * @see #browseFileDirectory(java.io.File)
         * @since 9
         */
        BROWSE_FILE_DIR,

        /**
         * Represents a move to trash
         * @see #moveToTrash(java.io.File)
         * @since 9
         */
        MOVE_TO_TRASH
    };

    /**
     * Adds sub-types of {@link SystemEventListener} to listen for notifications
     * from the native system.
     *
     * Has no effect if SystemEventListener's sub-type is unsupported on the current
     * platform.
     *
     * @param listener listener
     *
     * @throws SecurityException if a security manager exists and it
     * denies the
     * {@code AWTPermission("showWindowWithoutWarningBanner")}
     * permission
     *
     * @see java.awt.desktop.AppForegroundListener
     * @see java.awt.desktop.AppHiddenListener
     * @see java.awt.desktop.AppReopenedListener
     * @see java.awt.desktop.ScreenSleepListener
     * @see java.awt.desktop.SystemSleepListener
     * @see java.awt.desktop.UserSessionListener
     * @since 9
     */
    public void addAppEventListener(final SystemEventListener listener) {

    /**
     * Removes sub-types of {@link SystemEventListener} to listen for notifications
     * from the native system.
     *
     * Has no effect if SystemEventListener's sub-type is unsupported on  the current
     * platform.
     *
     * @param listener listener
     *
     * @throws SecurityException if a security manager exists and it
     * denies the
     * {@code AWTPermission("showWindowWithoutWarningBanner")}
     * permission
     *
     * @see java.awt.desktop.AppForegroundListener
     * @see java.awt.desktop.AppHiddenListener
     * @see java.awt.desktop.AppReopenedListener
     * @see java.awt.desktop.ScreenSleepListener
     * @see java.awt.desktop.SystemSleepListener
     * @see java.awt.desktop.UserSessionListener
     * @since 9
     */
    public void removeAppEventListener(final SystemEventListener listener) {

    /**
     * Installs a handler to show a custom About window for your application.
     * <p>
     * Setting the {@link java.awt.desktop.AboutHandler} to {@code null} reverts it to the
     * default behavior.
     *
     * @param aboutHandler the handler to respond to the
     * {@link java.awt.desktop.AboutHandler#handleAbout} )} message
     *
     * @throws SecurityException if a security manager exists and it
     * denies the
     * {@code AWTPermission("showWindowWithoutWarningBanner")}
     * permission
     * @throws UnsupportedOperationException if the current platform
     * does not support the {@link Desktop.Action#APP_ABOUT} action
     *
     * @since 9
     */
    public void setAboutHandler(final AboutHandler aboutHandler) {

    /**
     * Installs a handler to show a custom Preferences window for your
     * application.
     * <p>
     * Setting the {@link PreferencesHandler} to {@code null} reverts it to
     * the default behavior
     *
     * @param preferencesHandler the handler to respond to the
     * {@link PreferencesHandler#handlePreferences(PreferencesEvent)}
     *
     * @throws SecurityException if a security manager exists and it
     * denies the
     * {@code AWTPermission("showWindowWithoutWarningBanner")}
     * permission
     * @throws UnsupportedOperationException if the current platform
     * does not support the {@link Desktop.Action#APP_PREFERENCES} action
     * @since 9
     */
    public void setPreferencesHandler(final PreferencesHandler preferencesHandler) {

    /**
     * Installs the handler which is notified when the application is asked to
     * open a list of files.
     *
     * @implNote Please note that for Mac OS, notifications
     * are only sent if the Java app is a bundled application,
     * with a {@code CFBundleDocumentTypes} array present in its
     * Info.plist. See the
     * <a href="http://developer.apple.com/mac/library/documentation/General/Reference/InfoPlistKeyReference">
     * Info.plist Key Reference</a> for more information about adding a
     * {@code CFBundleDocumentTypes} key to your app's Info.plist.
     *
     * @param openFileHandler handler
     *
     * @throws SecurityException if a security manager exists and its
     * {@link java.lang.SecurityManager#checkRead(java.lang.String)}
     * method denies read access to the files, or it denies the
     * {@code AWTPermission("showWindowWithoutWarningBanner")}
     * permission, or the calling thread is not allowed to create a
     * subprocess
     * @throws UnsupportedOperationException if the current platform
     * does not support the {@link Desktop.Action#APP_OPEN_FILE} action
     * @since 9
     */
    public void setOpenFileHandler(final OpenFilesHandler openFileHandler) {

    /**
     * Installs the handler which is notified when the application is asked to
     * print a list of files.
     *
     * @implNote Please note that for Mac OS, notifications
     * are only sent if the Java app is a bundled application,
     * with a {@code CFBundleDocumentTypes} array present in its
     * Info.plist. See the
     * <a href="http://developer.apple.com/mac/library/documentation/General/Reference/InfoPlistKeyReference">
     * Info.plist Key Reference</a> for more information about adding a
     * {@code CFBundleDocumentTypes} key to your app's Info.plist.
     *
     * @param printFileHandler handler
     * @throws SecurityException if a security manager exists and its
     * {@link java.lang.SecurityManager#checkPrintJobAccess()} method denies
     * the permission to print.
     * @throws UnsupportedOperationException if the current platform
     * does not support the {@link Desktop.Action#APP_PRINT_FILE} action
     * @since 9
     */
    public void setPrintFileHandler(final PrintFilesHandler printFileHandler) {

    /**
     * Installs the handler which is notified when the application is asked to
     * open a URL.
     *
     * Setting the handler to {@code null} causes all
     * {@link OpenURIHandler#openURI(AppEvent.OpenURIEvent)} requests to be
     * enqueued until another handler is set.
     *
     * @implNote Please note that for Mac OS, notifications
     * are only sent if the Java app is a bundled application,
     * with a {@code CFBundleDocumentTypes} array present in its
     * Info.plist. See the
     * <a href="http://developer.apple.com/mac/library/documentation/General/Reference/InfoPlistKeyReference">
     * Info.plist Key Reference</a> for more information about adding a
     * {@code CFBundleDocumentTypes} key to your app's Info.plist.
     *
     * @param openURIHandler handler
     *
     * {@code AWTPermission("showWindowWithoutWarningBanner")}
     * permission, or the calling thread is not allowed to create a
     * subprocess
     * @throws UnsupportedOperationException if the current platform
     * does not support the {@link Desktop.Action#APP_OPEN_URI} action
     * @since 9
     */
    public void setOpenURIHandler(final OpenURIHandler openURIHandler) {

    /**
     * Installs the handler which determines if the application should quit. The
     * handler is passed a one-shot {@link java.awt.desktop.QuitResponse} which can cancel or
     * proceed with the quit. Setting the handler to {@code null} causes
     * all quit requests to directly perform the default {@link QuitStrategy}.
     *
     * @param quitHandler the handler that is called when the application is
     * asked to quit
     *
     * @throws SecurityException if a security manager exists and it
     * will not allow the caller to invoke {@code System.exit}
     * @throws UnsupportedOperationException if the current platform
     * does not support the {@link Desktop.Action#APP_QUIT_HANDLER} action
     * @since 9
     */
    public void setQuitHandler(final QuitHandler quitHandler) {

    /**
     * Sets the default strategy used to quit this application. The default is
     * calling SYSTEM_EXIT_0.
     *
     * @param strategy the way this application should be shutdown
     *
     * @throws SecurityException if a security manager exists and it
     * will not allow the caller to invoke {@code System.exit}
     * @throws UnsupportedOperationException if the current platform
     * does not support the {@link Desktop.Action#APP_QUIT_STRATEGY} action
     * @see QuitStrategy
     * @since 9
     */
    public void setQuitStrategy(final QuitStrategy strategy) {

    /**
     * Enables this application to be suddenly terminated.
     *
     * Call this method to indicate your application's state is saved, and
     * requires no notification to be terminated. Letting your application
     * remain terminatable improves the user experience by avoiding re-paging in
     * your application when it's asked to quit.
     *
     * <b>Note: enabling sudden termination will allow your application to be
     * quit without notifying your QuitHandler, or running any shutdown
     * hooks.</b>
     * E.g. user-initiated Cmd-Q, logout, restart, or shutdown requests will
     * effectively "kill -KILL" your application.
     *
     * @throws SecurityException if a security manager exists and it
     * will not allow the caller to invoke {@code System.exit}
     * @throws UnsupportedOperationException if the current platform
     * does not support the {@link Desktop.Action#APP_SUDDEN_TERMINATION} action
     * @see #disableSuddenTermination()
     * @since 9
     */
    public void enableSuddenTermination() {

    /**
     * Prevents this application from being suddenly terminated.
     *
     * Call this method to indicate that your application has unsaved state, and
     * may not be terminated without notification.
     *
     * @throws SecurityException if a security manager exists and it
     * will not allow the caller to invoke {@code System.exit}
     * @throws UnsupportedOperationException if the current platform
     * does not support the {@link Desktop.Action#APP_SUDDEN_TERMINATION} action
     * @see #enableSuddenTermination()
     * @since 9
     */
    public void disableSuddenTermination() {

    /**
     * Requests this application to move to the foreground.
     *
     * @param allWindows if all windows of this application should be moved to
     * the foreground, or only the foremost one
     * @throws SecurityException if a security manager exists and it denies the
     * {@code AWTPermission("showWindowWithoutWarningBanner")} permission.
     * @throws UnsupportedOperationException if the current platform
     * does not support the {@link Desktop.Action#APP_REQUEST_FOREGROUND} action
     * @since 9
     */
    public void requestForeground(final boolean allWindows) {

    /**
     * Opens the native help viewer application.
     *
     * @implNote Please note that for Mac OS, it opens the native help viewer
     * application if a Help Book has been added to the application bundler
     * and registered in the Info.plist with CFBundleHelpBookFolder
     *
     * @throws SecurityException if a security manager exists and it denies the
     * {@code AWTPermission("showWindowWithoutWarningBanner")} permission.
     * @throws UnsupportedOperationException if the current platform
     * does not support the {@link Desktop.Action#APP_HELP_VIEWER} action
     * @since 9
     */
    public void openHelpViewer() {

    /**
     * Sets the default menu bar to use when there are no active frames.
     *
     * @implNote Aqua Look and Feel should be active to support this on Mac OS.
     *
     * @param menuBar to use when no other frames are active
     * @throws SecurityException if a security manager exists and it denies the
     * {@code AWTPermission("showWindowWithoutWarningBanner")} permission.
     * @throws UnsupportedOperationException if the current platform
     * does not support the {@link Desktop.Action#APP_MENU_BAR} action
     * @since 9
     */
    public void setDefaultMenuBar(final JMenuBar menuBar) {

    /**
     * Opens a folder containing the {@code file} and selects it
     * in a default system file manager.
     * @param file the file
     * @throws SecurityException If a security manager exists and its
     *         {@link SecurityManager#checkRead(java.lang.String)} method
     *         denies read access to the file
     * @throws UnsupportedOperationException if the current platform
     *         does not support the {@link Desktop.Action#BROWSE_FILE_DIR} action
     * @throws NullPointerException if {@code file} is {@code null}
     * @throws IllegalArgumentException if the specified file doesn't
     * exist
     * @since 9
     */
    public void browseFileDirectory(File file) {

    /**
     * Moves the specified file to the trash.
     *
     * @param file the file
     * @return returns true if successfully moved the file to the trash.
     * @throws SecurityException If a security manager exists and its
     *         {@link SecurityManager#checkDelete(java.lang.String)} method
     *         denies deletion of the file
     * @throws UnsupportedOperationException if the current platform
     *         does not support the {@link Desktop.Action#MOVE_TO_TRASH} action
     * @throws NullPointerException if {@code file} is {@code null}
     * @throws IllegalArgumentException if the specified file doesn't
     * exist
     *
     * @since 9
     */
    public boolean moveToTrash(final File file) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\awt\event\FocusEvent.java
    /**
     * This enum represents the cause of a {@code FocusEvent}- the reason why it
     * occurred. Possible reasons include mouse events, keyboard focus
     * traversal, window activation.
     * If no cause is provided then the reason is {@code UNKNOWN}.
     *
     * @since 9
     */
    public enum Cause {

    /**
     * A focus event has the reason why this event was generated.
     * The cause is set during the focus event creation.
     *
     * @serial
     * @see #getCause()
     * @since 9
     */
    private final Cause cause;

    /**
     * Constructs a {@code FocusEvent} object with the
     * specified temporary state, opposite {@code Component} and the cause.
     * The opposite {@code Component} is the other
     * {@code Component} involved in this focus change.
     * For a {@code FOCUS_GAINED} event, this is the
     * {@code Component} that lost focus. For a
     * {@code FOCUS_LOST} event, this is the {@code Component}
     * that gained focus. If this focus change occurs with a native
     * application, with a Java application in a different VM,
     * or with no other {@code Component}, then the opposite
     * {@code Component} is {@code null}.
     * <p> This method throws an
     * {@code IllegalArgumentException} if {@code source} or {@code cause}
     * is {@code null}.
     *
     * @param source    The {@code Component} that originated the event
     * @param id        An integer indicating the type of event.
     *                  For information on allowable values, see
     *                  the class description for {@link FocusEvent}
     * @param temporary Equals {@code true} if the focus change is temporary;
     *                  {@code false} otherwise
     * @param opposite  The other Component involved in the focus change,
     *                  or {@code null}
     * @param cause     The focus event cause.
     * @throws IllegalArgumentException if {@code source} equals {@code null}
     *                                  or if {@code cause} equals {@code null}
     * @see #getSource()
     * @see #getID()
     * @see #isTemporary()
     * @see #getOppositeComponent()
     * @see Cause
     * @since 9
     */
    public FocusEvent(Component source, int id, boolean temporary,
                      Component opposite, Cause cause) {

    /**
     * Returns the event cause.
     *
     * @return one of {@link Cause} values
     * @since 9
     */
    public final Cause getCause() {

    /**
     * Checks if this deserialized {@code FocusEvent} instance is compatible
     * with the current specification which implies that focus event has
     * non-null {@code cause} value. If the check fails a new {@code FocusEvent}
     * instance is returned which {@code cause} field equals to
     * {@link Cause#UNKNOWN} and its other fields have the same values as in
     * this {@code FocusEvent} instance.
     *
     * @serial
     * @see #cause
     * @since 9
     */
    @SuppressWarnings("serial")
    Object readResolve() throws ObjectStreamException {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\awt\font\NumericShaper.java
        /**
         * The Sinhala range with the Sinhala digits.
         * @since 9
         */
        SINHALA         ('\u0de6', '\u0d80', '\u0e00'),
        /**
         * The Myanmar Extended-B range with the Myanmar Tai Laing digits.
         * @since 9
         */
        MYANMAR_TAI_LAING ('\ua9f0', '\ua9e0', '\uaa00');

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\awt\Font.java
    /**
     * Returns true if any part of the specified text is from a
     * complex script for which the implementation will need to invoke
     * layout processing in order to render correctly when using
     * {@link Graphics#drawString(String,int,int) drawString(String,int,int)}
     * and other text rendering methods. Measurement of the text
     * may similarly need the same extra processing.
     * The {@code start} and {@code end} indices are provided so that
     * the application can request only a subset of the text be considered.
     * The last char index examined is at {@code "end-1"},
     * i.e a request to examine the entire array would be
     * <pre>
     * {@code Font.textRequiresLayout(chars, 0, chars.length);}
     * </pre>
     * An application may find this information helpful in
     * performance sensitive code.
     * <p>
     * Note that even if this method returns {@code false}, layout processing
     * may still be invoked when used with any {@code Font}
     * for which {@link #hasLayoutAttributes()} returns {@code true},
     * so that method will need to be consulted for the specific font,
     * in order to obtain an answer which accounts for such font attributes.
     *
     * @param chars the text.
     * @param start the index of the first char to examine.
     * @param end the ending index, exclusive.
     * @return {@code true} if the specified text will need special layout.
     * @throws NullPointerException if {@code chars} is null.
     * @throws ArrayIndexOutOfBoundsException if {@code start} is negative or
     * {@code end} is greater than the length of the {@code chars} array.
     * @since 9
     */
    public static boolean textRequiresLayout(char[] chars,
                                             int start, int end) {

    /**
     * Returns a new array of {@code Font} decoded from the specified stream.
     * The returned {@code Font[]} will have at least one element.
     * <p>
     * The explicit purpose of this variation on the
     * {@code createFont(int, InputStream)} method is to support font
     * sources which represent a TrueType/OpenType font collection and
     * be able to return all individual fonts in that collection.
     * Consequently this method will throw {@code FontFormatException}
     * if the data source does not contain at least one TrueType/OpenType
     * font. The same exception will also be thrown if any of the fonts in
     * the collection does not contain the required font tables.
     * <p>
     * The condition "at least one", allows for the stream to represent
     * a single OpenType/TrueType font. That is, it does not have to be
     * a collection.
     * Each {@code Font} element of the returned array is
     * created with a point size of 1 and style {@link #PLAIN PLAIN}.
     * This base font can then be used with the {@code deriveFont}
     * methods in this class to derive new {@code Font} objects with
     * varying sizes, styles, transforms and font features.
     * <p>This method does not close the {@link InputStream}.
     * <p>
     * To make each {@code Font} available to Font constructors it
     * must be registered in the {@code GraphicsEnvironment} by calling
     * {@link GraphicsEnvironment#registerFont(Font) registerFont(Font)}.
     * @param fontStream an {@code InputStream} object representing the
     * input data for the font or font collection.
     * @return a new {@code Font[]}.
     * @throws FontFormatException if the {@code fontStream} data does
     *     not contain the required font tables for any of the elements of
     *     the collection, or if it contains no fonts at all.
     * @throws IOException if the {@code fontStream} cannot be completely read.
     * @see GraphicsEnvironment#registerFont(Font)
     * @since 9
     */
    public static Font[] createFonts(InputStream fontStream)
        throws FontFormatException, IOException {

    /**
     * Returns a new array of {@code Font} decoded from the specified file.
     * The returned {@code Font[]} will have at least one element.
     * <p>
     * The explicit purpose of this variation on the
     * {@code createFont(int, File)} method is to support font
     * sources which represent a TrueType/OpenType font collection and
     * be able to return all individual fonts in that collection.
     * Consequently this method will throw {@code FontFormatException}
     * if the data source does not contain at least one TrueType/OpenType
     * font. The same exception will also be thrown if any of the fonts in
     * the collection does not contain the required font tables.
     * <p>
     * The condition "at least one", allows for the stream to represent
     * a single OpenType/TrueType font. That is, it does not have to be
     * a collection.
     * Each {@code Font} element of the returned array is
     * created with a point size of 1 and style {@link #PLAIN PLAIN}.
     * This base font can then be used with the {@code deriveFont}
     * methods in this class to derive new {@code Font} objects with
     * varying sizes, styles, transforms and font features.
     * <p>
     * To make each {@code Font} available to Font constructors it
     * must be registered in the {@code GraphicsEnvironment} by calling
     * {@link GraphicsEnvironment#registerFont(Font) registerFont(Font)}.
     * @param fontFile a {@code File} object containing the
     * input data for the font or font collection.
     * @return a new {@code Font[]}.
     * @throws FontFormatException if the {@code File} does
     *     not contain the required font tables for any of the elements of
     *     the collection, or if it contains no fonts at all.
     * @throws IOException if the {@code fontFile} cannot be read.
     * @see GraphicsEnvironment#registerFont(Font)
     * @since 9
     */
    public static Font[] createFonts(File fontFile)
            throws FontFormatException, IOException
    {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\awt\image\AbstractMultiResolutionImage.java
/**
 * This class provides default implementations of several {@code Image} methods
 * for classes that want to implement the {@MultiResolutionImage} interface.
 *
 * For example,
 * <pre> {@code
 * public class CustomMultiResolutionImage extends AbstractMultiResolutionImage {
 *
 *     final Image[] resolutionVariants;
 *
 *     public CustomMultiResolutionImage(Image... resolutionVariants) {
 *          this.resolutionVariants = resolutionVariants;
 *     }
 *
 *     public Image getResolutionVariant(
 *             double destImageWidth, double destImageHeight) {
 *         // return a resolution variant based on the given destination image size
 *     }
 *
 *     public List<Image> getResolutionVariants() {
 *         return Collections.unmodifiableList(Arrays.asList(resolutionVariants));
 *     }
 *
 *     protected Image getBaseImage() {
 *         return resolutionVariants[0];
 *     }
 * }
 * } </pre>
 *
 * @see java.awt.Image
 * @see java.awt.image.MultiResolutionImage
 *
 * @since 9
 */
public abstract class AbstractMultiResolutionImage extends java.awt.Image
        implements MultiResolutionImage {

    /**
     * Return the base image representing the best version of the image for
     * rendering at the default width and height.
     *
     * @return the base image of the set of multi-resolution images
     *
     * @since 9
     */
    protected abstract Image getBaseImage();

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\awt\image\BaseMultiResolutionImage.java
/**
 * This class is an array-based implementation of
 * the {@code AbstractMultiResolutionImage} class.
 *
 * This class will implement the
 * {@code getResolutionVariant(double destImageWidth, double destImageHeight)}
 * method using a simple algorithm which will return the first image variant
 * in the array that is large enough to satisfy the rendering request. The
 * last image in the array will be returned if no suitable image is found
 * that is as large as the rendering request.
 * <p>
 * For best effect the array of images should be sorted with each image being
 * both wider and taller than the previous image.  The base image need not be
 * the first image in the array. No exception will be thrown if the images
 * are not sorted as suggested.
 *
 * @see java.awt.Image
 * @see java.awt.image.MultiResolutionImage
 * @see java.awt.image.AbstractMultiResolutionImage
 *
 * @since 9
 */
public class BaseMultiResolutionImage extends AbstractMultiResolutionImage {

    /**
     * Creates a multi-resolution image with the given resolution variants.
     * The first resolution variant is used as the base image.
     *
     * @param resolutionVariants array of resolution variants sorted by image size
     * @throws IllegalArgumentException if null or zero-length array is passed
     * @throws NullPointerException if the specified {@code resolutionVariants}
     *          contains one or more null elements
     *
     * @since 9
     */
    public BaseMultiResolutionImage(Image... resolutionVariants) {

    /**
     * Creates a multi-resolution image with the given base image index and
     * resolution variants.
     *
     * @param baseImageIndex the index of base image in the resolution variants
     *        array
     * @param resolutionVariants array of resolution variants sorted by image size
     * @throws IllegalArgumentException if null or zero-length array is passed
     * @throws NullPointerException if the specified {@code resolutionVariants}
     *          contains one or more null elements
     * @throws IndexOutOfBoundsException if {@code baseImageIndex} is
     *          negative or greater than or equal to {@code resolutionVariants}
     *          length.
     *
     * @since 9
     */
    public BaseMultiResolutionImage(int baseImageIndex,
                                    Image... resolutionVariants) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\awt\image\MultiResolutionImage.java
/**
 * This interface is designed to be an optional additional API supported by
 * some implementations of {@link java.awt.Image} to allow them to provide
 * alternate images for various rendering resolutions. The various
 * {@code Graphics.drawImage(...)} variant methods will consult the methods
 * of this interface if it is implemented on the argument {@code Image} object
 * in order to choose the best representation to use for each rendering operation.
 * <p>
 * The {@code MultiResolutionImage} interface should be implemented by any
 * subclass of {@code java.awt.Image} whose instances are intended to provide
 * image resolution variants according to the given image width and height.
 * For convenience, toolkit images obtained from
 * {@code Toolkit.getImage(String name)} and {@code Toolkit.getImage(URL url)}
 * will implement this interface on platforms that support naming conventions
 * for resolution variants of stored image media and the
 * {@code AbstractMultiResolutionImage} and {@code BaseMultiResolutionImage}
 * classes are provided to facilitate easy construction of custom multi-resolution
 * images from a list of related images.
 *
 * @see java.awt.Image
 * @see java.awt.image.AbstractMultiResolutionImage
 * @see java.awt.image.BaseMultiResolutionImage
 * @see java.awt.Toolkit#getImage(java.lang.String filename)
 * @see java.awt.Toolkit#getImage(java.net.URL url)
 *
 * @since 9
 */
public interface MultiResolutionImage {

    /**
     * Gets a specific image that is the best variant to represent
     * this logical image at the indicated size.
     *
     * @param destImageWidth the width of the destination image, in pixels.
     * @param destImageHeight the height of the destination image, in pixels.
     * @return image resolution variant.
     * @throws IllegalArgumentException if {@code destImageWidth} or
     *         {@code destImageHeight} is less than or equal to zero, infinity,
     *         or NaN.
     *
     * @since 9
     */
    Image getResolutionVariant(double destImageWidth, double destImageHeight);

    /**
     * Gets a readable list of all resolution variants.
     * The list must be nonempty and contain at least one resolution variant.
     * <p>
     * Note that many implementations might return an unmodifiable list.
     *
     * @return list of resolution variants.
     * @since 9
     */
    public List<Image> getResolutionVariants();

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\awt\RenderingHints.java
    /**
     * Image resolution variant hint key.
     * The {@code RESOLUTION_VARIANT} hint controls which image resolution
     * variant should be chosen for image drawing.
     *
     * <ul>
     * <li>{@link #VALUE_RESOLUTION_VARIANT_DEFAULT}
     * <li>{@link #VALUE_RESOLUTION_VARIANT_BASE}
     * <li>{@link #VALUE_RESOLUTION_VARIANT_SIZE_FIT}
     * <li>{@link #VALUE_RESOLUTION_VARIANT_DPI_FIT}
     * </ul>
     * @since 9
     */
    public static final Key KEY_RESOLUTION_VARIANT =
        SunHints.KEY_RESOLUTION_VARIANT;

    /**
     * Image resolution variant hint value -- an image resolution variant is
     * chosen based on a default heuristic which may depend on the policies
     * of the platform
     *
     * @see #KEY_RESOLUTION_VARIANT
     * @since 9
     */
    public static final Object VALUE_RESOLUTION_VARIANT_DEFAULT =
        SunHints.VALUE_RESOLUTION_VARIANT_DEFAULT;

    /**
     * Image resolution variant hint value -- the standard resolution of an image
     * is always used.
     *
     * @see #KEY_RESOLUTION_VARIANT
     * @since 9
     */
    public static final Object VALUE_RESOLUTION_VARIANT_BASE =
        SunHints.VALUE_RESOLUTION_VARIANT_BASE;

    /**
     * Image resolution variant hint value -- an image resolution variant is
     * chosen based on the DPI of the screen and the transform in the Graphics2D
     * context.
     *
     * @see #KEY_RESOLUTION_VARIANT
     * @since 9
     */
    public static final Object VALUE_RESOLUTION_VARIANT_SIZE_FIT =
        SunHints.VALUE_RESOLUTION_VARIANT_SIZE_FIT;

    /**
     * Image resolution variant hint value -- an image resolution variant is
     * chosen based only on the DPI of the screen.
     *
     * @see #KEY_RESOLUTION_VARIANT
     * @since 9
     */
    public static final Object VALUE_RESOLUTION_VARIANT_DPI_FIT =
        SunHints.VALUE_RESOLUTION_VARIANT_DPI_FIT;

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\awt\Taskbar.java
/**
 * The {@code Taskbar} class allows a Java application to interact with
 * the system task area (taskbar, Dock, etc.).
 *
 * <p>
 * There are a variety of interactions depending on the current platform such as
 * displaying progress of some task, appending user-specified menu to the application
 * icon context menu, etc.
 *
 * @implNote Linux support is currently limited to Unity. However to make these
 * features work on Unity, the app should be run from a .desktop file with
 * specified {@code java.desktop.appName} system property set to this .desktop
 * file name:
 * {@code Exec=java -Djava.desktop.appName=MyApp.desktop -jar /path/to/myapp.jar}
 * see <a href="https://help.ubuntu.com/community/UnityLaunchersAndDesktopFiles">
 * https://help.ubuntu.com/community/UnityLaunchersAndDesktopFiles</a>
 *
 * @since 9
 */

public class Taskbar {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\beans\BeanProperty.java
/**
 * An annotation used to specify some property-related information for the
 * automatically generated {@link BeanInfo} classes. This annotation is not used
 * if the annotated class has a corresponding user-defined {@code BeanInfo}
 * class, which does not imply the automatic analysis. If both the read and the
 * write methods of the property are annotated, then the read method annotation
 * will have more priority and replace the write method annotation.
 *
 * @author Sergey A. Malenkov
 * @see BeanInfo#getPropertyDescriptors
 * @since 9
 */
@Documented
@Target({METHOD})
@Retention(RUNTIME)
public @interface BeanProperty {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\beans\IndexedPropertyDescriptor.java
    /**
     * Creates {@code IndexedPropertyDescriptor} from the specified property info.
     *
     * @param entry  the key-value pair,
     *               where the {@code key} is the base name of the property (the rest of the method name)
     *               and the {@code value} is the automatically generated property info
     * @param bound  the flag indicating whether it is possible to treat this property as a bound property
     *
     * @since 9
     */
    IndexedPropertyDescriptor(Entry<String,PropertyInfo> entry, boolean bound) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\beans\JavaBean.java
/**
 * An annotation used to specify some class-related information
 * for the automatically generated {@link BeanInfo} classes.
 * This annotation is not used if the annotated class
 * has a corresponding user-defined {@code BeanInfo} class,
 * which does not imply the automatic analysis.
 *
 * @see BeanInfo#getBeanDescriptor
 * @since 9
 *
 * @author Sergey A. Malenkov
 */
@Documented
@Target({TYPE})
@Retention(RUNTIME)
public @interface JavaBean {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\beans\PropertyDescriptor.java
    /**
     * Creates {@code PropertyDescriptor} from the specified property info.
     *
     * @param entry  the pair of values,
     *               where the {@code key} is the base name of the property (the rest of the method name)
     *               and the {@code value} is the automatically generated property info
     * @param bound  the flag indicating whether it is possible to treat this property as a bound property
     *
     * @since 9
     */
    PropertyDescriptor(Entry<String,PropertyInfo> entry, boolean bound) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\io\InputStream.java
    /**
     * Reads all remaining bytes from the input stream. This method blocks until
     * all remaining bytes have been read and end of stream is detected, or an
     * exception is thrown. This method does not close the input stream.
     *
     * <p> When this stream reaches end of stream, further invocations of this
     * method will return an empty byte array.
     *
     * <p> Note that this method is intended for simple cases where it is
     * convenient to read all bytes into a byte array. It is not intended for
     * reading input streams with large amounts of data.
     *
     * <p> The behavior for the case where the input stream is <i>asynchronously
     * closed</i>, or the thread interrupted during the read, is highly input
     * stream specific, and therefore not specified.
     *
     * <p> If an I/O error occurs reading from the input stream, then it may do
     * so after some, but not all, bytes have been read. Consequently the input
     * stream may not be at end of stream and may be in an inconsistent state.
     * It is strongly recommended that the stream be promptly closed if an I/O
     * error occurs.
     *
     * @return a byte array containing the bytes read from this input stream
     * @throws IOException if an I/O error occurs
     * @throws OutOfMemoryError if an array of the required size cannot be
     *         allocated. For example, if an array larger than {@code 2GB} would
     *         be required to store the bytes.
     *
     * @since 9
     */
    public byte[] readAllBytes() throws IOException {

    /**
     * Reads the requested number of bytes from the input stream into the given
     * byte array. This method blocks until {@code len} bytes of input data have
     * been read, end of stream is detected, or an exception is thrown. The
     * number of bytes actually read, possibly zero, is returned. This method
     * does not close the input stream.
     *
     * <p> In the case where end of stream is reached before {@code len} bytes
     * have been read, then the actual number of bytes read will be returned.
     * When this stream reaches end of stream, further invocations of this
     * method will return zero.
     *
     * <p> If {@code len} is zero, then no bytes are read and {@code 0} is
     * returned; otherwise, there is an attempt to read up to {@code len} bytes.
     *
     * <p> The first byte read is stored into element {@code b[off]}, the next
     * one in to {@code b[off+1]}, and so on. The number of bytes read is, at
     * most, equal to {@code len}. Let <i>k</i> be the number of bytes actually
     * read; these bytes will be stored in elements {@code b[off]} through
     * {@code b[off+}<i>k</i>{@code -1]}, leaving elements {@code b[off+}<i>k</i>
     * {@code ]} through {@code b[off+len-1]} unaffected.
     *
     * <p> The behavior for the case where the input stream is <i>asynchronously
     * closed</i>, or the thread interrupted during the read, is highly input
     * stream specific, and therefore not specified.
     *
     * <p> If an I/O error occurs reading from the input stream, then it may do
     * so after some, but not all, bytes of {@code b} have been updated with
     * data from the input stream. Consequently the input stream and {@code b}
     * may be in an inconsistent state. It is strongly recommended that the
     * stream be promptly closed if an I/O error occurs.
     *
     * @param  b the byte array into which the data is read
     * @param  off the start offset in {@code b} at which the data is written
     * @param  len the maximum number of bytes to read
     * @return the actual number of bytes read into the buffer
     * @throws IOException if an I/O error occurs
     * @throws NullPointerException if {@code b} is {@code null}
     * @throws IndexOutOfBoundsException If {@code off} is negative, {@code len}
     *         is negative, or {@code len} is greater than {@code b.length - off}
     *
     * @since 9
     */
    public int readNBytes(byte[] b, int off, int len) throws IOException {

    /**
     * Reads all bytes from this input stream and writes the bytes to the
     * given output stream in the order that they are read. On return, this
     * input stream will be at end of stream. This method does not close either
     * stream.
     * <p>
     * This method may block indefinitely reading from the input stream, or
     * writing to the output stream. The behavior for the case where the input
     * and/or output stream is <i>asynchronously closed</i>, or the thread
     * interrupted during the transfer, is highly input and output stream
     * specific, and therefore not specified.
     * <p>
     * If an I/O error occurs reading from the input stream or writing to the
     * output stream, then it may do so after some bytes have been read or
     * written. Consequently the input stream may not be at end of stream and
     * one, or both, streams may be in an inconsistent state. It is strongly
     * recommended that both streams be promptly closed if an I/O error occurs.
     *
     * @param  out the output stream, non-null
     * @return the number of bytes transferred
     * @throws IOException if an I/O error occurs when reading or writing
     * @throws NullPointerException if {@code out} is {@code null}
     *
     * @since 9
     */
    public long transferTo(OutputStream out) throws IOException {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\AbstractStringBuilder.java
    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public IntStream chars() {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public IntStream codePoints() {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\Byte.java
    /**
     * Compares two {@code byte} values numerically treating the values
     * as unsigned.
     *
     * @param  x the first {@code byte} to compare
     * @param  y the second {@code byte} to compare
     * @return the value {@code 0} if {@code x == y}; a value less
     *         than {@code 0} if {@code x < y} as unsigned values; and
     *         a value greater than {@code 0} if {@code x > y} as
     *         unsigned values
     * @since 9
     */
    public static int compareUnsigned(byte x, byte y) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\Character.java
    /**
     * Weak bidirectional character type "LRI" in the Unicode specification.
     * @since 9
     */
    public static final byte DIRECTIONALITY_LEFT_TO_RIGHT_ISOLATE = 19;

    /**
     * Weak bidirectional character type "RLI" in the Unicode specification.
     * @since 9
     */
    public static final byte DIRECTIONALITY_RIGHT_TO_LEFT_ISOLATE = 20;

    /**
     * Weak bidirectional character type "FSI" in the Unicode specification.
     * @since 9
     */
    public static final byte DIRECTIONALITY_FIRST_STRONG_ISOLATE = 21;

    /**
     * Weak bidirectional character type "PDI" in the Unicode specification.
     * @since 9
     */
    public static final byte DIRECTIONALITY_POP_DIRECTIONAL_ISOLATE = 22;

        /**
         * Constant for the "Combining Diacritical Marks Extended" Unicode
         * character block.
         * @since 9
         */
        public static final UnicodeBlock COMBINING_DIACRITICAL_MARKS_EXTENDED =
            new UnicodeBlock("COMBINING_DIACRITICAL_MARKS_EXTENDED",
                             "COMBINING DIACRITICAL MARKS EXTENDED",
                             "COMBININGDIACRITICALMARKSEXTENDED");

        /**
         * Constant for the "Myanmar Extended-B" Unicode character block.
         * @since 9
         */
        public static final UnicodeBlock MYANMAR_EXTENDED_B =
            new UnicodeBlock("MYANMAR_EXTENDED_B",
                             "MYANMAR EXTENDED-B",
                             "MYANMAREXTENDED-B");

        /**
         * Constant for the "Latin Extended-E" Unicode character block.
         * @since 9
         */
        public static final UnicodeBlock LATIN_EXTENDED_E =
            new UnicodeBlock("LATIN_EXTENDED_E",
                             "LATIN EXTENDED-E",
                             "LATINEXTENDED-E");

        /**
         * Constant for the "Coptic Epact Numbers" Unicode character block.
         * @since 9
         */
        public static final UnicodeBlock COPTIC_EPACT_NUMBERS =
            new UnicodeBlock("COPTIC_EPACT_NUMBERS",
                             "COPTIC EPACT NUMBERS",
                             "COPTICEPACTNUMBERS");

        /**
         * Constant for the "Old Permic" Unicode character block.
         * @since 9
         */
        public static final UnicodeBlock OLD_PERMIC =
            new UnicodeBlock("OLD_PERMIC",
                             "OLD PERMIC",
                             "OLDPERMIC");

        /**
         * Constant for the "Elbasan" Unicode character block.
         * @since 9
         */
        public static final UnicodeBlock ELBASAN =
            new UnicodeBlock("ELBASAN");

        /**
         * Constant for the "Caucasian Albanian" Unicode character block.
         * @since 9
         */
        public static final UnicodeBlock CAUCASIAN_ALBANIAN =
            new UnicodeBlock("CAUCASIAN_ALBANIAN",
                             "CAUCASIAN ALBANIAN",
                             "CAUCASIANALBANIAN");

        /**
         * Constant for the "Linear A" Unicode character block.
         * @since 9
         */
        public static final UnicodeBlock LINEAR_A =
            new UnicodeBlock("LINEAR_A",
                             "LINEAR A",
                             "LINEARA");

        /**
         * Constant for the "Palmyrene" Unicode character block.
         * @since 9
         */
        public static final UnicodeBlock PALMYRENE =
            new UnicodeBlock("PALMYRENE");

        /**
         * Constant for the "Nabataean" Unicode character block.
         * @since 9
         */
        public static final UnicodeBlock NABATAEAN =
            new UnicodeBlock("NABATAEAN");

        /**
         * Constant for the "Old North Arabian" Unicode character block.
         * @since 9
         */
        public static final UnicodeBlock OLD_NORTH_ARABIAN =
            new UnicodeBlock("OLD_NORTH_ARABIAN",
                             "OLD NORTH ARABIAN",
                             "OLDNORTHARABIAN");

        /**
         * Constant for the "Manichaean" Unicode character block.
         * @since 9
         */
        public static final UnicodeBlock MANICHAEAN =
            new UnicodeBlock("MANICHAEAN");

        /**
         * Constant for the "Psalter Pahlavi" Unicode character block.
         * @since 9
         */
        public static final UnicodeBlock PSALTER_PAHLAVI =
            new UnicodeBlock("PSALTER_PAHLAVI",
                             "PSALTER PAHLAVI",
                             "PSALTERPAHLAVI");

        /**
         * Constant for the "Mahajani" Unicode character block.
         * @since 9
         */
        public static final UnicodeBlock MAHAJANI =
            new UnicodeBlock("MAHAJANI");

        /**
         * Constant for the "Sinhala Archaic Numbers" Unicode character block.
         * @since 9
         */
        public static final UnicodeBlock SINHALA_ARCHAIC_NUMBERS =
            new UnicodeBlock("SINHALA_ARCHAIC_NUMBERS",
                             "SINHALA ARCHAIC NUMBERS",
                             "SINHALAARCHAICNUMBERS");

        /**
         * Constant for the "Khojki" Unicode character block.
         * @since 9
         */
        public static final UnicodeBlock KHOJKI =
            new UnicodeBlock("KHOJKI");

        /**
         * Constant for the "Khudawadi" Unicode character block.
         * @since 9
         */
        public static final UnicodeBlock KHUDAWADI =
            new UnicodeBlock("KHUDAWADI");

        /**
         * Constant for the "Grantha" Unicode character block.
         * @since 9
         */
        public static final UnicodeBlock GRANTHA =
            new UnicodeBlock("GRANTHA");

        /**
         * Constant for the "Tirhuta" Unicode character block.
         * @since 9
         */
        public static final UnicodeBlock TIRHUTA =
            new UnicodeBlock("TIRHUTA");

        /**
         * Constant for the "Siddham" Unicode character block.
         * @since 9
         */
        public static final UnicodeBlock SIDDHAM =
            new UnicodeBlock("SIDDHAM");

        /**
         * Constant for the "Modi" Unicode character block.
         * @since 9
         */
        public static final UnicodeBlock MODI =
            new UnicodeBlock("MODI");

        /**
         * Constant for the "Warang Citi" Unicode character block.
         * @since 9
         */
        public static final UnicodeBlock WARANG_CITI =
            new UnicodeBlock("WARANG_CITI",
                             "WARANG CITI",
                             "WARANGCITI");

        /**
         * Constant for the "Pau Cin Hau" Unicode character block.
         * @since 9
         */
        public static final UnicodeBlock PAU_CIN_HAU =
            new UnicodeBlock("PAU_CIN_HAU",
                             "PAU CIN HAU",
                             "PAUCINHAU");

        /**
         * Constant for the "Mro" Unicode character block.
         * @since 9
         */
        public static final UnicodeBlock MRO =
            new UnicodeBlock("MRO");

        /**
         * Constant for the "Bassa Vah" Unicode character block.
         * @since 9
         */
        public static final UnicodeBlock BASSA_VAH =
            new UnicodeBlock("BASSA_VAH",
                             "BASSA VAH",
                             "BASSAVAH");

        /**
         * Constant for the "Pahawh Hmong" Unicode character block.
         * @since 9
         */
        public static final UnicodeBlock PAHAWH_HMONG =
            new UnicodeBlock("PAHAWH_HMONG",
                             "PAHAWH HMONG",
                             "PAHAWHHMONG");

        /**
         * Constant for the "Duployan" Unicode character block.
         * @since 9
         */
        public static final UnicodeBlock DUPLOYAN =
            new UnicodeBlock("DUPLOYAN");

        /**
         * Constant for the "Shorthand Format Controls" Unicode character block.
         * @since 9
         */
        public static final UnicodeBlock SHORTHAND_FORMAT_CONTROLS =
            new UnicodeBlock("SHORTHAND_FORMAT_CONTROLS",
                             "SHORTHAND FORMAT CONTROLS",
                             "SHORTHANDFORMATCONTROLS");

        /**
         * Constant for the "Mende Kikakui" Unicode character block.
         * @since 9
         */
        public static final UnicodeBlock MENDE_KIKAKUI =
            new UnicodeBlock("MENDE_KIKAKUI",
                             "MENDE KIKAKUI",
                             "MENDEKIKAKUI");

        /**
         * Constant for the "Ornamental Dingbats" Unicode character block.
         * @since 9
         */
        public static final UnicodeBlock ORNAMENTAL_DINGBATS =
            new UnicodeBlock("ORNAMENTAL_DINGBATS",
                             "ORNAMENTAL DINGBATS",
                             "ORNAMENTALDINGBATS");

        /**
         * Constant for the "Geometric Shapes Extended" Unicode character block.
         * @since 9
         */
        public static final UnicodeBlock GEOMETRIC_SHAPES_EXTENDED =
            new UnicodeBlock("GEOMETRIC_SHAPES_EXTENDED",
                             "GEOMETRIC SHAPES EXTENDED",
                             "GEOMETRICSHAPESEXTENDED");

        /**
         * Constant for the "Supplemental Arrows-C" Unicode character block.
         * @since 9
         */
        public static final UnicodeBlock SUPPLEMENTAL_ARROWS_C =
            new UnicodeBlock("SUPPLEMENTAL_ARROWS_C",
                             "SUPPLEMENTAL ARROWS-C",
                             "SUPPLEMENTALARROWS-C");

        /**
         * Constant for the "Cherokee Supplement" Unicode character block.
         * @since 9
         */
        public static final UnicodeBlock CHEROKEE_SUPPLEMENT =
            new UnicodeBlock("CHEROKEE_SUPPLEMENT",
                             "CHEROKEE SUPPLEMENT",
                             "CHEROKEESUPPLEMENT");

        /**
         * Constant for the "Hatran" Unicode character block.
         * @since 9
         */
        public static final UnicodeBlock HATRAN =
            new UnicodeBlock("HATRAN");

        /**
         * Constant for the "Old Hungarian" Unicode character block.
         * @since 9
         */
        public static final UnicodeBlock OLD_HUNGARIAN =
            new UnicodeBlock("OLD_HUNGARIAN",
                             "OLD HUNGARIAN",
                             "OLDHUNGARIAN");

        /**
         * Constant for the "Multani" Unicode character block.
         * @since 9
         */
        public static final UnicodeBlock MULTANI =
            new UnicodeBlock("MULTANI");

        /**
         * Constant for the "Ahom" Unicode character block.
         * @since 9
         */
        public static final UnicodeBlock AHOM =
            new UnicodeBlock("AHOM");

        /**
         * Constant for the "Early Dynastic Cuneiform" Unicode character block.
         * @since 9
         */
        public static final UnicodeBlock EARLY_DYNASTIC_CUNEIFORM =
            new UnicodeBlock("EARLY_DYNASTIC_CUNEIFORM",
                             "EARLY DYNASTIC CUNEIFORM",
                             "EARLYDYNASTICCUNEIFORM");

        /**
         * Constant for the "Anatolian Hieroglyphs" Unicode character block.
         * @since 9
         */
        public static final UnicodeBlock ANATOLIAN_HIEROGLYPHS =
            new UnicodeBlock("ANATOLIAN_HIEROGLYPHS",
                             "ANATOLIAN HIEROGLYPHS",
                             "ANATOLIANHIEROGLYPHS");

        /**
         * Constant for the "Sutton SignWriting" Unicode character block.
         * @since 9
         */
        public static final UnicodeBlock SUTTON_SIGNWRITING =
            new UnicodeBlock("SUTTON_SIGNWRITING",
                             "SUTTON SIGNWRITING",
                             "SUTTONSIGNWRITING");

        /**
         * Constant for the "Supplemental Symbols and Pictographs" Unicode
         * character block.
         * @since 9
         */
        public static final UnicodeBlock SUPPLEMENTAL_SYMBOLS_AND_PICTOGRAPHS =
            new UnicodeBlock("SUPPLEMENTAL_SYMBOLS_AND_PICTOGRAPHS",
                             "SUPPLEMENTAL SYMBOLS AND PICTOGRAPHS",
                             "SUPPLEMENTALSYMBOLSANDPICTOGRAPHS");

        /**
         * Constant for the "CJK Unified Ideographs Extension E" Unicode
         * character block.
         * @since 9
         */
        public static final UnicodeBlock CJK_UNIFIED_IDEOGRAPHS_EXTENSION_E =
            new UnicodeBlock("CJK_UNIFIED_IDEOGRAPHS_EXTENSION_E",
                             "CJK UNIFIED IDEOGRAPHS EXTENSION E",
                             "CJKUNIFIEDIDEOGRAPHSEXTENSIONE");

        /**
         * Unicode script "Caucasian Albanian".
         * @since 9
         */
        CAUCASIAN_ALBANIAN,

        /**
         * Unicode script "Bassa Vah".
         * @since 9
         */
        BASSA_VAH,

        /**
         * Unicode script "Duployan".
         * @since 9
         */
        DUPLOYAN,

        /**
         * Unicode script "Elbasan".
         * @since 9
         */
        ELBASAN,

        /**
         * Unicode script "Grantha".
         * @since 9
         */
        GRANTHA,

        /**
         * Unicode script "Pahawh Hmong".
         * @since 9
         */
        PAHAWH_HMONG,

        /**
         * Unicode script "Khojki".
         * @since 9
         */
        KHOJKI,

        /**
         * Unicode script "Linear A".
         * @since 9
         */
        LINEAR_A,

        /**
         * Unicode script "Mahajani".
         * @since 9
         */
        MAHAJANI,

        /**
         * Unicode script "Manichaean".
         * @since 9
         */
        MANICHAEAN,

        /**
         * Unicode script "Mende Kikakui".
         * @since 9
         */
        MENDE_KIKAKUI,

        /**
         * Unicode script "Modi".
         * @since 9
         */
        MODI,

        /**
         * Unicode script "Mro".
         * @since 9
         */
        MRO,

        /**
         * Unicode script "Old North Arabian".
         * @since 9
         */
        OLD_NORTH_ARABIAN,

        /**
         * Unicode script "Nabataean".
         * @since 9
         */
        NABATAEAN,

        /**
         * Unicode script "Palmyrene".
         * @since 9
         */
        PALMYRENE,

        /**
         * Unicode script "Pau Cin Hau".
         * @since 9
         */
        PAU_CIN_HAU,

        /**
         * Unicode script "Old Permic".
         * @since 9
         */
        OLD_PERMIC,

        /**
         * Unicode script "Psalter Pahlavi".
         * @since 9
         */
        PSALTER_PAHLAVI,

        /**
         * Unicode script "Siddham".
         * @since 9
         */
        SIDDHAM,

        /**
         * Unicode script "Khudawadi".
         * @since 9
         */
        KHUDAWADI,

        /**
         * Unicode script "Tirhuta".
         * @since 9
         */
        TIRHUTA,

        /**
         * Unicode script "Warang Citi".
         * @since 9
         */
        WARANG_CITI,

         /**
         * Unicode script "Ahom".
         * @since 9
         */
        AHOM,

        /**
         * Unicode script "Anatolian Hieroglyphs".
         * @since 9
         */
        ANATOLIAN_HIEROGLYPHS,

        /**
         * Unicode script "Hatran".
         * @since 9
         */
        HATRAN,

        /**
         * Unicode script "Multani".
         * @since 9
         */
        MULTANI,

        /**
         * Unicode script "Old Hungarian".
         * @since 9
         */
        OLD_HUNGARIAN,

        /**
         * Unicode script "SignWriting".
         * @since 9
         */
        SIGNWRITING,

        /**
         * Unicode script "Unknown".
         */
        UNKNOWN;

    /**
     * Returns the code point value of the Unicode character specified by
     * the given Unicode character name.
     * <p>
     * Note: if a character is not assigned a name by the <i>UnicodeData</i>
     * file (part of the Unicode Character Database maintained by the Unicode
     * Consortium), its name is defined as the result of expression
     *
     * <blockquote>{@code
     *     Character.UnicodeBlock.of(codePoint).toString().replace('_', ' ')
     *     + " "
     *     + Integer.toHexString(codePoint).toUpperCase(Locale.ROOT);
     *
     * }</blockquote>
     * <p>
     * The {@code name} matching is case insensitive, with any leading and
     * trailing whitespace character removed.
     *
     * @param  name the Unicode character name
     *
     * @return the code point value of the character specified by its name.
     *
     * @throws IllegalArgumentException if the specified {@code name}
     *         is not a valid Unicode character name.
     * @throws NullPointerException if {@code name} is {@code null}
     *
     * @since 9
     */
    public static int codePointOf(String name) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\Class.java
    /**
     * Returns the {@code Class} with the given <a href="ClassLoader.html#name">
     * binary name</a> in the given module.
     *
     * <p> This method attempts to locate, load, and link the class or interface.
     * It does not run the class initializer.  If the class is not found, this
     * method returns {@code null}. </p>
     *
     * <p> If the class loader of the given module defines other modules and
     * the given name is a class defined in a different module, this method
     * returns {@code null} after the class is loaded. </p>
     *
     * <p> This method does not check whether the requested class is
     * accessible to its caller. </p>
     *
     * @apiNote
     * This method returns {@code null} on failure rather than
     * throwing a {@link ClassNotFoundException}, as is done by
     * the {@link #forName(String, boolean, ClassLoader)} method.
     * The security check is a stack-based permission check if the caller
     * loads a class in another module.
     *
     * @param  module   A module
     * @param  name     The <a href="ClassLoader.html#name">binary name</a>
     *                  of the class
     * @return {@code Class} object of the given name defined in the given module;
     *         {@code null} if not found.
     *
     * @throws NullPointerException if the given module or name is {@code null}
     *
     * @throws LinkageError if the linkage fails
     *
     * @throws SecurityException
     *         <ul>
     *         <li> if the caller is not the specified module and
     *         {@code RuntimePermission("getClassLoader")} permission is denied; or</li>
     *         <li> access to the module content is denied. For example,
     *         permission check will be performed when a class loader calls
     *         {@link ModuleReader#open(String)} to read the bytes of a class file
     *         in a module.</li>
     *         </ul>
     *
     * @since 9
     */
    @CallerSensitive
    public static Class<?> forName(Module module, String name) {

    /**
     * Returns the module that this class or interface is a member of.
     *
     * If this class represents an array type then this method returns the
     * {@code Module} for the element type. If this class represents a
     * primitive type or void, then the {@code Module} object for the
     * {@code java.base} module is returned.
     *
     * If this class is in an unnamed module then the {@link
     * ClassLoader#getUnnamedModule() unnamed} {@code Module} of the class
     * loader for this class is returned.
     *
     * @return the module that this class or interface is a member of
     *
     * @since 9
     */
    public Module getModule() {

    /**
     * Returns the fully qualified package name.
     *
     * <p> If this class is a top level class, then this method returns the fully
     * qualified name of the package that the class is a member of, or the
     * empty string if the class is in an unnamed package.
     *
     * <p> If this class is a member class, then this method is equivalent to
     * invoking {@code getPackageName()} on the {@link #getEnclosingClass
     * enclosing class}.
     *
     * <p> If this class is a {@link #isLocalClass local class} or an {@link
     * #isAnonymousClass() anonymous class}, then this method is equivalent to
     * invoking {@code getPackageName()} on the {@link #getDeclaringClass
     * declaring class} of the {@link #getEnclosingMethod enclosing method} or
     * {@link #getEnclosingConstructor enclosing constructor}.
     *
     * <p> This method returns {@code null} if this class represents an array type,
     * a primitive type or void.
     *
     * @return the fully qualified package name
     *
     * @since 9
     * @jls 6.7  Fully Qualified Names
     */
    public String getPackageName() {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\ClassLoader.java
    /**
     * Finds the class with the given <a href="#name">binary name</a>
     * in a module defined to this class loader.
     * Class loader implementations that support the loading from modules
     * should override this method.
     *
     * @apiNote This method returns {@code null} rather than throwing
     *          {@code ClassNotFoundException} if the class could not be found
     *
     * @implSpec The default implementation returns {@code null}.
     *
     * @param  moduleName
     *         The module name
     * @param  name
     *         The <a href="#name">binary name</a> of the class
     *
     * @return The resulting {@code Class} object, or {@code null}
     *         if the class could not be found.
     *
     * @since 9
     */
    protected Class<?> findClass(String moduleName, String name) {

    /**
     * Returns a URL to a resource in a module defined to this class loader.
     * Class loader implementations that support the loading from modules
     * should override this method.
     *
     * @implSpec The default implementation returns {@code null}.
     *
     * @param  moduleName
     *         The module name
     * @param  name
     *         The resource name
     *
     * @return A URL to the resource; {@code null} if the resource could not be
     *         found, a URL could not be constructed to locate the resource,
     *         access to the resource is denied by the security manager, or
     *         there isn't a module of the given name defined to the class
     *         loader.
     *
     * @throws IOException
     *         If I/O errors occur
     *
     * @see java.lang.module.ModuleReader#find(String)
     * @since 9
     */
    protected URL findResource(String moduleName, String name) throws IOException {

    /**
     * Returns the unnamed {@code Module} for this class loader.
     *
     * @return The unnamed Module for this class loader
     *
     * @see Module#isNamed()
     * @since 9
     */
    public final Module getUnnamedModule() {

    /**
     * Returns the platform class loader for delegation.  All
     * <a href="#builtinLoaders">platform classes</a> are visible to
     * the platform class loader.
     *
     * @return  The platform {@code ClassLoader}.
     *
     * @throws  SecurityException
     *          If a security manager is present, and the caller's class loader is
     *          not {@code null}, and the caller's class loader is not the same
     *          as or an ancestor of the platform class loader,
     *          and the caller does not have the
     *          {@link RuntimePermission}{@code ("getClassLoader")}
     *
     * @since 9
     */
    @CallerSensitive
    public static ClassLoader getPlatformClassLoader() {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\Deprecated.java
    /**
     * Returns the version in which the annotated element became deprecated.
     * The version string is in the same format and namespace as the value of
     * the {@code &#64;since} javadoc tag. The default value is the empty
     * string.
     *
     * @return the version string
     * @since 9
     */
    String since() default "";

    /**
     * Indicates whether the annotated element is subject to removal in a
     * future version. The default value is {@code false}.
     *
     * @return whether the element is subject to removal
     * @since 9
     */
    boolean forRemoval() default false;

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\IndexOutOfBoundsException.java
    /**
     * Constructs a new {@code IndexOutOfBoundsException} class with an
     * argument indicating the illegal index.
     *
     * <p>The index is included in this exception's detail message.  The
     * exact presentation format of the detail message is unspecified.
     *
     * @param index the illegal index.
     * @since 9
     */
    public IndexOutOfBoundsException(int index) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\instrument\Instrumentation.java
    /**
     * Updates a module to read another module.
     *
     * Agents that instrument code in named modules may need to arrange for the
     * modules to read other modules. This method is equivalent to code in {@code
     * module} calling {@link Module#addReads(Module) addReads} to read {@code
     * other}.
     *
     * @param module the module to update
     * @param other the module to read
     * @throws NullPointerException if either module is {@code null}
     *
     * @since 9
     * @see Module#canRead(Module)
     */
    void addModuleReads(Module module, Module other);

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\invoke\MethodHandle.java
    /**
     * Makes an <em>array-spreading</em> method handle, which accepts an array argument at a given position and spreads
     * its elements as positional arguments in place of the array. The new method handle adapts, as its <i>target</i>,
     * the current method handle. The type of the adapter will be the same as the type of the target, except that the
     * {@code arrayLength} parameters of the target's type, starting at the zero-based position {@code spreadArgPos},
     * are replaced by a single array parameter of type {@code arrayType}.
     * <p>
     * This method behaves very much like {@link #asSpreader(Class, int)}, but accepts an additional {@code spreadArgPos}
     * argument to indicate at which position in the parameter list the spreading should take place.
     * <p>
     * @apiNote Example:
     * <blockquote><pre>{@code
    MethodHandle compare = LOOKUP.findStatic(Objects.class, "compare", methodType(int.class, Object.class, Object.class, Comparator.class));
    MethodHandle compare2FromArray = compare.asSpreader(0, Object[].class, 2);
    Object[] ints = new Object[]{3, 9, 7, 7};
    Comparator<Integer> cmp = (a, b) -> a - b;
    assertTrue((int) compare2FromArray.invoke(Arrays.copyOfRange(ints, 0, 2), cmp) < 0);
    assertTrue((int) compare2FromArray.invoke(Arrays.copyOfRange(ints, 1, 3), cmp) > 0);
    assertTrue((int) compare2FromArray.invoke(Arrays.copyOfRange(ints, 2, 4), cmp) == 0);
     * }</pre></blockquote>
     * @param spreadArgPos the position (zero-based index) in the argument list at which spreading should start.
     * @param arrayType usually {@code Object[]}, the type of the array argument from which to extract the spread arguments
     * @param arrayLength the number of arguments to spread from an incoming array argument
     * @return a new method handle which spreads an array argument at a given position,
     *         before calling the original method handle
     * @throws NullPointerException if {@code arrayType} is a null reference
     * @throws IllegalArgumentException if {@code arrayType} is not an array type,
     *         or if target does not have at least
     *         {@code arrayLength} parameter types,
     *         or if {@code arrayLength} is negative,
     *         or if {@code spreadArgPos} has an illegal value (negative, or together with arrayLength exceeding the
     *         number of arguments),
     *         or if the resulting method handle's type would have
     *         <a href="MethodHandle.html#maxarity">too many parameters</a>
     * @throws WrongMethodTypeException if the implied {@code asType} call fails
     *
     * @see #asSpreader(Class, int)
     * @since 9
     */
    public MethodHandle asSpreader(int spreadArgPos, Class<?> arrayType, int arrayLength) {

    /**
      * Adapts this method handle to be {@linkplain #asVarargsCollector variable arity}
      * if the boolean flag is true, else {@linkplain #asFixedArity fixed arity}.
      * If the method handle is already of the proper arity mode, it is returned
      * unchanged.
      * @apiNote
      * <p>This method is sometimes useful when adapting a method handle that
      * may be variable arity, to ensure that the resulting adapter is also
      * variable arity if and only if the original handle was.  For example,
      * this code changes the first argument of a handle {@code mh} to {@code int} without
      * disturbing its variable arity property:
      * {@code mh.asType(mh.type().changeParameterType(0,int.class))
      *     .withVarargs(mh.isVarargsCollector())}
      * @param makeVarargs true if the return method handle should have variable arity behavior
      * @return a method handle of the same type, with possibly adjusted variable arity behavior
      * @throws IllegalArgumentException if {@code makeVarargs} is true and
      *         this method handle does not have a trailing array parameter
      * @since 9
      * @see #asVarargsCollector
      * @see #asFixedArity
     */
     public MethodHandle withVarargs(boolean makeVarargs) {

    /**
     * Makes an <em>array-collecting</em> method handle, which accepts a given number of positional arguments starting
     * at a given position, and collects them into an array argument. The new method handle adapts, as its
     * <i>target</i>, the current method handle. The type of the adapter will be the same as the type of the target,
     * except that the parameter at the position indicated by {@code collectArgPos} (usually of type {@code arrayType})
     * is replaced by {@code arrayLength} parameters whose type is element type of {@code arrayType}.
     * <p>
     * This method behaves very much like {@link #asCollector(Class, int)}, but differs in that its {@code
     * collectArgPos} argument indicates at which position in the parameter list arguments should be collected. This
     * index is zero-based.
     * <p>
     * @apiNote Examples:
     * <blockquote><pre>{@code
    StringWriter swr = new StringWriter();
    MethodHandle swWrite = LOOKUP.findVirtual(StringWriter.class, "write", methodType(void.class, char[].class, int.class, int.class)).bindTo(swr);
    MethodHandle swWrite4 = swWrite.asCollector(0, char[].class, 4);
    swWrite4.invoke('A', 'B', 'C', 'D', 1, 2);
    assertEquals("BC", swr.toString());
    swWrite4.invoke('P', 'Q', 'R', 'S', 0, 4);
    assertEquals("BCPQRS", swr.toString());
    swWrite4.invoke('W', 'X', 'Y', 'Z', 3, 1);
    assertEquals("BCPQRSZ", swr.toString());
     * }</pre></blockquote>
     * <p>
     * <em>Note:</em> The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector
     * variable-arity method handle}, even if the original target method handle was.
     * @param collectArgPos the zero-based position in the parameter list at which to start collecting.
     * @param arrayType often {@code Object[]}, the type of the array argument which will collect the arguments
     * @param arrayLength the number of arguments to collect into a new array argument
     * @return a new method handle which collects some arguments
     *         into an array, before calling the original method handle
     * @throws NullPointerException if {@code arrayType} is a null reference
     * @throws IllegalArgumentException if {@code arrayType} is not an array type
     *         or {@code arrayType} is not assignable to this method handle's array parameter type,
     *         or {@code arrayLength} is not a legal array size,
     *         or {@code collectArgPos} has an illegal value (negative, or greater than the number of arguments),
     *         or the resulting method handle's type would have
     *         <a href="MethodHandle.html#maxarity">too many parameters</a>
     * @throws WrongMethodTypeException if the implied {@code asType} call fails
     *
     * @see #asCollector(Class, int)
     * @since 9
     */
    public MethodHandle asCollector(int collectArgPos, Class<?> arrayType, int arrayLength) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\invoke\MethodHandles.java
        /** A single-bit mask representing {@code module} access (default access),
         *  which may contribute to the result of {@link #lookupModes lookupModes}.
         *  The value is {@code 0x10}, which does not correspond meaningfully to
         *  any particular {@linkplain java.lang.reflect.Modifier modifier bit}.
         *  In conjunction with the {@code PUBLIC} modifier bit, a {@code Lookup}
         *  with this lookup mode can access all public types in the module of the
         *  lookup class and public types in packages exported by other modules
         *  to the module of the lookup class.
         *  @since 9
         */
        public static final int MODULE = PACKAGE << 1;

        /**
         * Looks up a class by name from the lookup context defined by this {@code Lookup} object. The static
         * initializer of the class is not run.
         * <p>
         * The lookup context here is determined by the {@linkplain #lookupClass() lookup class}, its class
         * loader, and the {@linkplain #lookupModes() lookup modes}. In particular, the method first attempts to
         * load the requested class, and then determines whether the class is accessible to this lookup object.
         *
         * @param targetName the fully qualified name of the class to be looked up.
         * @return the requested class.
         * @exception SecurityException if a security manager is present and it
         *            <a href="MethodHandles.Lookup.html#secmgr">refuses access</a>
         * @throws LinkageError if the linkage fails
         * @throws ClassNotFoundException if the class cannot be loaded by the lookup class' loader.
         * @throws IllegalAccessException if the class is not accessible, using the allowed access
         * modes.
         * @exception SecurityException if a security manager is present and it
         *                              <a href="MethodHandles.Lookup.html#secmgr">refuses access</a>
         * @since 9
         */
        public Class<?> findClass(String targetName) throws ClassNotFoundException, IllegalAccessException {

        /**
         * Determines if a class can be accessed from the lookup context defined by this {@code Lookup} object. The
         * static initializer of the class is not run.
         * <p>
         * The lookup context here is determined by the {@linkplain #lookupClass() lookup class} and the
         * {@linkplain #lookupModes() lookup modes}.
         *
         * @param targetClass the class to be access-checked
         *
         * @return the class that has been access-checked
         *
         * @throws IllegalAccessException if the class is not accessible from the lookup class, using the allowed access
         * modes.
         * @exception SecurityException if a security manager is present and it
         *                              <a href="MethodHandles.Lookup.html#secmgr">refuses access</a>
         * @since 9
         */
        public Class<?> accessClass(Class<?> targetClass) throws IllegalAccessException {

        /**
         * Produces a VarHandle giving access to non-static fields of type
         * {@code T} declared by a receiver class of type {@code R}, supporting
         * shape {@code (R : T)}.
         * <p>
         * Access checking is performed immediately on behalf of the lookup
         * class.
         * <p>
         * Certain access modes of the returned VarHandle are unsupported under
         * the following conditions:
         * <ul>
         * <li>if the field is declared {@code final}, then the write, atomic
         *     update, numeric atomic update, and bitwise atomic update access
         *     modes are unsupported.
         * <li>if the field type is anything other than {@code byte},
         *     {@code short}, {@code char}, {@code int}, {@code long},
         *     {@code float}, or {@code double} then numeric atomic update
         *     access modes are unsupported.
         * <li>if the field type is anything other than {@code boolean},
         *     {@code byte}, {@code short}, {@code char}, {@code int} or
         *     {@code long} then bitwise atomic update access modes are
         *     unsupported.
         * </ul>
         * <p>
         * If the field is declared {@code volatile} then the returned VarHandle
         * will override access to the field (effectively ignore the
         * {@code volatile} declaration) in accordance to it's specified
         * access modes.
         * <p>
         * If the field type is {@code float} or {@code double} then numeric
         * and atomic update access modes compare values using their bitwise
         * representation (see {@link Float#floatToRawIntBits} and
         * {@link Double#doubleToRawLongBits}, respectively).
         * @apiNote
         * Bitwise comparison of {@code float} values or {@code double} values,
         * as performed by the numeric and atomic update access modes, differ
         * from the primitive {@code ==} operator and the {@link Float#equals}
         * and {@link Double#equals} methods, specifically with respect to
         * comparing NaN values or comparing {@code -0.0} with {@code +0.0}.
         * Care should be taken when performing a compare and set or a compare
         * and exchange operation with such values since the operation may
         * unexpectedly fail.
         * There are many possible NaN values that are considered to be
         * {@code NaN} in Java, although no IEEE 754 floating-point operation
         * provided by Java can distinguish between them.  Operation failure can
         * occur if the expected or witness value is a NaN value and it is
         * transformed (perhaps in a platform specific manner) into another NaN
         * value, and thus has a different bitwise representation (see
         * {@link Float#intBitsToFloat} or {@link Double#longBitsToDouble} for more
         * details).
         * The values {@code -0.0} and {@code +0.0} have different bitwise
         * representations but are considered equal when using the primitive
         * {@code ==} operator.  Operation failure can occur if, for example, a
         * numeric algorithm computes an expected value to be say {@code -0.0}
         * and previously computed the witness value to be say {@code +0.0}.
         * @param recv the receiver class, of type {@code R}, that declares the
         * non-static field
         * @param name the field's name
         * @param type the field's type, of type {@code T}
         * @return a VarHandle giving access to non-static fields.
         * @throws NoSuchFieldException if the field does not exist
         * @throws IllegalAccessException if access checking fails, or if the field is {@code static}
         * @exception SecurityException if a security manager is present and it
         *                              <a href="MethodHandles.Lookup.html#secmgr">refuses access</a>
         * @throws NullPointerException if any argument is null
         * @since 9
         */
        public VarHandle findVarHandle(Class<?> recv, String name, Class<?> type) throws NoSuchFieldException, IllegalAccessException {

        /**
         * Produces a VarHandle giving access to a static field of type
         * {@code T} declared by a given declaring class, supporting shape
         * {@code ((empty) : T)}.
         * <p>
         * Access checking is performed immediately on behalf of the lookup
         * class.
         * <p>
         * If the returned VarHandle is operated on, the declaring class will be
         * initialized, if it has not already been initialized.
         * <p>
         * Certain access modes of the returned VarHandle are unsupported under
         * the following conditions:
         * <ul>
         * <li>if the field is declared {@code final}, then the write, atomic
         *     update, numeric atomic update, and bitwise atomic update access
         *     modes are unsupported.
         * <li>if the field type is anything other than {@code byte},
         *     {@code short}, {@code char}, {@code int}, {@code long},
         *     {@code float}, or {@code double}, then numeric atomic update
         *     access modes are unsupported.
         * <li>if the field type is anything other than {@code boolean},
         *     {@code byte}, {@code short}, {@code char}, {@code int} or
         *     {@code long} then bitwise atomic update access modes are
         *     unsupported.
         * </ul>
         * <p>
         * If the field is declared {@code volatile} then the returned VarHandle
         * will override access to the field (effectively ignore the
         * {@code volatile} declaration) in accordance to it's specified
         * access modes.
         * <p>
         * If the field type is {@code float} or {@code double} then numeric
         * and atomic update access modes compare values using their bitwise
         * representation (see {@link Float#floatToRawIntBits} and
         * {@link Double#doubleToRawLongBits}, respectively).
         * @apiNote
         * Bitwise comparison of {@code float} values or {@code double} values,
         * as performed by the numeric and atomic update access modes, differ
         * from the primitive {@code ==} operator and the {@link Float#equals}
         * and {@link Double#equals} methods, specifically with respect to
         * comparing NaN values or comparing {@code -0.0} with {@code +0.0}.
         * Care should be taken when performing a compare and set or a compare
         * and exchange operation with such values since the operation may
         * unexpectedly fail.
         * There are many possible NaN values that are considered to be
         * {@code NaN} in Java, although no IEEE 754 floating-point operation
         * provided by Java can distinguish between them.  Operation failure can
         * occur if the expected or witness value is a NaN value and it is
         * transformed (perhaps in a platform specific manner) into another NaN
         * value, and thus has a different bitwise representation (see
         * {@link Float#intBitsToFloat} or {@link Double#longBitsToDouble} for more
         * details).
         * The values {@code -0.0} and {@code +0.0} have different bitwise
         * representations but are considered equal when using the primitive
         * {@code ==} operator.  Operation failure can occur if, for example, a
         * numeric algorithm computes an expected value to be say {@code -0.0}
         * and previously computed the witness value to be say {@code +0.0}.
         * @param decl the class that declares the static field
         * @param name the field's name
         * @param type the field's type, of type {@code T}
         * @return a VarHandle giving access to a static field
         * @throws NoSuchFieldException if the field does not exist
         * @throws IllegalAccessException if access checking fails, or if the field is not {@code static}
         * @exception SecurityException if a security manager is present and it
         *                              <a href="MethodHandles.Lookup.html#secmgr">refuses access</a>
         * @throws NullPointerException if any argument is null
         * @since 9
         */
        public VarHandle findStaticVarHandle(Class<?> decl, String name, Class<?> type) throws NoSuchFieldException, IllegalAccessException {

        /**
         * Produces a VarHandle that accesses fields of type {@code T} declared
         * by a class of type {@code R}, as described by the given reflected
         * field.
         * If the field is non-static the VarHandle supports a shape of
         * {@code (R : T)}, otherwise supports a shape of {@code ((empty) : T)}.
         * <p>
         * Access checking is performed immediately on behalf of the lookup
         * class, regardless of the value of the field's {@code accessible}
         * flag.
         * <p>
         * If the field is static, and if the returned VarHandle is operated
         * on, the field's declaring class will be initialized, if it has not
         * already been initialized.
         * <p>
         * Certain access modes of the returned VarHandle are unsupported under
         * the following conditions:
         * <ul>
         * <li>if the field is declared {@code final}, then the write, atomic
         *     update, numeric atomic update, and bitwise atomic update access
         *     modes are unsupported.
         * <li>if the field type is anything other than {@code byte},
         *     {@code short}, {@code char}, {@code int}, {@code long},
         *     {@code float}, or {@code double} then numeric atomic update
         *     access modes are unsupported.
         * <li>if the field type is anything other than {@code boolean},
         *     {@code byte}, {@code short}, {@code char}, {@code int} or
         *     {@code long} then bitwise atomic update access modes are
         *     unsupported.
         * </ul>
         * <p>
         * If the field is declared {@code volatile} then the returned VarHandle
         * will override access to the field (effectively ignore the
         * {@code volatile} declaration) in accordance to it's specified
         * access modes.
         * <p>
         * If the field type is {@code float} or {@code double} then numeric
         * and atomic update access modes compare values using their bitwise
         * representation (see {@link Float#floatToRawIntBits} and
         * {@link Double#doubleToRawLongBits}, respectively).
         * @apiNote
         * Bitwise comparison of {@code float} values or {@code double} values,
         * as performed by the numeric and atomic update access modes, differ
         * from the primitive {@code ==} operator and the {@link Float#equals}
         * and {@link Double#equals} methods, specifically with respect to
         * comparing NaN values or comparing {@code -0.0} with {@code +0.0}.
         * Care should be taken when performing a compare and set or a compare
         * and exchange operation with such values since the operation may
         * unexpectedly fail.
         * There are many possible NaN values that are considered to be
         * {@code NaN} in Java, although no IEEE 754 floating-point operation
         * provided by Java can distinguish between them.  Operation failure can
         * occur if the expected or witness value is a NaN value and it is
         * transformed (perhaps in a platform specific manner) into another NaN
         * value, and thus has a different bitwise representation (see
         * {@link Float#intBitsToFloat} or {@link Double#longBitsToDouble} for more
         * details).
         * The values {@code -0.0} and {@code +0.0} have different bitwise
         * representations but are considered equal when using the primitive
         * {@code ==} operator.  Operation failure can occur if, for example, a
         * numeric algorithm computes an expected value to be say {@code -0.0}
         * and previously computed the witness value to be say {@code +0.0}.
         * @param f the reflected field, with a field of type {@code T}, and
         * a declaring class of type {@code R}
         * @return a VarHandle giving access to non-static fields or a static
         * field
         * @throws IllegalAccessException if access checking fails
         * @throws NullPointerException if the argument is null
         * @since 9
         */
        public VarHandle unreflectVarHandle(Field f) throws IllegalAccessException {

    /**
     * Produces a method handle constructing arrays of a desired type.
     * The return type of the method handle will be the array type.
     * The type of its sole argument will be {@code int}, which specifies the size of the array.
     * @param arrayClass an array type
     * @return a method handle which can create arrays of the given type
     * @throws NullPointerException if the argument is {@code null}
     * @throws IllegalArgumentException if {@code arrayClass} is not an array type
     * @see java.lang.reflect.Array#newInstance(Class, int)
     * @since 9
     */
    public static
    MethodHandle arrayConstructor(Class<?> arrayClass) throws IllegalArgumentException {

    /**
     * Produces a method handle returning the length of an array.
     * The type of the method handle will have {@code int} as return type,
     * and its sole argument will be the array type.
     * @param arrayClass an array type
     * @return a method handle which can retrieve the length of an array of the given array type
     * @throws NullPointerException if the argument is {@code null}
     * @throws IllegalArgumentException if arrayClass is not an array type
     * @since 9
     */
    public static
    MethodHandle arrayLength(Class<?> arrayClass) throws IllegalArgumentException {

    /**
     *
     * Produces a VarHandle giving access to elements of an array type
     * {@code T[]}, supporting shape {@code (T[], int : T)}.
     * <p>
     * Certain access modes of the returned VarHandle are unsupported under
     * the following conditions:
     * <ul>
     * <li>if the component type is anything other than {@code byte},
     *     {@code short}, {@code char}, {@code int}, {@code long},
     *     {@code float}, or {@code double} then numeric atomic update access
     *     modes are unsupported.
     * <li>if the field type is anything other than {@code boolean},
     *     {@code byte}, {@code short}, {@code char}, {@code int} or
     *     {@code long} then bitwise atomic update access modes are
     *     unsupported.
     * </ul>
     * <p>
     * If the component type is {@code float} or {@code double} then numeric
     * and atomic update access modes compare values using their bitwise
     * representation (see {@link Float#floatToRawIntBits} and
     * {@link Double#doubleToRawLongBits}, respectively).
     * @apiNote
     * Bitwise comparison of {@code float} values or {@code double} values,
     * as performed by the numeric and atomic update access modes, differ
     * from the primitive {@code ==} operator and the {@link Float#equals}
     * and {@link Double#equals} methods, specifically with respect to
     * comparing NaN values or comparing {@code -0.0} with {@code +0.0}.
     * Care should be taken when performing a compare and set or a compare
     * and exchange operation with such values since the operation may
     * unexpectedly fail.
     * There are many possible NaN values that are considered to be
     * {@code NaN} in Java, although no IEEE 754 floating-point operation
     * provided by Java can distinguish between them.  Operation failure can
     * occur if the expected or witness value is a NaN value and it is
     * transformed (perhaps in a platform specific manner) into another NaN
     * value, and thus has a different bitwise representation (see
     * {@link Float#intBitsToFloat} or {@link Double#longBitsToDouble} for more
     * details).
     * The values {@code -0.0} and {@code +0.0} have different bitwise
     * representations but are considered equal when using the primitive
     * {@code ==} operator.  Operation failure can occur if, for example, a
     * numeric algorithm computes an expected value to be say {@code -0.0}
     * and previously computed the witness value to be say {@code +0.0}.
     * @param arrayClass the class of an array, of type {@code T[]}
     * @return a VarHandle giving access to elements of an array
     * @throws NullPointerException if the arrayClass is null
     * @throws IllegalArgumentException if arrayClass is not an array type
     * @since 9
     */
    public static
    VarHandle arrayElementVarHandle(Class<?> arrayClass) throws IllegalArgumentException {

    /**
     * Produces a VarHandle giving access to elements of a {@code byte[]} array
     * viewed as if it were a different primitive array type, such as
     * {@code int[]} or {@code long[]}.  The shape of the resulting VarHandle is
     * {@code (byte[], int : T)}, where the {@code int} coordinate type
     * corresponds to an argument that is an index in a {@code byte[]} array,
     * and {@code T} is the component type of the given view array class.  The
     * returned VarHandle accesses bytes at an index in a {@code byte[]} array,
     * composing bytes to or from a value of {@code T} according to the given
     * endianness.
     * <p>
     * The supported component types (variables types) are {@code short},
     * {@code char}, {@code int}, {@code long}, {@code float} and
     * {@code double}.
     * <p>
     * Access of bytes at a given index will result in an
     * {@code IndexOutOfBoundsException} if the index is less than {@code 0}
     * or greater than the {@code byte[]} array length minus the size (in bytes)
     * of {@code T}.
     * <p>
     * Access of bytes at an index may be aligned or misaligned for {@code T},
     * with respect to the underlying memory address, {@code A} say, associated
     * with the array and index.
     * If access is misaligned then access for anything other than the
     * {@code get} and {@code set} access modes will result in an
     * {@code IllegalStateException}.  In such cases atomic access is only
     * guaranteed with respect to the largest power of two that divides the GCD
     * of {@code A} and the size (in bytes) of {@code T}.
     * If access is aligned then following access modes are supported and are
     * guaranteed to support atomic access:
     * <ul>
     * <li>read write access modes for all {@code T}, with the exception of
     *     access modes {@code get} and {@code set} for {@code long} and
     *     {@code double} on 32-bit platforms.
     * <li>atomic update access modes for {@code int}, {@code long},
     *     {@code float} or {@code double}.
     *     (Future major platform releases of the JDK may support additional
     *     types for certain currently unsupported access modes.)
     * <li>numeric atomic update access modes for {@code int} and {@code long}.
     *     (Future major platform releases of the JDK may support additional
     *     numeric types for certain currently unsupported access modes.)
     * <li>bitwise atomic update access modes for {@code int} and {@code long}.
     *     (Future major platform releases of the JDK may support additional
     *     numeric types for certain currently unsupported access modes.)
     * </ul>
     * <p>
     * Misaligned access, and therefore atomicity guarantees, may be determined
     * for {@code byte[]} arrays without operating on a specific array.  Given
     * an {@code index}, {@code T} and it's corresponding boxed type,
     * {@code T_BOX}, misalignment may be determined as follows:
     * <pre>{@code
     * int sizeOfT = T_BOX.BYTES;  // size in bytes of T
     * int misalignedAtZeroIndex = ByteBuffer.wrap(new byte[0]).
     *     alignmentOffset(0, sizeOfT);
     * int misalignedAtIndex = (misalignedAtZeroIndex + index) % sizeOfT;
     * boolean isMisaligned = misalignedAtIndex != 0;
     * }</pre>
     * <p>
     * If the variable type is {@code float} or {@code double} then atomic
     * update access modes compare values using their bitwise representation
     * (see {@link Float#floatToRawIntBits} and
     * {@link Double#doubleToRawLongBits}, respectively).
     * @param viewArrayClass the view array class, with a component type of
     * type {@code T}
     * @param byteOrder the endianness of the view array elements, as
     * stored in the underlying {@code byte} array
     * @return a VarHandle giving access to elements of a {@code byte[]} array
     * viewed as if elements corresponding to the components type of the view
     * array class
     * @throws NullPointerException if viewArrayClass or byteOrder is null
     * @throws IllegalArgumentException if viewArrayClass is not an array type
     * @throws UnsupportedOperationException if the component type of
     * viewArrayClass is not supported as a variable type
     * @since 9
     */
    public static
    VarHandle byteArrayViewVarHandle(Class<?> viewArrayClass,
                                     ByteOrder byteOrder) throws IllegalArgumentException {

    /**
     * Produces a VarHandle giving access to elements of a {@code ByteBuffer}
     * viewed as if it were an array of elements of a different primitive
     * component type to that of {@code byte}, such as {@code int[]} or
     * {@code long[]}.  The shape of the resulting VarHandle is
     * {@code (ByteBuffer, int : T)}, where the {@code int} coordinate type
     * corresponds to an argument that is an index in a {@code ByteBuffer}, and
     * {@code T} is the component type of the given view array class.  The
     * returned VarHandle accesses bytes at an index in a {@code ByteBuffer},
     * composing bytes to or from a value of {@code T} according to the given
     * endianness.
     * <p>
     * The supported component types (variables types) are {@code short},
     * {@code char}, {@code int}, {@code long}, {@code float} and
     * {@code double}.
     * <p>
     * Access will result in a {@code ReadOnlyBufferException} for anything
     * other than the read access modes if the {@code ByteBuffer} is read-only.
     * <p>
     * Access of bytes at a given index will result in an
     * {@code IndexOutOfBoundsException} if the index is less than {@code 0}
     * or greater than the {@code ByteBuffer} limit minus the size (in bytes) of
     * {@code T}.
     * <p>
     * Access of bytes at an index may be aligned or misaligned for {@code T},
     * with respect to the underlying memory address, {@code A} say, associated
     * with the {@code ByteBuffer} and index.
     * If access is misaligned then access for anything other than the
     * {@code get} and {@code set} access modes will result in an
     * {@code IllegalStateException}.  In such cases atomic access is only
     * guaranteed with respect to the largest power of two that divides the GCD
     * of {@code A} and the size (in bytes) of {@code T}.
     * If access is aligned then following access modes are supported and are
     * guaranteed to support atomic access:
     * <ul>
     * <li>read write access modes for all {@code T}, with the exception of
     *     access modes {@code get} and {@code set} for {@code long} and
     *     {@code double} on 32-bit platforms.
     * <li>atomic update access modes for {@code int}, {@code long},
     *     {@code float} or {@code double}.
     *     (Future major platform releases of the JDK may support additional
     *     types for certain currently unsupported access modes.)
     * <li>numeric atomic update access modes for {@code int} and {@code long}.
     *     (Future major platform releases of the JDK may support additional
     *     numeric types for certain currently unsupported access modes.)
     * <li>bitwise atomic update access modes for {@code int} and {@code long}.
     *     (Future major platform releases of the JDK may support additional
     *     numeric types for certain currently unsupported access modes.)
     * </ul>
     * <p>
     * Misaligned access, and therefore atomicity guarantees, may be determined
     * for a {@code ByteBuffer}, {@code bb} (direct or otherwise), an
     * {@code index}, {@code T} and it's corresponding boxed type,
     * {@code T_BOX}, as follows:
     * <pre>{@code
     * int sizeOfT = T_BOX.BYTES;  // size in bytes of T
     * ByteBuffer bb = ...
     * int misalignedAtIndex = bb.alignmentOffset(index, sizeOfT);
     * boolean isMisaligned = misalignedAtIndex != 0;
     * }</pre>
     * <p>
     * If the variable type is {@code float} or {@code double} then atomic
     * update access modes compare values using their bitwise representation
     * (see {@link Float#floatToRawIntBits} and
     * {@link Double#doubleToRawLongBits}, respectively).
     * @param viewArrayClass the view array class, with a component type of
     * type {@code T}
     * @param byteOrder the endianness of the view array elements, as
     * stored in the underlying {@code ByteBuffer} (Note this overrides the
     * endianness of a {@code ByteBuffer})
     * @return a VarHandle giving access to elements of a {@code ByteBuffer}
     * viewed as if elements corresponding to the components type of the view
     * array class
     * @throws NullPointerException if viewArrayClass or byteOrder is null
     * @throws IllegalArgumentException if viewArrayClass is not an array type
     * @throws UnsupportedOperationException if the component type of
     * viewArrayClass is not supported as a variable type
     * @since 9
     */
    public static
    VarHandle byteBufferViewVarHandle(Class<?> viewArrayClass,
                                      ByteOrder byteOrder) throws IllegalArgumentException {

    /**
     * Produces a special <em>invoker method handle</em> which can be used to
     * invoke a signature-polymorphic access mode method on any VarHandle whose
     * associated access mode type is compatible with the given type.
     * The resulting invoker will have a type which is exactly equal to the
     * desired given type, except that it will accept an additional leading
     * argument of type {@code VarHandle}.
     *
     * @param accessMode the VarHandle access mode
     * @param type the desired target type
     * @return a method handle suitable for invoking an access mode method of
     *         any VarHandle whose access mode type is of the given type.
     * @since 9
     */
    static public
    MethodHandle varHandleExactInvoker(VarHandle.AccessMode accessMode, MethodType type) {

    /**
     * Produces a special <em>invoker method handle</em> which can be used to
     * invoke a signature-polymorphic access mode method on any VarHandle whose
     * associated access mode type is compatible with the given type.
     * The resulting invoker will have a type which is exactly equal to the
     * desired given type, except that it will accept an additional leading
     * argument of type {@code VarHandle}.
     * <p>
     * Before invoking its target, if the access mode type differs from the
     * desired given type, the invoker will apply reference casts as necessary
     * and box, unbox, or widen primitive values, as if by
     * {@link MethodHandle#asType asType}.  Similarly, the return value will be
     * converted as necessary.
     * <p>
     * This method is equivalent to the following code (though it may be more
     * efficient): {@code publicLookup().findVirtual(VarHandle.class, accessMode.name(), type)}
     *
     * @param accessMode the VarHandle access mode
     * @param type the desired target type
     * @return a method handle suitable for invoking an access mode method of
     *         any VarHandle whose access mode type is convertible to the given
     *         type.
     * @since 9
     */
    static public
    MethodHandle varHandleInvoker(VarHandle.AccessMode accessMode, MethodType type) {

    /**
     * Produces a constant method handle of the requested return type which
     * returns the default value for that type every time it is invoked.
     * The resulting constant method handle will have no side effects.
     * <p>The returned method handle is equivalent to {@code empty(methodType(type))}.
     * It is also equivalent to {@code explicitCastArguments(constant(Object.class, null), methodType(type))},
     * since {@code explicitCastArguments} converts {@code null} to default values.
     * @param type the expected return type of the desired method handle
     * @return a constant method handle that takes no arguments
     *         and returns the default value of the given type (or void, if the type is void)
     * @throws NullPointerException if the argument is null
     * @see MethodHandles#constant
     * @see MethodHandles#empty
     * @see MethodHandles#explicitCastArguments
     * @since 9
     */
    public static  MethodHandle zero(Class<?> type) {

    /**
     * Produces a method handle of the requested type which ignores any arguments, does nothing,
     * and returns a suitable default depending on the return type.
     * That is, it returns a zero primitive value, a {@code null}, or {@code void}.
     * <p>The returned method handle is equivalent to
     * {@code dropArguments(zero(type.returnType()), 0, type.parameterList())}.
     * <p>
     * @apiNote Given a predicate and target, a useful "if-then" construct can be produced as
     * {@code guardWithTest(pred, target, empty(target.type())}.
     * @param type the type of the desired method handle
     * @return a constant method handle of the given type, which returns a default value of the given return type
     * @throws NullPointerException if the argument is null
     * @see MethodHandles#zero
     * @see MethodHandles#constant
     * @since 9
     */
    public static  MethodHandle empty(MethodType type) {

    /**
     * Adapts a target method handle to match the given parameter type list, if necessary, by adding dummy arguments.
     * Some leading parameters are first skipped; they will be left unchanged and are otherwise ignored.
     * The remaining types in the target's parameter type list must be contained as a sub-list of the given type list,
     * at the given position.
     * Any non-matching parameter types (before or after the matching sub-list) are inserted in corresponding
     * positions of the target method handle's parameters, as if by {@link #dropArguments}.
     * (More precisely, elements in the new list before {@code pos} are inserted into the target list at {@code skip},
     * while elements in the new list after the match beginning at {@code pos} are inserted at the end of the
     * target list.)
     * The target's return type will be unchanged.
     * @apiNote
     * Two method handles whose argument lists are "effectively identical" (i.e., identical
     * in a common prefix) may be mutually converted to a common type
     * by two calls to {@code dropArgumentsToMatch}, as follows:
     * <blockquote><pre>{@code
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
...
MethodHandle h0 = constant(boolean.class, true);
MethodHandle h1 = lookup().findVirtual(String.class, "concat", methodType(String.class, String.class));
MethodType bigType = h1.type().insertParameterTypes(1, String.class, int.class);
MethodHandle h2 = dropArguments(h1, 0, bigType.parameterList());
if (h1.type().parameterCount() < h2.type().parameterCount())
    h1 = dropArgumentsToMatch(h1, 0, h2.type().parameterList(), 0);  // lengthen h1
else
    h2 = dropArgumentsToMatch(h2, 0, h1.type().parameterList(), 0);    // lengthen h2
MethodHandle h3 = guardWithTest(h0, h1, h2);
assertEquals("xy", h3.invoke("x", "y", 1, "a", "b", "c"));
     * }</pre></blockquote>
     * @param target the method handle to adapt
     * @param skip number of targets parameters to disregard (they will be unchanged)
     * @param newTypes the desired argument list of the method handle
     * @param pos place in {@code newTypes} where the non-skipped target parameters must occur
     * @return a possibly adapted method handle
     * @throws NullPointerException if either argument is null
     * @throws IllegalArgumentException if any element of {@code newTypes} is {@code void.class},
     *         or if {@code skip} is negative or greater than the arity of the target,
     *         or if {@code pos} is negative or greater than the newTypes list size,
     *         or if the non-skipped target parameter types match the new types at {@code pos}
     * @since 9
     */
    public static
    MethodHandle dropArgumentsToMatch(MethodHandle target, int skip, List<Class<?>> newTypes, int pos) {

    /**
     * Constructs a method handle representing a loop with several loop variables that are updated and checked upon each
     * iteration. Upon termination of the loop due to one of the predicates, a corresponding finalizer is run and
     * delivers the loop's result, which is the return value of the resulting handle.
     * <p>
     * Intuitively, every loop is formed by one or more "clauses", each specifying a local iteration value and/or a loop
     * exit. Each iteration of the loop executes each clause in order. A clause can optionally update its iteration
     * variable; it can also optionally perform a test and conditional loop exit. In order to express this logic in
     * terms of method handles, each clause will determine four actions:<ul>
     * <li>Before the loop executes, the initialization of an iteration variable or loop invariant local.
     * <li>When a clause executes, an update step for the iteration variable.
     * <li>When a clause executes, a predicate execution to test for loop exit.
     * <li>If a clause causes a loop exit, a finalizer execution to compute the loop's return value.
     * </ul>
     * <p>
     * Some of these clause parts may be omitted according to certain rules, and useful default behavior is provided in
     * this case. See below for a detailed description.
     * <p>
     * Each clause function, with the exception of clause initializers, is able to observe the entire loop state,
     * because it will be passed <em>all</em> current iteration variable values, as well as all incoming loop
     * parameters. Most clause functions will not need all of this information, but they will be formally connected as
     * if by {@link #dropArguments}.
     * <p>
     * Given a set of clauses, there is a number of checks and adjustments performed to connect all the parts of the
     * loop. They are spelled out in detail in the steps below. In these steps, every occurrence of the word "must"
     * corresponds to a place where {@link IllegalArgumentException} may be thrown if the required constraint is not met
     * by the inputs to the loop combinator. The term "effectively identical", applied to parameter type lists, means
     * that they must be identical, or else one list must be a proper prefix of the other.
     * <p>
     * <em>Step 0: Determine clause structure.</em><ol type="a">
     * <li>The clause array (of type {@code MethodHandle[][]} must be non-{@code null} and contain at least one element.
     * <li>The clause array may not contain {@code null}s or sub-arrays longer than four elements.
     * <li>Clauses shorter than four elements are treated as if they were padded by {@code null} elements to length
     * four. Padding takes place by appending elements to the array.
     * <li>Clauses with all {@code null}s are disregarded.
     * <li>Each clause is treated as a four-tuple of functions, called "init", "step", "pred", and "fini".
     * </ol>
     * <p>
     * <em>Step 1A: Determine iteration variables.</em><ol type="a">
     * <li>Examine init and step function return types, pairwise, to determine each clause's iteration variable type.
     * <li>If both functions are omitted, use {@code void}; else if one is omitted, use the other's return type; else
     * use the common return type (they must be identical).
     * <li>Form the list of return types (in clause order), omitting all occurrences of {@code void}.
     * <li>This list of types is called the "common prefix".
     * </ol>
     * <p>
     * <em>Step 1B: Determine loop parameters.</em><ul>
     * <li><b>If at least one init function is given,</b><ol type="a">
     *   <li>Examine init function parameter lists.
     *   <li>Omitted init functions are deemed to have {@code null} parameter lists.
     *   <li>All init function parameter lists must be effectively identical.
     *   <li>The longest parameter list (which is necessarily unique) is called the "common suffix".
     * </ol>
     * <li><b>If no init function is given,</b><ol type="a">
     *   <li>Examine the suffixes of the step, pred, and fini parameter lists, after removing the "common prefix".
     *   <li>The longest of these suffixes is taken as the "common suffix".
     * </ol></ul>
     * <p>
     * <em>Step 1C: Determine loop return type.</em><ol type="a">
     * <li>Examine fini function return types, disregarding omitted fini functions.
     * <li>If there are no fini functions, use {@code void} as the loop return type.
     * <li>Otherwise, use the common return type of the fini functions; they must all be identical.
     * </ol>
     * <p>
     * <em>Step 1D: Check other types.</em><ol type="a">
     * <li>There must be at least one non-omitted pred function.
     * <li>Every non-omitted pred function must have a {@code boolean} return type.
     * </ol>
     * <p>
     * <em>Step 2: Determine parameter lists.</em><ol type="a">
     * <li>The parameter list for the resulting loop handle will be the "common suffix".
     * <li>The parameter list for init functions will be adjusted to the "common suffix". (Note that their parameter
     * lists are already effectively identical to the common suffix.)
     * <li>The parameter list for non-init (step, pred, and fini) functions will be adjusted to the common prefix
     * followed by the common suffix, called the "common parameter sequence".
     * <li>Every non-init, non-omitted function parameter list must be effectively identical to the common parameter
     * sequence.
     * </ol>
     * <p>
     * <em>Step 3: Fill in omitted functions.</em><ol type="a">
     * <li>If an init function is omitted, use a {@linkplain #constant constant function} of the appropriate
     * {@code null}/zero/{@code false}/{@code void} type. (For this purpose, a constant {@code void} is simply a
     * function which does nothing and returns {@code void}; it can be obtained from another constant function by
     * {@linkplain MethodHandle#asType type conversion}.)
     * <li>If a step function is omitted, use an {@linkplain #identity identity function} of the clause's iteration
     * variable type; insert dropped argument parameters before the identity function parameter for the non-{@code void}
     * iteration variables of preceding clauses. (This will turn the loop variable into a local loop invariant.)
     * <li>If a pred function is omitted, the corresponding fini function must also be omitted.
     * <li>If a pred function is omitted, use a constant {@code true} function. (This will keep the loop going, as far
     * as this clause is concerned.)
     * <li>If a fini function is omitted, use a constant {@code null}/zero/{@code false}/{@code void} function of the
     * loop return type.
     * </ol>
     * <p>
     * <em>Step 4: Fill in missing parameter types.</em><ol type="a">
     * <li>At this point, every init function parameter list is effectively identical to the common suffix, but some
     * lists may be shorter. For every init function with a short parameter list, pad out the end of the list by
     * {@linkplain #dropArguments dropping arguments}.
     * <li>At this point, every non-init function parameter list is effectively identical to the common parameter
     * sequence, but some lists may be shorter. For every non-init function with a short parameter list, pad out the end
     * of the list by {@linkplain #dropArguments dropping arguments}.
     * </ol>
     * <p>
     * <em>Final observations.</em><ol type="a">
     * <li>After these steps, all clauses have been adjusted by supplying omitted functions and arguments.
     * <li>All init functions have a common parameter type list, which the final loop handle will also have.
     * <li>All fini functions have a common return type, which the final loop handle will also have.
     * <li>All non-init functions have a common parameter type list, which is the common parameter sequence, of
     * (non-{@code void}) iteration variables followed by loop parameters.
     * <li>Each pair of init and step functions agrees in their return types.
     * <li>Each non-init function will be able to observe the current values of all iteration variables, by means of the
     * common prefix.
     * </ol>
     * <p>
     * <em>Loop execution.</em><ol type="a">
     * <li>When the loop is called, the loop input values are saved in locals, to be passed (as the common suffix) to
     * every clause function. These locals are loop invariant.
     * <li>Each init function is executed in clause order (passing the common suffix) and the non-{@code void} values
     * are saved (as the common prefix) into locals. These locals are loop varying (unless their steps are identity
     * functions, as noted above).
     * <li>All function executions (except init functions) will be passed the common parameter sequence, consisting of
     * the non-{@code void} iteration values (in clause order) and then the loop inputs (in argument order).
     * <li>The step and pred functions are then executed, in clause order (step before pred), until a pred function
     * returns {@code false}.
     * <li>The non-{@code void} result from a step function call is used to update the corresponding loop variable. The
     * updated value is immediately visible to all subsequent function calls.
     * <li>If a pred function returns {@code false}, the corresponding fini function is called, and the resulting value
     * is returned from the loop as a whole.
     * </ol>
     * <p>
     * Here is pseudocode for the resulting loop handle. In the code, {@code V}/{@code v} represent the types / values
     * of loop variables; {@code A}/{@code a}, those of arguments passed to the resulting loop; and {@code R}, the
     * result types of finalizers as well as of the resulting loop.
     * <blockquote><pre>{@code
     * V... init...(A...);
     * boolean pred...(V..., A...);
     * V... step...(V..., A...);
     * R fini...(V..., A...);
     * R loop(A... a) {
     *   V... v... = init...(a...);
     *   for (;;) {
     *     for ((v, p, s, f) in (v..., pred..., step..., fini...)) {
     *       v = s(v..., a...);
     *       if (!p(v..., a...)) {
     *         return f(v..., a...);
     *       }
     *     }
     *   }
     * }
     * }</pre></blockquote>
     * <p>
     * @apiNote Example:
     * <blockquote><pre>{@code
     * // iterative implementation of the factorial function as a loop handle
     * static int one(int k) { return 1; }
     * static int inc(int i, int acc, int k) { return i + 1; }
     * static int mult(int i, int acc, int k) { return i * acc; }
     * static boolean pred(int i, int acc, int k) { return i < k; }
     * static int fin(int i, int acc, int k) { return acc; }
     * // assume MH_one, MH_inc, MH_mult, MH_pred, and MH_fin are handles to the above methods
     * // null initializer for counter, should initialize to 0
     * MethodHandle[] counterClause = new MethodHandle[]{null, MH_inc};
     * MethodHandle[] accumulatorClause = new MethodHandle[]{MH_one, MH_mult, MH_pred, MH_fin};
     * MethodHandle loop = MethodHandles.loop(counterClause, accumulatorClause);
     * assertEquals(120, loop.invoke(5));
     * }</pre></blockquote>
     *
     * @param clauses an array of arrays (4-tuples) of {@link MethodHandle}s adhering to the rules described above.
     *
     * @return a method handle embodying the looping behavior as defined by the arguments.
     *
     * @throws IllegalArgumentException in case any of the constraints described above is violated.
     *
     * @see MethodHandles#whileLoop(MethodHandle, MethodHandle, MethodHandle)
     * @see MethodHandles#doWhileLoop(MethodHandle, MethodHandle, MethodHandle)
     * @see MethodHandles#countedLoop(MethodHandle, MethodHandle, MethodHandle)
     * @see MethodHandles#iteratedLoop(MethodHandle, MethodHandle, MethodHandle)
     * @since 9
     */
    public static MethodHandle loop(MethodHandle[]... clauses) {

    /**
     * Constructs a {@code while} loop from an initializer, a body, and a predicate. This is a convenience wrapper for
     * the {@linkplain #loop(MethodHandle[][]) generic loop combinator}.
     * <p>
     * The loop handle's result type is the same as the sole loop variable's, i.e., the result type of {@code init}.
     * The parameter type list of {@code init} also determines that of the resulting handle. The {@code pred} handle
     * must have an additional leading parameter of the same type as {@code init}'s result, and so must the {@code
     * body}. These constraints follow directly from those described for the {@linkplain MethodHandles#loop(MethodHandle[][])
     * generic loop combinator}.
     * <p>
     * Here is pseudocode for the resulting loop handle. In the code, {@code V}/{@code v} represent the type / value of
     * the sole loop variable as well as the result type of the loop; and {@code A}/{@code a}, that of the argument
     * passed to the loop.
     * <blockquote><pre>{@code
     * V init(A);
     * boolean pred(V, A);
     * V body(V, A);
     * V whileLoop(A a) {
     *   V v = init(a);
     *   while (pred(v, a)) {
     *     v = body(v, a);
     *   }
     *   return v;
     * }
     * }</pre></blockquote>
     * <p>
     * @apiNote Example:
     * <blockquote><pre>{@code
     * // implement the zip function for lists as a loop handle
     * static List<String> initZip(Iterator<String> a, Iterator<String> b) { return new ArrayList<>(); }
     * static boolean zipPred(List<String> zip, Iterator<String> a, Iterator<String> b) { return a.hasNext() && b.hasNext(); }
     * static List<String> zipStep(List<String> zip, Iterator<String> a, Iterator<String> b) {
     *   zip.add(a.next());
     *   zip.add(b.next());
     *   return zip;
     * }
     * // assume MH_initZip, MH_zipPred, and MH_zipStep are handles to the above methods
     * MethodHandle loop = MethodHandles.whileLoop(MH_initZip, MH_zipPred, MH_zipStep);
     * List<String> a = Arrays.asList("a", "b", "c", "d");
     * List<String> b = Arrays.asList("e", "f", "g", "h");
     * List<String> zipped = Arrays.asList("a", "e", "b", "f", "c", "g", "d", "h");
     * assertEquals(zipped, (List<String>) loop.invoke(a.iterator(), b.iterator()));
     * }</pre></blockquote>
     *
     * <p>
     * @implSpec The implementation of this method is equivalent to:
     * <blockquote><pre>{@code
     * MethodHandle whileLoop(MethodHandle init, MethodHandle pred, MethodHandle body) {
     *     MethodHandle[]
     *         checkExit = {null, null, pred, identity(init.type().returnType())},
     *         varBody = {init, body};
     *     return loop(checkExit, varBody);
     * }
     * }</pre></blockquote>
     *
     * @param init initializer: it should provide the initial value of the loop variable. This controls the loop's
     *             result type. Passing {@code null} or a {@code void} init function will make the loop's result type
     *             {@code void}.
     * @param pred condition for the loop, which may not be {@code null}.
     * @param body body of the loop, which may not be {@code null}.
     *
     * @return the value of the loop variable as the loop terminates.
     * @throws IllegalArgumentException if any argument has a type inconsistent with the loop structure
     *
     * @see MethodHandles#loop(MethodHandle[][])
     * @since 9
     */
    public static MethodHandle whileLoop(MethodHandle init, MethodHandle pred, MethodHandle body) {

    /**
     * Constructs a {@code do-while} loop from an initializer, a body, and a predicate. This is a convenience wrapper
     * for the {@linkplain MethodHandles#loop(MethodHandle[][]) generic loop combinator}.
     * <p>
     * The loop handle's result type is the same as the sole loop variable's, i.e., the result type of {@code init}.
     * The parameter type list of {@code init} also determines that of the resulting handle. The {@code pred} handle
     * must have an additional leading parameter of the same type as {@code init}'s result, and so must the {@code
     * body}. These constraints follow directly from those described for the {@linkplain MethodHandles#loop(MethodHandle[][])
     * generic loop combinator}.
     * <p>
     * Here is pseudocode for the resulting loop handle. In the code, {@code V}/{@code v} represent the type / value of
     * the sole loop variable as well as the result type of the loop; and {@code A}/{@code a}, that of the argument
     * passed to the loop.
     * <blockquote><pre>{@code
     * V init(A);
     * boolean pred(V, A);
     * V body(V, A);
     * V doWhileLoop(A a) {
     *   V v = init(a);
     *   do {
     *     v = body(v, a);
     *   } while (pred(v, a));
     *   return v;
     * }
     * }</pre></blockquote>
     * <p>
     * @apiNote Example:
     * <blockquote><pre>{@code
     * // int i = 0; while (i < limit) { ++i; } return i; => limit
     * static int zero(int limit) { return 0; }
     * static int step(int i, int limit) { return i + 1; }
     * static boolean pred(int i, int limit) { return i < limit; }
     * // assume MH_zero, MH_step, and MH_pred are handles to the above methods
     * MethodHandle loop = MethodHandles.doWhileLoop(MH_zero, MH_step, MH_pred);
     * assertEquals(23, loop.invoke(23));
     * }</pre></blockquote>
     *
     * <p>
     * @implSpec The implementation of this method is equivalent to:
     * <blockquote><pre>{@code
     * MethodHandle doWhileLoop(MethodHandle init, MethodHandle body, MethodHandle pred) {
     *     MethodHandle[] clause = { init, body, pred, identity(init.type().returnType()) };
     *     return loop(clause);
     * }
     * }</pre></blockquote>
     *
     *
     * @param init initializer: it should provide the initial value of the loop variable. This controls the loop's
     *             result type. Passing {@code null} or a {@code void} init function will make the loop's result type
     *             {@code void}.
     * @param pred condition for the loop, which may not be {@code null}.
     * @param body body of the loop, which may not be {@code null}.
     *
     * @return the value of the loop variable as the loop terminates.
     * @throws IllegalArgumentException if any argument has a type inconsistent with the loop structure
     *
     * @see MethodHandles#loop(MethodHandle[][])
     * @since 9
     */
    public static MethodHandle doWhileLoop(MethodHandle init, MethodHandle body, MethodHandle pred) {

    /**
     * Constructs a loop that runs a given number of iterations. The loop counter is an {@code int} initialized from the
     * {@code iterations} handle evaluation result. The counter is passed to the {@code body} function, so that must
     * accept an initial {@code int} argument. The result of the loop execution is the final value of the additional
     * local state. This is a convenience wrapper for the {@linkplain MethodHandles#loop(MethodHandle[][]) generic loop
     * combinator}.
     * <p>
     * The result type and parameter type list of {@code init} determine those of the resulting handle. The {@code
     * iterations} handle must accept the same parameter types as {@code init} but return an {@code int}. The {@code
     * body} handle must accept the same parameter types as well, preceded by an {@code int} parameter for the counter,
     * and a parameter of the same type as {@code init}'s result. These constraints follow directly from those described
     * for the {@linkplain MethodHandles#loop(MethodHandle[][]) generic loop combinator}.
     * <p>
     * Here is pseudocode for the resulting loop handle. In the code, {@code V}/{@code v} represent the type / value of
     * the sole loop variable as well as the result type of the loop; and {@code A}/{@code a}, that of the argument
     * passed to the loop.
     * <blockquote><pre>{@code
     * int iterations(A);
     * V init(A);
     * V body(int, V, A);
     * V countedLoop(A a) {
     *   int end = iterations(a);
     *   V v = init(a);
     *   for (int i = 0; i < end; ++i) {
     *     v = body(i, v, a);
     *   }
     *   return v;
     * }
     * }</pre></blockquote>
     * <p>
     * @apiNote Example:
     * <blockquote><pre>{@code
     * // String s = "Lambdaman!"; for (int i = 0; i < 13; ++i) { s = "na " + s; } return s;
     * // => a variation on a well known theme
     * static String start(String arg) { return arg; }
     * static String step(int counter, String v, String arg) { return "na " + v; }
     * // assume MH_start and MH_step are handles to the two methods above
     * MethodHandle fit13 = MethodHandles.constant(int.class, 13);
     * MethodHandle loop = MethodHandles.countedLoop(fit13, MH_start, MH_step);
     * assertEquals("na na na na na na na na na na na na na Lambdaman!", loop.invoke("Lambdaman!"));
     * }</pre></blockquote>
     *
     * <p>
     * @implSpec The implementation of this method is equivalent to:
     * <blockquote><pre>{@code
     * MethodHandle countedLoop(MethodHandle iterations, MethodHandle init, MethodHandle body) {
     *     return countedLoop(null, iterations, init, body);  // null => constant zero
     * }
     * }</pre></blockquote>
     *
     * @param iterations a handle to return the number of iterations this loop should run.
     * @param init initializer for additional loop state. This determines the loop's result type.
     *             Passing {@code null} or a {@code void} init function will make the loop's result type
     *             {@code void}.
     * @param body the body of the loop, which must not be {@code null}.
     *             It must accept an initial {@code int} parameter (for the counter), and then any
     *             additional loop-local variable plus loop parameters.
     *
     * @return a method handle representing the loop.
     * @throws IllegalArgumentException if any argument has a type inconsistent with the loop structure
     *
     * @since 9
     */
    public static MethodHandle countedLoop(MethodHandle iterations, MethodHandle init, MethodHandle body) {

    /**
     * Constructs a loop that counts over a range of numbers. The loop counter is an {@code int} that will be
     * initialized to the {@code int} value returned from the evaluation of the {@code start} handle and run to the
     * value returned from {@code end} (exclusively) with a step width of 1. The counter value is passed to the {@code
     * body} function in each iteration; it has to accept an initial {@code int} parameter
     * for that. The result of the loop execution is the final value of the additional local state
     * obtained by running {@code init}.
     * This is a
     * convenience wrapper for the {@linkplain MethodHandles#loop(MethodHandle[][]) generic loop combinator}.
     * <p>
     * The constraints for the {@code init} and {@code body} handles are the same as for {@link
     * #countedLoop(MethodHandle, MethodHandle, MethodHandle)}. Additionally, the {@code start} and {@code end} handles
     * must return an {@code int} and accept the same parameters as {@code init}.
     * <p>
     * Here is pseudocode for the resulting loop handle. In the code, {@code V}/{@code v} represent the type / value of
     * the sole loop variable as well as the result type of the loop; and {@code A}/{@code a}, that of the argument
     * passed to the loop.
     * <blockquote><pre>{@code
     * int start(A);
     * int end(A);
     * V init(A);
     * V body(int, V, A);
     * V countedLoop(A a) {
     *   int s = start(a);
     *   int e = end(a);
     *   V v = init(a);
     *   for (int i = s; i < e; ++i) {
     *     v = body(i, v, a);
     *   }
     *   return v;
     * }
     * }</pre></blockquote>
     *
     * <p>
     * @implSpec The implementation of this method is equivalent to:
     * <blockquote><pre>{@code
     * MethodHandle countedLoop(MethodHandle start, MethodHandle end, MethodHandle init, MethodHandle body) {
     *     MethodHandle returnVar = dropArguments(identity(init.type().returnType()), 0, int.class, int.class);
     *     // assume MH_increment and MH_lessThan are handles to x+1 and x<y of type int,
     *     // assume MH_decrement is a handle to x-1 of type int
     *     MethodHandle[]
     *         indexVar = {start, MH_increment}, // i = start; i = i+1
     *         loopLimit = {end, null,
     *                       filterArgument(MH_lessThan, 0, MH_decrement), returnVar}, // i-1<end
     *         bodyClause = {init,
     *                       filterArgument(dropArguments(body, 1, int.class), 0, MH_decrement}; // v = body(i-1, v)
     *     return loop(indexVar, loopLimit, bodyClause);
     * }
     * }</pre></blockquote>
     *
     * @param start a handle to return the start value of the loop counter.
     *              If it is {@code null}, a constant zero is assumed.
     * @param end a non-{@code null} handle to return the end value of the loop counter (the loop will run to {@code end-1}).
     * @param init initializer for additional loop state. This determines the loop's result type.
     *             Passing {@code null} or a {@code void} init function will make the loop's result type
     *             {@code void}.
     * @param body the body of the loop, which must not be {@code null}.
     *             It must accept an initial {@code int} parameter (for the counter), and then any
     *             additional loop-local variable plus loop parameters.
     *
     * @return a method handle representing the loop.
     * @throws IllegalArgumentException if any argument has a type inconsistent with the loop structure
     *
     * @since 9
     */
    public static MethodHandle countedLoop(MethodHandle start, MethodHandle end, MethodHandle init, MethodHandle body) {

    /**
     * Constructs a loop that ranges over the elements produced by an {@code Iterator<T>}.
     * The iterator will be produced by the evaluation of the {@code iterator} handle.
     * This handle must have {@link java.util.Iterator} as its return type.
     * If this handle is passed as {@code null} the method {@link Iterable#iterator} will be used instead,
     * and will be applied to a leading argument of the loop handle.
     * Each value produced by the iterator is passed to the {@code body}, which must accept an initial {@code T} parameter.
     * The result of the loop execution is the final value of the additional local state
     * obtained by running {@code init}.
     * <p>
     * This is a convenience wrapper for the
     * {@linkplain MethodHandles#loop(MethodHandle[][]) generic loop combinator}, and the constraints imposed on the {@code body}
     * handle follow directly from those described for the latter.
     * <p>
     * Here is pseudocode for the resulting loop handle. In the code, {@code V}/{@code v} represent the type / value of
     * the loop variable as well as the result type of the loop; {@code T}/{@code t}, that of the elements of the
     * structure the loop iterates over, and {@code A}/{@code a}, that of the argument passed to the loop.
     * <blockquote><pre>{@code
     * Iterator<T> iterator(A);  // defaults to Iterable::iterator
     * V init(A);
     * V body(T,V,A);
     * V iteratedLoop(A a) {
     *   Iterator<T> it = iterator(a);
     *   V v = init(a);
     *   for (T t : it) {
     *     v = body(t, v, a);
     *   }
     *   return v;
     * }
     * }</pre></blockquote>
     * <p>
     * The type {@code T} may be either a primitive or reference.
     * Since type {@code Iterator<T>} is erased in the method handle representation to the raw type
     * {@code Iterator}, the {@code iteratedLoop} combinator adjusts the leading argument type for {@code body}
     * to {@code Object} as if by the {@link MethodHandle#asType asType} conversion method.
     * Therefore, if an iterator of the wrong type appears as the loop is executed,
     * runtime exceptions may occur as the result of dynamic conversions performed by {@code asType}.
     * <p>
     * @apiNote Example:
     * <blockquote><pre>{@code
     * // reverse a list
     * static List<String> reverseStep(String e, List<String> r, List<String> l) {
     *   r.add(0, e);
     *   return r;
     * }
     * static List<String> newArrayList(List<String> l) { return new ArrayList<>(); }
     * // assume MH_reverseStep, MH_newArrayList are handles to the above methods
     * MethodHandle loop = MethodHandles.iteratedLoop(null, MH_newArrayList, MH_reverseStep);
     * List<String> list = Arrays.asList("a", "b", "c", "d", "e");
     * List<String> reversedList = Arrays.asList("e", "d", "c", "b", "a");
     * assertEquals(reversedList, (List<String>) loop.invoke(list));
     * }</pre></blockquote>
     * <p>
     * @implSpec The implementation of this method is equivalent to (excluding error handling):
     * <blockquote><pre>{@code
     * MethodHandle iteratedLoop(MethodHandle iterator, MethodHandle init, MethodHandle body) {
     *     // assume MH_next and MH_hasNext are handles to methods of Iterator
     *     Class<?> itype = iterator.type().returnType();
     *     Class<?> ttype = body.type().parameterType(0);
     *     MethodHandle returnVar = dropArguments(identity(init.type().returnType()), 0, itype);
     *     MethodHandle nextVal = MH_next.asType(MH_next.type().changeReturnType(ttype));
     *     MethodHandle[]
     *         iterVar = {iterator, null, MH_hasNext, returnVar}, // it = iterator(); while (it.hasNext)
     *         bodyClause = {init, filterArgument(body, 0, nextVal)};  // v = body(t, v, a);
     *     return loop(iterVar, bodyClause);
     * }
     * }</pre></blockquote>
     *
     * @param iterator a handle to return the iterator to start the loop.
     *             The handle must have {@link java.util.Iterator} as its return type.
     *             Passing {@code null} will make the loop call {@link Iterable#iterator()} on the first
     *             incoming value.
     * @param init initializer for additional loop state. This determines the loop's result type.
     *             Passing {@code null} or a {@code void} init function will make the loop's result type
     *             {@code void}.
     * @param body the body of the loop, which must not be {@code null}.
     *             It must accept an initial {@code T} parameter (for the iterated values), and then any
     *             additional loop-local variable plus loop parameters.
     *
     * @return a method handle embodying the iteration loop functionality.
     * @throws IllegalArgumentException if any argument has a type inconsistent with the loop structure
     *
     * @since 9
     */
    public static MethodHandle iteratedLoop(MethodHandle iterator, MethodHandle init, MethodHandle body) {

    /**
     * Makes a method handle that adapts a {@code target} method handle by wrapping it in a {@code try-finally} block.
     * Another method handle, {@code cleanup}, represents the functionality of the {@code finally} block. Any exception
     * thrown during the execution of the {@code target} handle will be passed to the {@code cleanup} handle. The
     * exception will be rethrown, unless {@code cleanup} handle throws an exception first.  The
     * value returned from the {@code cleanup} handle's execution will be the result of the execution of the
     * {@code try-finally} handle.
     * <p>
     * The {@code cleanup} handle will be passed one or two additional leading arguments.
     * The first is the exception thrown during the
     * execution of the {@code target} handle, or {@code null} if no exception was thrown.
     * The second is the result of the execution of the {@code target} handle, or, if it throws an exception,
     * a {@code null}, zero, or {@code false} value of the required type is supplied as a placeholder.
     * The second argument is not present if the {@code target} handle has a {@code void} return type.
     * (Note that, except for argument type conversions, combinators represent {@code void} values in parameter lists
     * by omitting the corresponding paradoxical arguments, not by inserting {@code null} or zero values.)
     * <p>
     * The {@code target} and {@code cleanup} handles must have the same corresponding argument and return types, except
     * that the {@code cleanup} handle may omit trailing arguments. Also, the {@code cleanup} handle must have one or
     * two extra leading parameters:<ul>
     * <li>a {@code Throwable}, which will carry the exception thrown by the {@code target} handle (if any); and
     * <li>a parameter of the same type as the return type of both {@code target} and {@code cleanup}, which will carry
     * the result from the execution of the {@code target} handle.
     * This parameter is not present if the {@code target} returns {@code void}.
     * </ul>
     * <p>
     * The pseudocode for the resulting adapter looks as follows. In the code, {@code V} represents the result type of
     * the {@code try/finally} construct; {@code A}/{@code a}, the types and values of arguments to the resulting
     * handle consumed by the cleanup; and {@code B}/{@code b}, those of arguments to the resulting handle discarded by
     * the cleanup.
     * <blockquote><pre>{@code
     * V target(A..., B...);
     * V cleanup(Throwable, V, A...);
     * V adapter(A... a, B... b) {
     *   V result = (zero value for V);
     *   Throwable throwable = null;
     *   try {
     *     result = target(a..., b...);
     *   } catch (Throwable t) {
     *     throwable = t;
     *     throw t;
     *   } finally {
     *     result = cleanup(throwable, result, a...);
     *   }
     *   return result;
     * }
     * }</pre></blockquote>
     * <p>
     * Note that the saved arguments ({@code a...} in the pseudocode) cannot
     * be modified by execution of the target, and so are passed unchanged
     * from the caller to the cleanup, if it is invoked.
     * <p>
     * The target and cleanup must return the same type, even if the cleanup
     * always throws.
     * To create such a throwing cleanup, compose the cleanup logic
     * with {@link #throwException throwException},
     * in order to create a method handle of the correct return type.
     * <p>
     * Note that {@code tryFinally} never converts exceptions into normal returns.
     * In rare cases where exceptions must be converted in that way, first wrap
     * the target with {@link #catchException(MethodHandle, Class, MethodHandle)}
     * to capture an outgoing exception, and then wrap with {@code tryFinally}.
     *
     * @param target the handle whose execution is to be wrapped in a {@code try} block.
     * @param cleanup the handle that is invoked in the finally block.
     *
     * @return a method handle embodying the {@code try-finally} block composed of the two arguments.
     * @throws NullPointerException if any argument is null
     * @throws IllegalArgumentException if {@code cleanup} does not accept
     *          the required leading arguments, or if the method handle types do
     *          not match in their return types and their
     *          corresponding trailing parameters
     *
     * @see MethodHandles#catchException(MethodHandle, Class, MethodHandle)
     * @since 9
     */
    public static MethodHandle tryFinally(MethodHandle target, MethodHandle cleanup) {

    /**
     * Adapts a target method handle by pre-processing some of its arguments, starting at a given position, and then
     * calling the target with the result of the pre-processing, inserted into the original sequence of arguments just
     * before the folded arguments.
     * <p>
     * This method is closely related to {@link #foldArguments(MethodHandle, MethodHandle)}, but allows to control the
     * position in the parameter list at which folding takes place. The argument controlling this, {@code pos}, is a
     * zero-based index. The aforementioned method {@link #foldArguments(MethodHandle, MethodHandle)} assumes position
     * 0.
     * <p>
     * @apiNote Example:
     * <blockquote><pre>{@code
    import static java.lang.invoke.MethodHandles.*;
    import static java.lang.invoke.MethodType.*;
    ...
    MethodHandle trace = publicLookup().findVirtual(java.io.PrintStream.class,
    "println", methodType(void.class, String.class))
    .bindTo(System.out);
    MethodHandle cat = lookup().findVirtual(String.class,
    "concat", methodType(String.class, String.class));
    assertEquals("boojum", (String) cat.invokeExact("boo", "jum"));
    MethodHandle catTrace = foldArguments(cat, 1, trace);
    // also prints "jum":
    assertEquals("boojum", (String) catTrace.invokeExact("boo", "jum"));
     * }</pre></blockquote>
     * <p>Here is pseudocode for the resulting adapter. In the code, {@code T}
     * represents the result type of the {@code target} and resulting adapter.
     * {@code V}/{@code v} represent the type and value of the parameter and argument
     * of {@code target} that precedes the folding position; {@code V} also is
     * the result type of the {@code combiner}. {@code A}/{@code a} denote the
     * types and values of the {@code N} parameters and arguments at the folding
     * position. {@code Z}/{@code z} and {@code B}/{@code b} represent the types
     * and values of the {@code target} parameters and arguments that precede and
     * follow the folded parameters and arguments starting at {@code pos},
     * respectively.
     * <blockquote><pre>{@code
     * // there are N arguments in A...
     * T target(Z..., V, A[N]..., B...);
     * V combiner(A...);
     * T adapter(Z... z, A... a, B... b) {
     *   V v = combiner(a...);
     *   return target(z..., v, a..., b...);
     * }
     * // and if the combiner has a void return:
     * T target2(Z..., A[N]..., B...);
     * void combiner2(A...);
     * T adapter2(Z... z, A... a, B... b) {
     *   combiner2(a...);
     *   return target2(z..., a..., b...);
     * }
     * }</pre></blockquote>
     * <p>
     * <em>Note:</em> The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector
     * variable-arity method handle}, even if the original target method handle was.
     *
     * @param target the method handle to invoke after arguments are combined
     * @param pos the position at which to start folding and at which to insert the folding result; if this is {@code
     *            0}, the effect is the same as for {@link #foldArguments(MethodHandle, MethodHandle)}.
     * @param combiner method handle to call initially on the incoming arguments
     * @return method handle which incorporates the specified argument folding logic
     * @throws NullPointerException if either argument is null
     * @throws IllegalArgumentException if {@code combiner}'s return type
     *          is non-void and not the same as the argument type at position {@code pos} of
     *          the target signature, or if the {@code N} argument types at position {@code pos}
     *          of the target signature
     *          (skipping one matching the {@code combiner}'s return type)
     *          are not identical with the argument types of {@code combiner}
     *
     * @see #foldArguments(MethodHandle, MethodHandle)
     * @since 9
     */
    public static MethodHandle foldArguments(MethodHandle target, int pos, MethodHandle combiner) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\invoke\StringConcatException.java
/**
 * StringConcatException is thrown by {@link StringConcatFactory} when linkage
 * invariants are violated.
 *
 * @since 9
 */
public class StringConcatException extends Exception {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\invoke\StringConcatFactory.java
/**
 * <p>Methods to facilitate the creation of String concatenation methods, that
 * can be used to efficiently concatenate a known number of arguments of known
 * types, possibly after type adaptation and partial evaluation of arguments.
 * These methods are typically used as <em>bootstrap methods</em> for {@code
 * invokedynamic} call sites, to support the <em>string concatenation</em>
 * feature of the Java Programming Language.
 *
 * <p>Indirect access to the behavior specified by the provided {@code
 * MethodHandle} proceeds in order through two phases:
 *
 * <ol>
 *     <li><em>Linkage</em> occurs when the methods in this class are invoked.
 * They take as arguments a method type describing the concatenated arguments
 * count and types, and optionally the String <em>recipe</em>, plus the
 * constants that participate in the String concatenation. The details on
 * accepted recipe shapes are described further below. Linkage may involve
 * dynamically loading a new class that implements the expected concatenation
 * behavior. The {@code CallSite} holds the {@code MethodHandle} pointing to the
 * exact concatenation method. The concatenation methods may be shared among
 * different {@code CallSite}s, e.g. if linkage methods produce them as pure
 * functions.</li>
 *
 * <li><em>Invocation</em> occurs when a generated concatenation method is
 * invoked with the exact dynamic arguments. This may occur many times for a
 * single concatenation method. The method referenced by the behavior {@code
 * MethodHandle} is invoked with the static arguments and any additional dynamic
 * arguments provided on invocation, as if by {@link MethodHandle#invoke(Object...)}.</li>
 * </ol>
 *
 * <p> This class provides two forms of linkage methods: a simple version
 * ({@link #makeConcat(java.lang.invoke.MethodHandles.Lookup, String,
 * MethodType)}) using only the dynamic arguments, and an advanced version
 * ({@link #makeConcatWithConstants(java.lang.invoke.MethodHandles.Lookup,
 * String, MethodType, String, Object...)} using the advanced forms of capturing
 * the constant arguments. The advanced strategy can produce marginally better
 * invocation bytecode, at the expense of exploding the number of shapes of
 * string concatenation methods present at runtime, because those shapes would
 * include constant static arguments as well.
 *
 * @author Aleksey Shipilev
 * @author Remi Forax
 * @author Peter Levart
 *
 * @apiNote
 * <p>There is a JVM limit (classfile structural constraint): no method
 * can call with more than 255 slots. This limits the number of static and
 * dynamic arguments one can pass to bootstrap method. Since there are potential
 * concatenation strategies that use {@code MethodHandle} combinators, we need
 * to reserve a few empty slots on the parameter lists to capture the
 * temporal results. This is why bootstrap methods in this factory do not accept
 * more than 200 argument slots. Users requiring more than 200 argument slots in
 * concatenation are expected to split the large concatenation in smaller
 * expressions.
 *
 * @since 9
 */
public final class StringConcatFactory {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\invoke\VarHandle.java
/**
 * A VarHandle is a dynamically typed reference to a variable, or to a
 * parametrically-defined family of variables, including static fields,
 * non-static fields, array elements, or components of an off-heap data
 * structure.  Access to such variables is supported under various
 * <em>access modes</em>, including plain read/write access, volatile
 * read/write access, and compare-and-swap.
 *
 * <p>VarHandles are immutable and have no visible state.  VarHandles cannot be
 * subclassed by the user.
 *
 * <p>A VarHandle has:
 * <ul>
 * <li>a {@link #varType variable type}, referred to as {@code T}, which is the
 * type of variable(s) referenced by this VarHandle;
 * <li>a list of {@link #coordinateTypes coordinate types}, referred to as
 * {@code CT}, where the types (primitive and reference) are represented by
 * {@link Class} objects).  A list of arguments corresponding to instances of
 * the coordinate types uniquely locates a variable referenced by this
 * VarHandle; and
 * <li>a <em>shape</em>, that combines the variable type and coordinate types,
 * and is declared with the notation {@code (CT : T)}.  An empty list of
 * coordinate types is declared as {@code (empty)}.
 * </ul>
 *
 * <p>Factory methods that produce or {@link java.lang.invoke.MethodHandles.Lookup
 * lookup} VarHandle instances document the supported variable type, coordinate
 * types, and shape.
 *
 * For example, a VarHandle referencing a non-static field will declare a shape
 * of {@code (R : T)}, where {@code R} is the receiver type and
 * {@code T} is the field type, and where the VarHandle and an instance of the
 * receiver type can be utilized to access the field variable.
 * A VarHandle referencing array elements will declare a shape of
 * {@code (T[], int : T)}, where {@code T[]} is the array type and {@code T}
 * its component type, and where the VarHandle, an instance of the array type,
 * and an {@code int} index can be utilized to access an array element variable.
 *
 * <p>Each access mode is associated with a
 * <a href="MethodHandle.html#sigpoly">signature polymorphic</a> method of the
 * same name, where the VarHandle shape and access mode uniquely determine the
 * canonical {@link #accessModeType(AccessMode) access mode type},
 * which in turn determines the matching constraints on a valid symbolic
 * type descriptor at the call site of an access mode's method
 * <a href="VarHandle.html#invoke">invocation</a>.
 *
 * As such, VarHandles are dynamically and strongly typed.  Their arity,
 * argument types, and return type of an access mode method invocation are not
 * statically checked.  If they, and associated values, do not match the arity
 * and types of the access mode's type, an exception will be thrown.
 *
 * The parameter types of an access mode method type will consist of those that
 * are the VarHandles's coordinate types (in order), followed by access mode
 * parameter types specific to the access mode.
 *
 * <p>An access mode's method documents the form of its method signature, which
 * is derived from the access mode parameter types.  The form is declared with
 * the notation {@code (CT, P1 p1, P2 p2, ..., PN pn)R}, where {@code CT} is the
 * coordinate types (as documented by a VarHandle factory method), {@code P1},
 * {@code P2} and {@code PN} are the first, second and the n'th access mode
 * parameters named {@code p1}, {@code p2} and {@code pn} respectively, and
 * {@code R} is the return type.
 *
 * For example, for the generic shape of {@code (CT : T)} the
 * {@link #compareAndSet} access mode method documents that its method
 * signature is of the form {@code (CT, T expectedValue, T newValue)boolean},
 * where the parameter types named {@code extendedValue} and {@code newValue}
 * are the access mode parameter types.  If the VarHandle accesses array
 * elements with a shape of say {@code (T[], int : T)} then the access mode
 * method type is {@code (T[], int, T, T)boolean}.
 *
 * <p>Access modes are grouped into the following categories:
 * <ul>
 * <li>read access modes that get the value of a variable under specified
 * memory ordering effects.
 * The set of corresponding access mode methods belonging to this group
 * consists of the methods
 * {@link #get get},
 * {@link #getVolatile getVolatile},
 * {@link #getAcquire getAcquire},
 * {@link #getOpaque getOpaque}.
 * <li>write access modes that set the value of a variable under specified
 * memory ordering effects.
 * The set of corresponding access mode methods belonging to this group
 * consists of the methods
 * {@link #set set},
 * {@link #setVolatile setVolatile},
 * {@link #setRelease setRelease},
 * {@link #setOpaque setOpaque}.
 * <li>atomic update access modes that, for example, atomically compare and set
 * the value of a variable under specified memory ordering effects.
 * The set of corresponding access mode methods belonging to this group
 * consists of the methods
 * {@link #compareAndSet compareAndSet},
 * {@link #weakCompareAndSetPlain weakCompareAndSetPlain},
 * {@link #weakCompareAndSet weakCompareAndSet},
 * {@link #weakCompareAndSetAcquire weakCompareAndSetAcquire},
 * {@link #weakCompareAndSetRelease weakCompareAndSetRelease},
 * {@link #compareAndExchangeAcquire compareAndExchangeAcquire},
 * {@link #compareAndExchange compareAndExchange},
 * {@link #compareAndExchangeRelease compareAndExchangeRelease},
 * {@link #getAndSet getAndSet},
 * {@link #getAndSetAcquire getAndSetAcquire},
 * {@link #getAndSetRelease getAndSetRelease}.
 * <li>numeric atomic update access modes that, for example, atomically get and
 * set with addition the value of a variable under specified memory ordering
 * effects.
 * The set of corresponding access mode methods belonging to this group
 * consists of the methods
 * {@link #getAndAdd getAndAdd},
 * {@link #getAndAddAcquire getAndAddAcquire},
 * {@link #getAndAddRelease getAndAddRelease},
 * <li>bitwise atomic update access modes that, for example, atomically get and
 * bitwise OR the value of a variable under specified memory ordering
 * effects.
 * The set of corresponding access mode methods belonging to this group
 * consists of the methods
 * {@link #getAndBitwiseOr getAndBitwiseOr},
 * {@link #getAndBitwiseOrAcquire getAndBitwiseOrAcquire},
 * {@link #getAndBitwiseOrRelease getAndBitwiseOrRelease},
 * {@link #getAndBitwiseAnd getAndBitwiseAnd},
 * {@link #getAndBitwiseAndAcquire getAndBitwiseAndAcquire},
 * {@link #getAndBitwiseAndRelease getAndBitwiseAndRelease},
 * {@link #getAndBitwiseXor getAndBitwiseXor},
 * {@link #getAndBitwiseXorAcquire getAndBitwiseXorAcquire},
 * {@link #getAndBitwiseXorRelease getAndBitwiseXorRelease}.
 * </ul>
 *
 * <p>Factory methods that produce or {@link java.lang.invoke.MethodHandles.Lookup
 * lookup} VarHandle instances document the set of access modes that are
 * supported, which may also include documenting restrictions based on the
 * variable type and whether a variable is read-only.  If an access mode is not
 * supported then the corresponding signature-polymorphic method will on
 * invocation throw an {@code UnsupportedOperationException}.  Factory methods
 * should document any additional undeclared exceptions that may be thrown by
 * access mode methods.
 * The {@link #get get} access mode is supported for all
 * VarHandle instances and the corresponding method never throws
 * {@code UnsupportedOperationException}.
 * If a VarHandle references a read-only variable (for example a {@code final}
 * field) then write, atomic update, numeric atomic update, and bitwise atomic
 * update access modes are not supported and corresponding methods throw
 * {@code UnsupportedOperationException}.
 * Read/write access modes (if supported), with the exception of
 * {@code get} and {@code set}, provide atomic access for
 * reference types and all primitive types.
 * Unless stated otherwise in the documentation of a factory method, the access
 * modes {@code get} and {@code set} (if supported) provide atomic access for
 * reference types and all primitives types, with the exception of {@code long}
 * and {@code double} on 32-bit platforms.
 *
 * <p>Access modes will override any memory ordering effects specified at
 * the declaration site of a variable.  For example, a VarHandle accessing a
 * a field using the {@code get} access mode will access the field as
 * specified <em>by its access mode</em> even if that field is declared
 * {@code volatile}.  When mixed access is performed extreme care should be
 * taken since the Java Memory Model may permit surprising results.
 *
 * <p>In addition to supporting access to variables under various access modes,
 * a set of static methods, referred to as memory fence methods, is also
 * provided for fine-grained control of memory ordering.
 *
 * The Java Language Specification permits other threads to observe operations
 * as if they were executed in orders different than are apparent in program
 * source code, subject to constraints arising, for example, from the use of
 * locks, {@code volatile} fields or VarHandles.  The static methods,
 * {@link #fullFence fullFence}, {@link #acquireFence acquireFence},
 * {@link #releaseFence releaseFence}, {@link #loadLoadFence loadLoadFence} and
 * {@link #storeStoreFence storeStoreFence}, can also be used to impose
 * constraints.  Their specifications, as is the case for certain access modes,
 * are phrased in terms of the lack of "reorderings" -- observable ordering
 * effects that might otherwise occur if the fence was not present.  More
 * precise phrasing of the specification of access mode methods and memory fence
 * methods may accompany future updates of the Java Language Specification.
 *
 * <h1>Compilation of an access mode's method</h1>
 * A Java method call expression naming an access mode method can invoke a
 * VarHandle from Java source code.  From the viewpoint of source code, these
 * methods can take any arguments and their polymorphic result (if expressed)
 * can be cast to any return type.  Formally this is accomplished by giving the
 * access mode methods variable arity {@code Object} arguments and
 * {@code Object} return types (if the return type is polymorphic), but they
 * have an additional quality called <em>signature polymorphism</em> which
 * connects this freedom of invocation directly to the JVM execution stack.
 * <p>
 * As is usual with virtual methods, source-level calls to access mode methods
 * compile to an {@code invokevirtual} instruction.  More unusually, the
 * compiler must record the actual argument types, and may not perform method
 * invocation conversions on the arguments.  Instead, it must generate
 * instructions to push them on the stack according to their own unconverted
 * types.  The VarHandle object itself will be pushed on the stack before the
 * arguments.  The compiler then generates an {@code invokevirtual} instruction
 * that invokes the access mode method with a symbolic type descriptor which
 * describes the argument and return types.
 * <p>
 * To issue a complete symbolic type descriptor, the compiler must also
 * determine the return type (if polymorphic).  This is based on a cast on the
 * method invocation expression, if there is one, or else {@code Object} if the
 * invocation is an expression, or else {@code void} if the invocation is a
 * statement.  The cast may be to a primitive type (but not {@code void}).
 * <p>
 * As a corner case, an uncasted {@code null} argument is given a symbolic type
 * descriptor of {@code java.lang.Void}.  The ambiguity with the type
 * {@code Void} is harmless, since there are no references of type {@code Void}
 * except the null reference.
 *
 *
 * <h1><a name="invoke">Invocation of an access mode's method</a></h1>
 * The first time an {@code invokevirtual} instruction is executed it is linked
 * by symbolically resolving the names in the instruction and verifying that
 * the method call is statically legal.  This also holds for calls to access mode
 * methods.  In this case, the symbolic type descriptor emitted by the compiler
 * is checked for correct syntax, and names it contains are resolved.  Thus, an
 * {@code invokevirtual} instruction which invokes an access mode method will
 * always link, as long as the symbolic type descriptor is syntactically
 * well-formed and the types exist.
 * <p>
 * When the {@code invokevirtual} is executed after linking, the receiving
 * VarHandle's access mode type is first checked by the JVM to ensure that it
 * matches the symbolic type descriptor.  If the type
 * match fails, it means that the access mode method which the caller is
 * invoking is not present on the individual VarHandle being invoked.
 *
 * <p>
 * Invocation of an access mode's signature-polymorphic method behaves as if an
 * invocation of {@link MethodHandle#invoke}, where the receiving method handle
 * is bound to a VarHandle instance and the access mode.  More specifically, the
 * following:
 * <pre> {@code
 * VarHandle vh = ..
 * R r = (R) vh.{access-mode}(p1, p2, ..., pN);
 * }</pre>
 * behaves as if (modulo the access mode methods do not declare throwing of
 * {@code Throwable}):
 * <pre> {@code
 * VarHandle vh = ..
 * MethodHandle mh = MethodHandles.varHandleExactInvoker(
 *                       VarHandle.AccessMode.{access-mode},
 *                       vh.accessModeType(VarHandle.AccessMode.{access-mode}));
 *
 * mh = mh.bindTo(vh);
 * R r = (R) mh.invoke(p1, p2, ..., pN)
 * }</pre>
 * or, more concisely, behaves as if:
 * <pre> {@code
 * VarHandle vh = ..
 * MethodHandle mh = vh.toMethodHandle(VarHandle.AccessMode.{access-mode});
 *
 * R r = (R) mh.invoke(p1, p2, ..., pN)
 * }</pre>
 * In terms of equivalent {@code invokevirtual} bytecode behaviour an access
 * mode method invocation is equivalent to:
 * <pre> {@code
 * MethodHandle mh = MethodHandles.lookup().findVirtual(
 *                       VarHandle.class,
 *                       VarHandle.AccessMode.{access-mode}.methodName(),
 *                       MethodType.methodType(R, p1, p2, ..., pN));
 *
 * R r = (R) mh.invokeExact(vh, p1, p2, ..., pN)
 * }</pre>
 * where the desired method type is the symbolic type descriptor and a
 * {@link MethodHandle#invokeExact} is performed, since before invocation of the
 * target, the handle will apply reference casts as necessary and box, unbox, or
 * widen primitive values, as if by {@link MethodHandle#asType asType} (see also
 * {@link MethodHandles#varHandleInvoker}).
 *
 * <h1>Invocation checking</h1>
 * In typical programs, VarHandle access mode type matching will usually
 * succeed.  But if a match fails, the JVM will throw a
 * {@link WrongMethodTypeException}.
 * <p>
 * Thus, an access mode type mismatch which might show up as a linkage error
 * in a statically typed program can show up as a dynamic
 * {@code WrongMethodTypeException} in a program which uses VarHandles.
 * <p>
 * Because access mode types contain "live" {@code Class} objects, method type
 * matching takes into account both type names and class loaders.
 * Thus, even if a VarHandle {@code VH} is created in one class loader
 * {@code L1} and used in another {@code L2}, VarHandle access mode method
 * calls are type-safe, because the caller's symbolic type descriptor, as
 * resolved in {@code L2}, is matched against the original callee method's
 * symbolic type descriptor, as resolved in {@code L1}.  The resolution in
 * {@code L1} happens when {@code VH} is created and its access mode types are
 * assigned, while the resolution in {@code L2} happens when the
 * {@code invokevirtual} instruction is linked.
 * <p>
 * Apart from type descriptor checks, a VarHandles's capability to
 * access it's variables is unrestricted.
 * If a VarHandle is formed on a non-public variable by a class that has access
 * to that variable, the resulting VarHandle can be used in any place by any
 * caller who receives a reference to it.
 * <p>
 * Unlike with the Core Reflection API, where access is checked every time a
 * reflective method is invoked, VarHandle access checking is performed
 * <a href="MethodHandles.Lookup.html#access">when the VarHandle is
 * created</a>.
 * Thus, VarHandles to non-public variables, or to variables in non-public
 * classes, should generally be kept secret.  They should not be passed to
 * untrusted code unless their use from the untrusted code would be harmless.
 *
 *
 * <h1>VarHandle creation</h1>
 * Java code can create a VarHandle that directly accesses any field that is
 * accessible to that code.  This is done via a reflective, capability-based
 * API called {@link java.lang.invoke.MethodHandles.Lookup
 * MethodHandles.Lookup}.
 * For example, a VarHandle for a non-static field can be obtained
 * from {@link java.lang.invoke.MethodHandles.Lookup#findVarHandle
 * Lookup.findVarHandle}.
 * There is also a conversion method from Core Reflection API objects,
 * {@link java.lang.invoke.MethodHandles.Lookup#unreflectVarHandle
 * Lookup.unreflectVarHandle}.
 * <p>
 * Access to protected field members is restricted to receivers only of the
 * accessing class, or one of its subclasses, and the accessing class must in
 * turn be a subclass (or package sibling) of the protected member's defining
 * class.  If a VarHandle refers to a protected non-static field of a declaring
 * class outside the current package, the receiver argument will be narrowed to
 * the type of the accessing class.
 *
 * <h1>Interoperation between VarHandles and the Core Reflection API</h1>
 * Using factory methods in the {@link java.lang.invoke.MethodHandles.Lookup
 * Lookup} API, any field represented by a Core Reflection API object
 * can be converted to a behaviorally equivalent VarHandle.
 * For example, a reflective {@link java.lang.reflect.Field Field} can
 * be converted to a VarHandle using
 * {@link java.lang.invoke.MethodHandles.Lookup#unreflectVarHandle
 * Lookup.unreflectVarHandle}.
 * The resulting VarHandles generally provide more direct and efficient
 * access to the underlying fields.
 * <p>
 * As a special case, when the Core Reflection API is used to view the
 * signature polymorphic access mode methods in this class, they appear as
 * ordinary non-polymorphic methods.  Their reflective appearance, as viewed by
 * {@link java.lang.Class#getDeclaredMethod Class.getDeclaredMethod},
 * is unaffected by their special status in this API.
 * For example, {@link java.lang.reflect.Method#getModifiers
 * Method.getModifiers}
 * will report exactly those modifier bits required for any similarly
 * declared method, including in this case {@code native} and {@code varargs}
 * bits.
 * <p>
 * As with any reflected method, these methods (when reflected) may be invoked
 * directly via {@link java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke},
 * via JNI, or indirectly via
 * {@link java.lang.invoke.MethodHandles.Lookup#unreflect Lookup.unreflect}.
 * However, such reflective calls do not result in access mode method
 * invocations.  Such a call, if passed the required argument (a single one, of
 * type {@code Object[]}), will ignore the argument and will throw an
 * {@code UnsupportedOperationException}.
 * <p>
 * Since {@code invokevirtual} instructions can natively invoke VarHandle
 * access mode methods under any symbolic type descriptor, this reflective view
 * conflicts with the normal presentation of these methods via bytecodes.
 * Thus, these native methods, when reflectively viewed by
 * {@code Class.getDeclaredMethod}, may be regarded as placeholders only.
 * <p>
 * In order to obtain an invoker method for a particular access mode type,
 * use {@link java.lang.invoke.MethodHandles#varHandleExactInvoker} or
 * {@link java.lang.invoke.MethodHandles#varHandleInvoker}.  The
 * {@link java.lang.invoke.MethodHandles.Lookup#findVirtual Lookup.findVirtual}
 * API is also able to return a method handle to call an access mode method for
 * any specified access mode type and is equivalent in behaviour to
 * {@link java.lang.invoke.MethodHandles#varHandleInvoker}.
 *
 * <h1>Interoperation between VarHandles and Java generics</h1>
 * A VarHandle can be obtained for a variable, such as a a field, which is
 * declared with Java generic types.  As with the Core Reflection API, the
 * VarHandle's variable type will be constructed from the erasure of the
 * source-level type.  When a VarHandle access mode method is invoked, the
 * types
 * of its arguments or the return value cast type may be generic types or type
 * instances.  If this occurs, the compiler will replace those types by their
 * erasures when it constructs the symbolic type descriptor for the
 * {@code invokevirtual} instruction.
 *
 * @see MethodHandle
 * @see MethodHandles
 * @see MethodType
 * @since 9
 */
public abstract class VarHandle {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\management\ThreadInfo.java
    /**
     * Tests if the thread associated with this {@code ThreadInfo} is
     * a {@linkplain Thread#isDaemon daemon thread}.
     *
     * @return {@code true} if the thread is a daemon thread,
     *         {@code false} otherwise.
     * @see Thread#isDaemon
     * @since 9
     */
    public boolean isDaemon() {

    /**
     * Returns the {@linkplain Thread#getPriority() thread priority} of the
     * thread associated with this {@code ThreadInfo}.
     *
     * @return The priority of the thread associated with this
     *         {@code ThreadInfo}.
     * @since 9
     */
    public int getPriority() {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\Math.java
    /**
     * Returns the product of the arguments, throwing an exception if the result
     * overflows a {@code long}.
     *
     * @param x the first value
     * @param y the second value
     * @return the result
     * @throws ArithmeticException if the result overflows a long
     * @since 9
     */
    public static long multiplyExact(long x, int y) {

    /**
     * Returns the largest (closest to positive infinity)
     * {@code long} value that is less than or equal to the algebraic quotient.
     * There is one special case, if the dividend is the
     * {@linkplain Long#MIN_VALUE Long.MIN_VALUE} and the divisor is {@code -1},
     * then integer overflow occurs and
     * the result is equal to {@code Long.MIN_VALUE}.
     * <p>
     * Normal integer division operates under the round to zero rounding mode
     * (truncation).  This operation instead acts under the round toward
     * negative infinity (floor) rounding mode.
     * The floor rounding mode gives different results from truncation
     * when the exact result is negative.
     * <p>
     * For examples, see {@link #floorDiv(int, int)}.
     *
     * @param x the dividend
     * @param y the divisor
     * @return the largest (closest to positive infinity)
     * {@code int} value that is less than or equal to the algebraic quotient.
     * @throws ArithmeticException if the divisor {@code y} is zero
     * @see #floorMod(long, int)
     * @see #floor(double)
     * @since 9
     */
    public static long floorDiv(long x, int y) {

    /**
     * Returns the floor modulus of the {@code long} and {@int} arguments.
     * <p>
     * The floor modulus is {@code x - (floorDiv(x, y) * y)},
     * has the same sign as the divisor {@code y}, and
     * is in the range of {@code -abs(y) < r < +abs(y)}.
     *
     * <p>
     * The relationship between {@code floorDiv} and {@code floorMod} is such that:
     * <ul>
     *   <li>{@code floorDiv(x, y) * y + floorMod(x, y) == x}
     * </ul>
     * <p>
     * For examples, see {@link #floorMod(int, int)}.
     *
     * @param x the dividend
     * @param y the divisor
     * @return the floor modulus {@code x - (floorDiv(x, y) * y)}
     * @throws ArithmeticException if the divisor {@code y} is zero
     * @see #floorDiv(long, int)
     * @since 9
     */
    public static int floorMod(long x, int y) {

    /**
     * Returns the fused multiply add of the three arguments; that is,
     * returns the exact product of the first two arguments summed
     * with the third argument and then rounded once to the nearest
     * {@code double}.
     *
     * The rounding is done using the {@linkplain
     * java.math.RoundingMode#HALF_EVEN round to nearest even
     * rounding mode}.
     *
     * In contrast, if {@code a * b + c} is evaluated as a regular
     * floating-point expression, two rounding errors are involved,
     * the first for the multiply operation, the second for the
     * addition operation.
     *
     * <p>Special cases:
     * <ul>
     * <li> If any argument is NaN, the result is NaN.
     *
     * <li> If one of the first two arguments is infinite and the
     * other is zero, the result is NaN.
     *
     * <li> If the exact product of the first two arguments is infinite
     * (in other words, at least one of the arguments is infinite and
     * the other is neither zero nor NaN) and the third argument is an
     * infinity of the opposite sign, the result is NaN.
     *
     * </ul>
     *
     * <p>Note that {@code fma(a, 1.0, c)} returns the same
     * result as ({@code a + c}).  However,
     * {@code fma(a, b, +0.0)} does <em>not</em> always return the
     * same result as ({@code a * b}) since
     * {@code fma(-0.0, +0.0, +0.0)} is {@code +0.0} while
     * ({@code -0.0 * +0.0}) is {@code -0.0}; {@code fma(a, b, -0.0)} is
     * equivalent to ({@code a * b}) however.
     *
     * @apiNote This method corresponds to the fusedMultiplyAdd
     * operation defined in IEEE 754-2008.
     *
     * @param a a value
     * @param b a value
     * @param c a value
     *
     * @return (<i>a</i>&nbsp;&times;&nbsp;<i>b</i>&nbsp;+&nbsp;<i>c</i>)
     * computed, as if with unlimited range and precision, and rounded
     * once to the nearest {@code double} value
     *
     * @since 9
     */
    // @HotSpotIntrinsicCandidate
    public static double fma(double a, double b, double c) {

    /**
     * Returns the fused multiply add of the three arguments; that is,
     * returns the exact product of the first two arguments summed
     * with the third argument and then rounded once to the nearest
     * {@code float}.
     *
     * The rounding is done using the {@linkplain
     * java.math.RoundingMode#HALF_EVEN round to nearest even
     * rounding mode}.
     *
     * In contrast, if {@code a * b + c} is evaluated as a regular
     * floating-point expression, two rounding errors are involved,
     * the first for the multiply operation, the second for the
     * addition operation.
     *
     * <p>Special cases:
     * <ul>
     * <li> If any argument is NaN, the result is NaN.
     *
     * <li> If one of the first two arguments is infinite and the
     * other is zero, the result is NaN.
     *
     * <li> If the exact product of the first two arguments is infinite
     * (in other words, at least one of the arguments is infinite and
     * the other is neither zero nor NaN) and the third argument is an
     * infinity of the opposite sign, the result is NaN.
     *
     * </ul>
     *
     * <p>Note that {@code fma(a, 1.0f, c)} returns the same
     * result as ({@code a + c}).  However,
     * {@code fma(a, b, +0.0f)} does <em>not</em> always return the
     * same result as ({@code a * b}) since
     * {@code fma(-0.0f, +0.0f, +0.0f)} is {@code +0.0f} while
     * ({@code -0.0f * +0.0f}) is {@code -0.0f}; {@code fma(a, b, -0.0f)} is
     * equivalent to ({@code a * b}) however.
     *
     * @apiNote This method corresponds to the fusedMultiplyAdd
     * operation defined in IEEE 754-2008.
     *
     * @param a a value
     * @param b a value
     * @param c a value
     *
     * @return (<i>a</i>&nbsp;&times;&nbsp;<i>b</i>&nbsp;+&nbsp;<i>c</i>)
     * computed, as if with unlimited range and precision, and rounded
     * once to the nearest {@code float} value
     *
     * @since 9
     */
    // @HotSpotIntrinsicCandidate
    public static float fma(float a, float b, float c) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\module\Configuration.java
/**
 * The configuration that is the result of resolution or resolution with
 * service binding.
 *
 * <h2><a name="resolution">Resolution</a></h2>
 *
 * <p> Resolution is the process of computing the transitive closure of a set
 * of root modules over a set of observable modules by resolving the
 * dependences expressed by {@code requires} clauses.
 *
 * The <em>dependence graph</em> is augmented with edges that take account of
 * implicitly declared dependences ({@code requires public}) to create a
 * <em>readability graph</em>. A {@code Configuration} encapsulates the
 * resulting graph of {@link ResolvedModule resolved modules}.
 *
 * <p> Suppose we have the following observable modules: </p>
 * <pre> {@code
 *     module m1 { requires m2; }
 *     module m2 { requires public m3; }
 *     module m3 { }
 *     module m4 { }
 * } </pre>
 *
 * <p> If the module {@code m1} is resolved then the resulting configuration
 * contains three modules ({@code m1}, {@code m2}, {@code m3}). The edges in
 * its readability graph are: </p>
 * <pre> {@code
 *     m1 --> m2  (meaning m1 reads m2)
 *     m1 --> m3
 *     m2 --> m3
 * } </pre>
 *
 * <p> Resolution is an additive process. When computing the transitive closure
 * then the dependence relation may include dependences on modules in parent
 * configurations. The result is a <em>relative configuration</em> that is
 * relative to a parent configuration and where the readability graph may have
 * edges from modules in the configuration to modules in a parent configuration.
 * </p>
 *
 * <p> Suppose we have the following observable modules: </p>
 * <pre> {@code
 *     module m1 { requires m2; requires java.xml; }
 *     module m2 { }
 * } </pre>
 *
 * <p> If module {@code m1} is resolved with the configuration for the {@link
 * java.lang.reflect.Layer#boot() boot} layer as the parent then the resulting
 * configuration contains two modules ({@code m1}, {@code m2}). The edges in
 * its readability graph are:
 * <pre> {@code
 *     m1 --> m2
 *     m1 --> java.xml
 * } </pre>
 * where module {@code java.xml} is in the parent configuration. For
 * simplicity, this example omits the implicitly declared dependence on the
 * {@code java.base} module.
 *
 * <a name="automaticmoduleresolution"></a>
 * <p> {@link ModuleDescriptor#isAutomatic() Automatic} modules receive special
 * treatment during resolution. Each automatic module is resolved so that it
 * reads all other modules in the configuration and all parent configurations.
 * Each automatic module is also resolved as if it {@code requires public} all
 * other automatic modules in the configuration (and all automatic modules in
 * parent configurations). </p>

 * <h2><a name="servicebinding">Service binding</a></h2>
 *
 * <p> Service binding is the process of augmenting a graph of resolved modules
 * from the set of observable modules induced by the service-use dependence
 * ({@code uses} and {@code provides} clauses). Any module that was not
 * previously in the graph requires resolution to compute its transitive
 * closure. Service binding is an iterative process in that adding a module
 * that satisfies some service-use dependence may introduce new service-use
 * dependences. </p>
 *
 * <p> Suppose we have the following observable modules: </p>
 * <pre> {@code
 *     module m1 { exports p; uses p.S; }
 *     module m2 { requires m1; provides p.S with p2.S2; }
 *     module m3 { requires m1; requires m4; provides p.S with p3.S3; }
 *     module m4 { }
 * } </pre>
 *
 * <p> If the module {@code m1} is resolved then the resulting graph of modules
 * has one module ({@code m1}). If the graph is augmented with modules induced
 * by the service-use dependence relation then the configuration will contain
 * four modules ({@code m1}, {@code m2}, {@code m3}, {@code m4}). The edges in
 * its readability graph are: </p>
 * <pre> {@code
 *     m2 --> m1
 *     m3 --> m1
 *     m3 --> m4
 * } </pre>
 * <p> The edges in the conceptual service-use graph are: </p>
 * <pre> {@code
 *     m1 --> m2  (meaning m1 uses a service that is provided by m2)
 *     m1 --> m3
 * } </pre>
 *
 * <p> If this configuration is instantiated as a {@code Layer}, and if code in
 * module {@code m1} uses {@link java.util.ServiceLoader ServiceLoader} to
 * iterate over implementations of {@code p.S.class}, then it will iterate over
 * an instance of {@code p2.S2} and {@code p3.S3}. </p>
 *
 * <h3> Example </h3>
 *
 * <p> The following example uses the {@code resolveRequires} method to resolve
 * a module named <em>myapp</em> with the configuration for the boot layer as
 * the parent configuration. It prints the name of each resolved module and
 * the names of the modules that each module reads. </p>
 *
 * <pre>{@code
 *    ModuleFinder finder = ModuleFinder.of(dir1, dir2, dir3);
 *
 *    Configuration parent = Layer.boot().configuration();
 *
 *    Configuration cf = parent.resolveRequires(finder,
 *                                              ModuleFinder.of(),
 *                                              Set.of("myapp"));
 *    cf.modules().forEach(m -> {
 *        System.out.format("%s -> %s%n",
 *            m.name(),
 *            m.reads().stream()
 *                .map(ResolvedModule::name)
 *                .collect(Collectors.joining(", ")));
 *    });
 * }</pre>
 *
 * @since 9
 * @see java.lang.reflect.Layer
 */
public final class Configuration {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\module\FindException.java
/**
 * Thrown by module finders when finding a module fails.
 *
 * @see ModuleFinder
 * @since 9
 */

public class FindException extends RuntimeException {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\module\InvalidModuleDescriptorException.java
/**
 * Thrown when reading a module descriptor and the module descriptor is found
 * to be malformed or otherwise cannot be interpreted as a module descriptor.
 *
 * @see ModuleDescriptor#read
 * @since 9
 */
public class InvalidModuleDescriptorException extends RuntimeException {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\module\ModuleDescriptor.java
/**
 * A module descriptor.
 *
 * <p> A {@code ModuleDescriptor} is typically created from the binary form
 * of a module declaration. The associated {@link ModuleDescriptor.Builder}
 * class can also be used to create a {@code ModuleDescriptor} from its
 * components. </p>
 *
 * <p> {@code ModuleDescriptor} objects are immutable and safe for use by
 * multiple concurrent threads.</p>
 *
 * @since 9
 * @see java.lang.reflect.Module
 */

public class ModuleDescriptor
    implements Comparable<ModuleDescriptor>
{

    /**
     * <p> A dependence upon a module </p>
     *
     * @see ModuleDescriptor#requires()
     * @since 9
     */

    public final static class Requires
        implements Comparable<Requires>
    {

        /**
         * A modifier on a module dependence.
         *
         * @since 9
         */
        public static enum Modifier {

    /**
     * <p> A module export, may be qualified or unqualified. </p>
     *
     * @see ModuleDescriptor#exports()
     * @since 9
     */

    public final static class Exports {

    /**
     * <p> A service that a module provides one or more implementations of. </p>
     *
     * @see ModuleDescriptor#provides()
     * @since 9
     */

    public final static class Provides {

    /**
     * A module's version string.
     *
     * <p> A version string has three components: The version number itself, an
     * optional pre-release version, and an optional build version.  Each
     * component is sequence of tokens; each token is either a non-negative
     * integer or a string.  Tokens are separated by the punctuation characters
     * {@code '.'}, {@code '-'}, or {@code '+'}, or by transitions from a
     * sequence of digits to a sequence of characters that are neither digits
     * nor punctuation characters, or vice versa.
     *
     * <ul>
     *
     *   <li> The <i>version number</i> is a sequence of tokens separated by
     *   {@code '.'} characters, terminated by the first {@code '-'} or {@code
     *   '+'} character. </li>
     *
     *   <li> The <i>pre-release version</i> is a sequence of tokens separated
     *   by {@code '.'} or {@code '-'} characters, terminated by the first
     *   {@code '+'} character. </li>
     *
     *   <li> The <i>build version</i> is a sequence of tokens separated by
     *   {@code '.'}, {@code '-'}, or {@code '+'} characters.
     *
     * </ul>
     *
     * <p> When comparing two version strings, the elements of their
     * corresponding components are compared in pointwise fashion.  If one
     * component is longer than the other, but otherwise equal to it, then the
     * first component is considered the greater of the two; otherwise, if two
     * corresponding elements are integers then they are compared as such;
     * otherwise, at least one of the elements is a string, so the other is
     * converted into a string if it is an integer and the two are compared
     * lexicographically.  Trailing integer elements with the value zero are
     * ignored.
     *
     * <p> Given two version strings, if their version numbers differ then the
     * result of comparing them is the result of comparing their version
     * numbers; otherwise, if one of them has a pre-release version but the
     * other does not then the first is considered to precede the second,
     * otherwise the result of comparing them is the result of comparing their
     * pre-release versions; otherwise, the result of comparing them is the
     * result of comparing their build versions.
     *
     * @see ModuleDescriptor#version()
     * @since 9
     */

    public final static class Version
        implements Comparable<Version>
    {

    /**
     * A builder used for building {@link ModuleDescriptor} objects.
     *
     * <p> Example usage: </p>
     *
     * <pre>{@code
     *     ModuleDescriptor descriptor = new ModuleDescriptor.Builder("m1")
     *         .requires("m2")
     *         .exports("p")
     *         .build();
     * }</pre>
     *
     * @apiNote A {@code Builder} cannot be used to create an {@link
     * ModuleDescriptor#isAutomatic() automatic} or a {@link
     * ModuleDescriptor#isSynthetic() synthetic} module.
     *
     * @since 9
     */
    public static final class Builder {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\module\ModuleFinder.java
/**
 * A finder of modules. A {@code ModuleFinder} is used to find modules during
 * <a href="Configuration.html#resolution">resolution</a> or
 * <a href="Configuration.html#servicebinding">service binding</a>.
 *
 * <p> A {@code ModuleFinder} can only find one module with a given name. A
 * {@code ModuleFinder} that finds modules in a sequence of directories, for
 * example, will locate the first occurrence of a module of a given name and
 * will ignore other modules of that name that appear in directories later in
 * the sequence. </p>
 *
 * <p> Example usage: </p>
 *
 * <pre>{@code
 *     Path dir1, dir2, dir3;
 *
 *     ModuleFinder finder = ModuleFinder.of(dir1, dir2, dir3);
 *
 *     Optional<ModuleReference> omref = finder.find("jdk.foo");
 *     omref.ifPresent(mref -> ... );
 *
 * }</pre>
 *
 * <p> The {@link #find(String) find} and {@link #findAll() findAll} methods
 * defined here can fail for several reasons. These include I/O errors, errors
 * detected parsing a module descriptor ({@code module-info.class}), or in the
 * case of {@code ModuleFinder} returned by {@link #of ModuleFinder.of}, that
 * two or more modules with the same name are found in a directory.
 * When an error is detected then these methods throw {@link FindException
 * FindException} with an appropriate {@link Throwable#getCause cause}.
 * The behavior of a {@code ModuleFinder} after a {@code FindException} is
 * thrown is undefined. For example, invoking {@code find} after an exception
 * is thrown may or may not scan the same modules that lead to the exception.
 * It is recommended that a module finder be discarded after an exception is
 * thrown. </p>
 *
 * <p> A {@code ModuleFinder} is not required to be thread safe. </p>
 *
 * @since 9
 */

public interface ModuleFinder {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\module\ModuleReader.java
/**
 * Provides access to the content of a module.
 *
 * <p> A module reader is intended for cases where access to the resources in a
 * module is required, regardless of whether the module has been loaded.
 * A framework that scans a collection of packaged modules on the file system,
 * for example, may use a module reader to access a specific resource in each
 * module. A module reader is also intended to be used by {@code ClassLoader}
 * implementations that load classes and resources from modules. </p>
 *
 * <p> A {@code ModuleReader} is {@linkplain ModuleReference#open open} upon
 * creation and is closed by invoking the {@link #close close} method.  Failure
 * to close a module reader may result in a resource leak.  The {@code
 * try-with-resources} statement provides a useful construct to ensure that
 * module readers are closed. </p>
 *
 * <p> A {@code ModuleReader} implementation may require permissions to access
 * resources in the module. Consequently the {@link #find find}, {@link #open
 * open} and {@link #read read} methods may throw {@code SecurityException} if
 * access is denied by the security manager. </p>
 *
 * @see ModuleReference
 * @since 9
 */

public interface ModuleReader extends Closeable {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\module\ModuleReference.java
/**
 * A reference to a module's content.
 *
 * <p> A module reference contains the module's descriptor and its location, if
 * known.  It also has the ability to create a {@link ModuleReader} in order to
 * access the module's content, which may be inside the Java run-time system
 * itself or in an artifact such as a modular JAR file.
 *
 * @see ModuleFinder
 * @see ModuleReader
 * @since 9
 */

public final class ModuleReference {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\module\package-info.java
/**
 * Classes to support module descriptors and creating configurations of modules
 * by means of resolution and service binding.
 *
 * <p> Unless otherwise noted, passing a {@code null} argument to a constructor
 * or method of any class or interface in this package will cause a {@link
 * java.lang.NullPointerException NullPointerException} to be thrown. Additionally,
 * invoking a method with an array or collection containing a {@code null} element
 * will cause a {@code NullPointerException}, unless otherwise specified. </p>
 *
 * @since 9
 */

package java.lang.module;

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\module\ResolutionException.java
/**
 * Thrown when resolving a set of modules or binding fails.
 *
 * @see Configuration
 * @since 9
 */
public class ResolutionException extends RuntimeException {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\module\ResolvedModule.java
/**
 * A module in a graph of <em>resolved modules</em>.
 *
 * <p> {@code ResolvedModule} defines the {@link #configuration configuration}
 * method to get the configuration that the resolved module is in. It defines
 * the {@link #reference() reference} method to get the reference to the
 * module's content.
 *
 * @since 9
 * @see Configuration#modules()
 */
public final class ResolvedModule {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\Process.java
    /**
     * Returns {@code true} if the implementation of {@link #destroy} is to
     * normally terminate the process,
     * Returns {@code false} if the implementation of {@code destroy}
     * forcibly and immediately terminates the process.
     * <p>
     * Invoking this method on {@code Process} objects returned by
     * {@link ProcessBuilder#start} and {@link Runtime#exec} return
     * {@code true} or {@code false} depending on the platform implementation.
     *
     * @implSpec
     * This implementation throws an instance of
     * {@link java.lang.UnsupportedOperationException} and performs no other action.
     *
     * @return {@code true} if the implementation of {@link #destroy} is to
     *         normally terminate the process;
     *         otherwise, {@link #destroy} forcibly terminates the process
     * @throws UnsupportedOperationException if the Process implementation
     *         does not support this operation
     * @since 9
     */
    public boolean supportsNormalTermination() {

    /**
     * Returns the native process ID of the process.
     * The native process ID is an identification number that the operating
     * system assigns to the process.
     *
     * @implSpec
     * The implementation of this method returns the process id as:
     * {@link #toHandle toHandle().getPid()}.
     *
     * @return the native process id of the process
     * @throws UnsupportedOperationException if the Process implementation
     *         does not support this operation
     * @since 9
     */
    public long getPid() {

    /**
     * Returns a {@code CompletableFuture<Process>} for the termination of the Process.
     * The {@link java.util.concurrent.CompletableFuture} provides the ability
     * to trigger dependent functions or actions that may be run synchronously
     * or asynchronously upon process termination.
     * When the process has terminated the CompletableFuture is
     * {@link java.util.concurrent.CompletableFuture#complete completed} regardless
     * of the exit status of the process.
     * <p>
     * Calling {@code onExit().get()} waits for the process to terminate and returns
     * the Process. The future can be used to check if the process is
     * {@link java.util.concurrent.CompletableFuture#isDone done} or to
     * {@link java.util.concurrent.CompletableFuture#get() wait} for it to terminate.
     * {@link java.util.concurrent.CompletableFuture#cancel(boolean) Cancelling}
     * the CompletableFuture does not affect the Process.
     * <p>
     * Processes returned from {@link ProcessBuilder#start} override the
     * default implementation to provide an efficient mechanism to wait
     * for process exit.
     *
     * @apiNote
     * Using {@link #onExit() onExit} is an alternative to
     * {@link #waitFor() waitFor} that enables both additional concurrency
     * and convenient access to the result of the Process.
     * Lambda expressions can be used to evaluate the result of the Process
     * execution.
     * If there is other processing to be done before the value is used
     * then {@linkplain #onExit onExit} is a convenient mechanism to
     * free the current thread and block only if and when the value is needed.
     * <br>
     * For example, launching a process to compare two files and get a boolean if they are identical:
     * <pre> {@code   Process p = new ProcessBuilder("cmp", "f1", "f2").start();
     *    Future<Boolean> identical = p.onExit().thenApply(p1 -> p1.exitValue() == 0);
     *    ...
     *    if (identical.get()) { ... }
     * }</pre>
     *
     * @implSpec
     * This implementation executes {@link #waitFor()} in a separate thread
     * repeatedly until it returns successfully. If the execution of
     * {@code waitFor} is interrupted, the thread's interrupt status is preserved.
     * <p>
     * When {@link #waitFor()} returns successfully the CompletableFuture is
     * {@link java.util.concurrent.CompletableFuture#complete completed} regardless
     * of the exit status of the process.
     *
     * This implementation may consume a lot of memory for thread stacks if a
     * large number of processes are waited for concurrently.
     * <p>
     * External implementations should override this method and provide
     * a more efficient implementation. For example, to delegate to the underlying
     * process, it can do the following:
     * <pre>{@code
     *    public CompletableFuture<Process> onExit() {
     *       return delegate.onExit().thenApply(p -> this);
     *    }
     * }</pre>
     * @apiNote
     * The process may be observed to have terminated with {@link #isAlive}
     * before the ComputableFuture is completed and dependent actions are invoked.
     *
     * @return a new {@code CompletableFuture<Process>} for the Process
     *
     * @since 9
     */
    public CompletableFuture<Process> onExit() {

    /**
     * Returns a ProcessHandle for the Process.
     *
     * {@code Process} objects returned by {@link ProcessBuilder#start} and
     * {@link Runtime#exec} implement {@code toHandle} as the equivalent of
     * {@link ProcessHandle#of(long) ProcessHandle.of(pid)} including the
     * check for a SecurityManager and {@code RuntimePermission("manageProcess")}.
     *
     * @implSpec
     * This implementation throws an instance of
     * {@link java.lang.UnsupportedOperationException} and performs no other action.
     * Subclasses should override this method to provide a ProcessHandle for the
     * process.  The methods {@link #getPid}, {@link #info}, {@link #children},
     * and {@link #descendants}, unless overridden, operate on the ProcessHandle.
     *
     * @return Returns a ProcessHandle for the Process
     * @throws UnsupportedOperationException if the Process implementation
     *         does not support this operation
     * @throws SecurityException if a security manager has been installed and
     *         it denies RuntimePermission("manageProcess")
     * @since 9
     */
    public ProcessHandle toHandle() {

    /**
     * Returns a snapshot of information about the process.
     *
     * <p> A {@link ProcessHandle.Info} instance has accessor methods
     * that return information about the process if it is available.
     *
     * @implSpec
     * This implementation returns information about the process as:
     * {@link #toHandle toHandle().info()}.
     *
     * @return a snapshot of information about the process, always non-null
     * @throws UnsupportedOperationException if the Process implementation
     *         does not support this operation
     * @since 9
     */
    public ProcessHandle.Info info() {

    /**
     * Returns a snapshot of the direct children of the process.
     * The parent of a direct child process is the process.
     * Typically, a process that is {@link #isAlive not alive} has no children.
     * <p>
     * <em>Note that processes are created and terminate asynchronously.
     * There is no guarantee that a process is {@link #isAlive alive}.
     * </em>
     *
     * @implSpec
     * This implementation returns the direct children as:
     * {@link #toHandle toHandle().children()}.
     *
     * @return a sequential Stream of ProcessHandles for processes that are
     *         direct children of the process
     * @throws UnsupportedOperationException if the Process implementation
     *         does not support this operation
     * @throws SecurityException if a security manager has been installed and
     *         it denies RuntimePermission("manageProcess")
     * @since 9
     */
    public Stream<ProcessHandle> children() {

    /**
     * Returns a snapshot of the descendants of the process.
     * The descendants of a process are the children of the process
     * plus the descendants of those children, recursively.
     * Typically, a process that is {@link #isAlive not alive} has no children.
     * <p>
     * <em>Note that processes are created and terminate asynchronously.
     * There is no guarantee that a process is {@link #isAlive alive}.
     * </em>
     *
     * @implSpec
     * This implementation returns all children as:
     * {@link #toHandle toHandle().descendants()}.
     *
     * @return a sequential Stream of ProcessHandles for processes that
     *         are descendants of the process
     * @throws UnsupportedOperationException if the Process implementation
     *         does not support this operation
     * @throws SecurityException if a security manager has been installed and
     *         it denies RuntimePermission("manageProcess")
     * @since 9
     */
    public Stream<ProcessHandle> descendants() {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\ProcessBuilder.java
        /**
         * Indicates that subprocess output will be discarded.
         * A typical implementation discards the output by writing to
         * an operating system specific "null file".
         *
         * <p>It will always be true that
         * <pre> {@code
         * Redirect.DISCARD.file() is the filename appropriate for the operating system
         * and may be null &&
         * Redirect.DISCARD.type() == Redirect.Type.WRITE
         * }</pre>
         * @since 9
         */
        public static final Redirect DISCARD = new Redirect() {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\ProcessHandle.java
/**
 * ProcessHandle identifies and provides control of native processes. Each
 * individual process can be monitored for liveness, list its children,
 * get information about the process or destroy it.
 * By comparison, {@link java.lang.Process Process} instances were started
 * by the current process and additionally provide access to the process
 * input, output, and error streams.
 * <p>
 * The native process ID is an identification number that the
 * operating system assigns to the process.
 * The range for process id values is dependent on the operating system.
 * For example, an embedded system might use a 16-bit value.
 * Status information about a process is retrieved from the native system
 * and may change asynchronously; processes may be created or terminate
 * spontaneously.
 * The time between when a process terminates and the process id
 * is reused for a new process is unpredictable.
 * Race conditions can exist between checking the status of a process and
 * acting upon it. When using ProcessHandles avoid assumptions
 * about the liveness or identity of the underlying process.
 * <p>
 * Each ProcessHandle identifies and allows control of a process in the native
 * system. ProcessHandles are returned from the factory methods {@link #current()},
 * {@link #of(long)},
 * {@link #children}, {@link #descendants}, {@link #parent()} and
 * {@link #allProcesses()}.
 * <p>
 * The {@link Process} instances created by {@link ProcessBuilder} can be queried
 * for a ProcessHandle that provides information about the Process.
 * ProcessHandle references should not be freely distributed.
 *
 * <p>
 * A {@link java.util.concurrent.CompletableFuture} available from {@link #onExit}
 * can be used to wait for process termination, and possibly trigger dependent
 * actions.
 * <p>
 * The factory methods limit access to ProcessHandles using the
 * SecurityManager checking the {@link RuntimePermission RuntimePermission("manageProcess")}.
 * The ability to control processes is also restricted by the native system,
 * ProcessHandle provides no more access to, or control over, the native process
 * than would be allowed by a native application.
 *
 * @implSpec
 * In the case where ProcessHandles cannot be supported then the factory
 * methods must consistently throw {@link java.lang.UnsupportedOperationException}.
 * The methods of this class throw {@link java.lang.UnsupportedOperationException}
 * if the operating system does not allow access to query or kill a process.
 *
 * <p>
 * The {@code ProcessHandle} static factory methods return instances that are
 * <a href="{@docRoot}/java/lang/doc-files/ValueBased.html">value-based</a>,
 * immutable and thread-safe.
 * Use of identity-sensitive operations (including reference equality
 * ({@code ==}), identity hash code, or synchronization) on these instances of
 * {@code ProcessHandle} may have unpredictable results and should be avoided.
 * Use {@link #equals(Object) equals} or
 * {@link #compareTo(ProcessHandle) compareTo} methods to compare ProcessHandles.
 *
 * @see Process
 * @since 9
 */
public interface ProcessHandle extends Comparable<ProcessHandle> {

    /**
     * Information snapshot about the process.
     * The attributes of a process vary by operating system and are not available
     * in all implementations.  Information about processes is limited
     * by the operating system privileges of the process making the request.
     * The return types are {@code Optional<T>} allowing explicit tests
     * and actions if the value is available.
     * @since 9
     */
    public interface Info {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\ProcessHandleImpl.java
/**
 * ProcessHandleImpl is the implementation of ProcessHandle.
 *
 * @see Process
 * @since 9
 */
final class ProcessHandleImpl implements ProcessHandle {

    /**
     * Tests whether the process represented by this {@code ProcessHandle} is alive.
     *
     * @return {@code true} if the process represented by this
     * {@code ProcessHandle} object has not yet terminated.
     * @since 9
     */
    @Override
    public boolean isAlive() {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\ref\Cleaner.java
/**
 * {@code Cleaner} manages a set of object references and corresponding cleaning actions.
 * <p>
 * Cleaning actions are {@link #register(Object object, Runnable action) registered}
 * to run after the cleaner is notified that the object has become
 * phantom reachable.
 * The cleaner uses {@link PhantomReference} and {@link ReferenceQueue} to be
 * notified when the <a href="package-summary.html#reachability">reachability</a>
 * changes.
 * <p>
 * Each cleaner operates independently, managing the pending cleaning actions
 * and handling threading and termination when the cleaner is no longer in use.
 * Registering an object reference and corresponding cleaning action returns
 * a {@link Cleanable Cleanable}. The most efficient use is to explicitly invoke
 * the {@link Cleanable#clean clean} method when the object is closed or
 * no longer needed.
 * The cleaning action is a {@link Runnable} to be invoked at most once when
 * the object has become phantom reachable unless it has already been explicitly cleaned.
 * Note that the cleaning action must not refer to the object being registered.
 * If so, the object will not become phantom reachable and the cleaning action
 * will not be invoked automatically.
 * <p>
 * The execution of the cleaning action is performed
 * by a thread associated with the cleaner.
 * All exceptions thrown by the cleaning action are ignored.
 * The cleaner and other cleaning actions are not affected by
 * exceptions in a cleaning action.
 * The thread runs until all registered cleaning actions have
 * completed and the cleaner itself is reclaimed by the garbage collector.
 * <p>
 * The behavior of cleaners during {@link System#exit(int) System.exit}
 * is implementation specific. No guarantees are made relating
 * to whether cleaning actions are invoked or not.
 * <p>
 * Unless otherwise noted, passing a {@code null} argument to a constructor or
 * method in this class will cause a
 * {@link java.lang.NullPointerException NullPointerException} to be thrown.
 *
 * @apiNote
 * The cleaning action is invoked only after the associated object becomes
 * phantom reachable, so it is important that the object implementing the
 * cleaning action does not hold references to the object.
 * In this example, a static class encapsulates the cleaning state and action.
 * An "inner" class, anonymous or not,  must not be used because it implicitly
 * contains a reference to the outer instance, preventing it from becoming
 * phantom reachable.
 * The choice of a new cleaner or sharing an existing cleaner is determined
 * by the use case.
 * <p>
 * If the CleaningExample is used in a try-finally block then the
 * {@code close} method calls the cleaning action.
 * If the {@code close} method is not called, the cleaning action is called
 * by the Cleaner when the CleaningExample instance has become phantom reachable.
 * <pre>{@code
 * public class CleaningExample implements AutoCloseable {
 *        // A cleaner, preferably one shared within a library
 *        private static final Cleaner cleaner = <cleaner>;
 *
 *        static class State implements Runnable {
 *
 *            State(...) {
 *                // initialize State needed for cleaning action
 *            }
 *
 *            public void run() {
 *                // cleanup action accessing State, executed at most once
 *            }
 *        }
 *
 *        private final State;
 *        private final Cleaner.Cleanable cleanable
 *
 *        public CleaningExample() {
 *            this.state = new State(...);
 *            this.cleanable = cleaner.register(this, state);
 *        }
 *
 *        public void close() {
 *            cleanable.clean();
 *        }
 *    }
 * }</pre>
 * The cleaning action could be a lambda but all too easily will capture
 * the object reference, by referring to fields of the object being cleaned,
 * preventing the object from becoming phantom reachable.
 * Using a static nested class, as above, will avoid accidentally retaining the
 * object reference.
 * <p>
 * <a name="compatible-cleaners"></a>
 * Cleaning actions should be prepared to be invoked concurrently with
 * other cleaning actions.
 * Typically the cleaning actions should be very quick to execute
 * and not block. If the cleaning action blocks, it may delay processing
 * other cleaning actions registered to the same cleaner.
 * All cleaning actions registered to a cleaner should be mutually compatible.
 * @since 9
 */
public final class Cleaner {

    /**
     * {@code Cleanable} represents an object and a
     * cleaning action registered in a {@code Cleaner}.
     * @since 9
     */
    public interface Cleanable {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\ref\Reference.java
    /**
     * Ensures that the object referenced by the given reference remains
     * <a href="package-summary.html#reachability"><em>strongly reachable</em></a>,
     * regardless of any prior actions of the program that might otherwise cause
     * the object to become unreachable; thus, the referenced object is not
     * reclaimable by garbage collection at least until after the invocation of
     * this method.  Invocation of this method does not itself initiate garbage
     * collection or finalization.
     *
     * <p> This method establishes an ordering for
     * <a href="package-summary.html#reachability"><em>strong reachability</em></a>
     * with respect to garbage collection.  It controls relations that are
     * otherwise only implicit in a program -- the reachability conditions
     * triggering garbage collection.  This method is designed for use in
     * uncommon situations of premature finalization where using
     * {@code synchronized} blocks or methods, or using other synchronization
     * facilities are not possible or do not provide the desired control.  This
     * method is applicable only when reclamation may have visible effects,
     * which is possible for objects with finalizers (See
     * <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html#jls-12.6">
     * Section 12.6 17 of <cite>The Java&trade; Language Specification</cite></a>)
     * that are implemented in ways that rely on ordering control for correctness.
     *
     * @apiNote
     * Finalization may occur whenever the virtual machine detects that no
     * reference to an object will ever be stored in the heap: The garbage
     * collector may reclaim an object even if the fields of that object are
     * still in use, so long as the object has otherwise become unreachable.
     * This may have surprising and undesirable effects in cases such as the
     * following example in which the bookkeeping associated with a class is
     * managed through array indices.  Here, method {@code action} uses a
     * {@code reachabilityFence} to ensure that the {@code Resource} object is
     * not reclaimed before bookkeeping on an associated
     * {@code ExternalResource} has been performed; in particular here, to
     * ensure that the array slot holding the {@code ExternalResource} is not
     * nulled out in method {@link Object#finalize}, which may otherwise run
     * concurrently.
     *
     * <pre> {@code
     * class Resource {
     *   private static ExternalResource[] externalResourceArray = ...
     *
     *   int myIndex;
     *   Resource(...) {
     *     myIndex = ...
     *     externalResourceArray[myIndex] = ...;
     *     ...
     *   }
     *   protected void finalize() {
     *     externalResourceArray[myIndex] = null;
     *     ...
     *   }
     *   public void action() {
     *     try {
     *       // ...
     *       int i = myIndex;
     *       Resource.update(externalResourceArray[i]);
     *     } finally {
     *       Reference.reachabilityFence(this);
     *     }
     *   }
     *   private static void update(ExternalResource ext) {
     *     ext.status = ...;
     *   }
     * }}</pre>
     *
     * Here, the invocation of {@code reachabilityFence} is nonintuitively
     * placed <em>after</em> the call to {@code update}, to ensure that the
     * array slot is not nulled out by {@link Object#finalize} before the
     * update, even if the call to {@code action} was the last use of this
     * object.  This might be the case if, for example a usage in a user program
     * had the form {@code new Resource().action();} which retains no other
     * reference to this {@code Resource}.  While probably overkill here,
     * {@code reachabilityFence} is placed in a {@code finally} block to ensure
     * that it is invoked across all paths in the method.  In a method with more
     * complex control paths, you might need further precautions to ensure that
     * {@code reachabilityFence} is encountered along all of them.
     *
     * <p> It is sometimes possible to better encapsulate use of
     * {@code reachabilityFence}.  Continuing the above example, if it were
     * acceptable for the call to method {@code update} to proceed even if the
     * finalizer had already executed (nulling out slot), then you could
     * localize use of {@code reachabilityFence}:
     *
     * <pre> {@code
     * public void action2() {
     *   // ...
     *   Resource.update(getExternalResource());
     * }
     * private ExternalResource getExternalResource() {
     *   ExternalResource ext = externalResourceArray[myIndex];
     *   Reference.reachabilityFence(this);
     *   return ext;
     * }}</pre>
     *
     * <p> Method {@code reachabilityFence} is not required in constructions
     * that themselves ensure reachability.  For example, because objects that
     * are locked cannot, in general, be reclaimed, it would suffice if all
     * accesses of the object, in all methods of class {@code Resource}
     * (including {@code finalize}) were enclosed in {@code synchronized (this)}
     * blocks.  (Further, such blocks must not include infinite loops, or
     * themselves be unreachable, which fall into the corner case exceptions to
     * the "in general" disclaimer.)  However, method {@code reachabilityFence}
     * remains a better option in cases where this approach is not as efficient,
     * desirable, or possible; for example because it would encounter deadlock.
     *
     * @param ref the reference. If {@code null}, this method has no effect.
     * @since 9
     */
    @DontInline
    public static void reachabilityFence(Object ref) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\reflect\AnnotatedArrayType.java
    /**
     * Returns the potentially annotated type that this type is a member of, if
     * this type represents a nested type. For example, if this type is
     * {@code @TA O<T>.I<S>}, return a representation of {@code @TA O<T>}.
     *
     * <p>Returns {@code null} for an {@code AnnotatedType} that is an instance
     *     of {@code AnnotatedArrayType}.
     *
     * @return {@code null}
     *
     * @since 9
     */
    @Override
    AnnotatedType getAnnotatedOwnerType();

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\reflect\AnnotatedParameterizedType.java
    /**
     * Returns the potentially annotated type that this type is a member of, if
     * this type represents a nested type. For example, if this type is
     * {@code @TA O<T>.I<S>}, return a representation of {@code @TA O<T>}.
     *
     * <p>Returns {@code null} if this {@code AnnotatedType} represents a
     *     top-level type, or a local or anonymous class, or a primitive type, or
     *     void.
     *
     * @return an {@code AnnotatedType} object representing the potentially
     *     annotated type that this type is a member of, or {@code null}
     * @throws TypeNotPresentException if the owner type
     *     refers to a non-existent type declaration
     * @throws MalformedParameterizedTypeException if the owner type
     *     refers to a parameterized type that cannot be instantiated
     *     for any reason
     *
     * @since 9
     */
    @Override
    AnnotatedType getAnnotatedOwnerType();

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\reflect\AnnotatedType.java
    /**
     * Returns the potentially annotated type that this type is a member of, if
     * this type represents a nested type. For example, if this type is
     * {@code @TA O<T>.I<S>}, return a representation of {@code @TA O<T>}.
     *
     * <p>Returns {@code null} if this {@code AnnotatedType} represents a
     *     top-level type, or a local or anonymous class, or a primitive type, or
     *     void.
     *
     * <p>Returns {@code null} if this {@code AnnotatedType} is an instance of
     *     {@code AnnotatedArrayType}, {@code AnnotatedTypeVariable}, or
     *     {@code AnnotatedWildcardType}.
     *
     * @implSpec
     * This default implementation returns {@code null} and performs no other
     * action.
     *
     * @return an {@code AnnotatedType} object representing the potentially
     *     annotated type that this type is a member of, or {@code null}
     * @throws TypeNotPresentException if the owner type
     *     refers to a non-existent type declaration
     * @throws MalformedParameterizedTypeException if the owner type
     *     refers to a parameterized type that cannot be instantiated
     *     for any reason
     *
     * @since 9
     */
    default AnnotatedType getAnnotatedOwnerType() {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\reflect\AnnotatedTypeVariable.java
    /**
     * Returns the potentially annotated type that this type is a member of, if
     * this type represents a nested type. For example, if this type is
     * {@code @TA O<T>.I<S>}, return a representation of {@code @TA O<T>}.
     *
     * <p>Returns {@code null} for an {@code AnnotatedType} that is an instance
     *     of {@code AnnotatedTypeVariable}.
     *
     * @return {@code null}
     *
     * @since 9
     */
    @Override
    AnnotatedType getAnnotatedOwnerType();

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\reflect\AnnotatedWildcardType.java
    /**
     * Returns the potentially annotated type that this type is a member of, if
     * this type represents a nested type. For example, if this type is
     * {@code @TA O<T>.I<S>}, return a representation of {@code @TA O<T>}.
     *
     * <p>Returns {@code null} for an {@code AnnotatedType} that is an instance
     *     of {@code AnnotatedWildcardType}.
     *
     * @return {@code null}
     *
     * @since 9
     */
    @Override
    AnnotatedType getAnnotatedOwnerType();

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\reflect\InaccessibleObjectException.java
/**
 * Thrown when Java language access checks cannot be suppressed.
 *
 * @see AccessibleObject#setAccessible(boolean)
 * @since 9
 */

public class InaccessibleObjectException extends RuntimeException {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\reflect\Layer.java
/**
 * A layer of modules in the Java virtual machine.
 *
 * <p> A layer is created from a graph of modules that is the {@link
 * Configuration} and a function that maps each module to a {@link ClassLoader}.
 * Creating a layer informs the Java virtual machine about the classes that
 * may be loaded from modules so that the Java virtual machine knows which
 * module that each class is a member of. Each layer, except the {@link
 * #empty() empty} layer, has a {@link #parent() parent}. </p>
 *
 * <p> Creating a layer creates a {@link Module} object for each {@link
 * ResolvedModule} in the configuration. For each resolved module that is
 * {@link ResolvedModule#reads() read}, the {@code Module} {@link
 * Module#canRead reads} the corresponding run-time {@code Module}, which may
 * be in the same layer or a parent layer. The {@code Module} {@link
 * Module#isExported(String) exports} the packages described by its {@link
 * ModuleDescriptor}. </p>
 *
 * <p> The {@link #defineModulesWithOneLoader defineModulesWithOneLoader} and
 * {@link #defineModulesWithManyLoaders defineModulesWithManyLoaders} methods
 * provide convenient ways to create a {@code Layer} where all modules are
 * mapped to a single class loader or where each module is mapped to its own
 * class loader. The {@link #defineModules defineModules} method is for more
 * advanced cases where modules are mapped to custom class loaders by means of
 * a function specified to the method. </p>
 *
 * <p> A Java virtual machine has at least one non-empty layer, the {@link
 * #boot() boot} layer, that is created when the Java virtual machine is
 * started. The boot layer contains module {@code java.base} and is the only
 * layer in the Java virtual machine with a module named "{@code java.base}".
 * The modules in the boot layer are mapped to the bootstrap class loader and
 * other class loaders that are <a href="../ClassLoader.html#builtinLoaders">
 * built-in</a> into the Java virtual machine. The boot layer will often be
 * the {@link #parent() parent} when creating additional layers. </p>
 *
 * <p> As when creating a {@code Configuration},
 * {@link ModuleDescriptor#isAutomatic() automatic} modules receive
 * <a href="../module/Configuration.html#automaticmoduleresolution">special
 * treatment</a> when creating a layer. An automatic module is created in the
 * Java virtual machine as a {@code Module} that reads every unnamed {@code
 * Module} in the Java virtual machine. </p>
 *
 * <p> Unless otherwise specified, passing a {@code null} argument to a method
 * in this class causes a {@link NullPointerException NullPointerException} to
 * be thrown. </p>
 *
 * <h3> Example usage: </h3>
 *
 * <p> This example creates a configuration by resolving a module named
 * "{@code myapp}" with the configuration for the boot layer as the parent. It
 * then creates a new layer with the modules in this configuration. All modules
 * are defined to the same class loader. </p>
 *
 * <pre>{@code
 *     ModuleFinder finder = ModuleFinder.of(dir1, dir2, dir3);
 *
 *     Layer parent = Layer.boot();
 *
 *     Configuration cf = parent.configuration()
 *         .resolveRequires(finder, ModuleFinder.of(), Set.of("myapp"));
 *
 *     ClassLoader scl = ClassLoader.getSystemClassLoader();
 *
 *     Layer layer = parent.defineModulesWithOneLoader(cf, scl);
 *
 *     Class<?> c = layer.findLoader("myapp").loadClass("app.Main");
 * }</pre>
 *
 * @since 9
 * @see Module#getLayer()
 */

public final class Layer {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\reflect\LayerInstantiationException.java
/**
 * Thrown when creating a Layer fails.
 *
 * @see Layer
 *
 * @since 9
 */
public class LayerInstantiationException extends RuntimeException {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\reflect\Module.java
/**
 * Represents a run-time module, either {@link #isNamed() named} or unnamed.
 *
 * <p> Named modules have a {@link #getName() name} and are constructed by the
 * Java Virtual Machine when a graph of modules is defined to the Java virtual
 * machine to create a module {@link Layer Layer}. </p>
 *
 * <p> An unnamed module does not have a name. There is an unnamed module
 * per {@link ClassLoader ClassLoader} that is obtained by invoking the class
 * loader's {@link ClassLoader#getUnnamedModule() getUnnamedModule} method. The
 * {@link Class#getModule() getModule} method of all types defined by a class
 * loader that are not in a named module return the class loader's unnamed
 * module. </p>
 *
 * <p> The package names that are parameters or returned by methods defined in
 * this class are the fully-qualified names of the packages as defined in
 * section 6.5.3 of <cite>The Java&trade; Language Specification </cite>, for
 * example, {@code "java.lang"}. </p>
 *
 * <p> Unless otherwise specified, passing a {@code null} argument to a method
 * in this class causes a {@link NullPointerException NullPointerException} to
 * be thrown. </p>
 *
 * @since 9
 * @see java.lang.Class#getModule
 */

public final class Module {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\Short.java
    /**
     * Compares two {@code short} values numerically treating the values
     * as unsigned.
     *
     * @param  x the first {@code short} to compare
     * @param  y the second {@code short} to compare
     * @return the value {@code 0} if {@code x == y}; a value less
     *         than {@code 0} if {@code x < y} as unsigned values; and
     *         a value greater than {@code 0} if {@code x > y} as
     *         unsigned values
     * @since 9
     */
    public static int compareUnsigned(short x, short y) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\StackTraceElement.java
    /**
     * Creates a stack trace element representing the specified execution
     * point.
     *
     * @param moduleName the module name if the class containing the
     *        execution point represented by the stack trace is in a named
     *        module; can be {@code null}
     * @param moduleVersion the module version if the class containing the
     *        execution point represented by the stack trace is in a named
     *        module that has a version; can be {@code null}
     * @param declaringClass the fully qualified name of the class containing
     *        the execution point represented by the stack trace element
     * @param methodName the name of the method containing the execution point
     *        represented by the stack trace element
     * @param fileName the name of the file containing the execution point
     *        represented by the stack trace element, or {@code null} if
     *        this information is unavailable
     * @param lineNumber the line number of the source line containing the
     *        execution point represented by this stack trace element, or
     *        a negative number if this information is unavailable. A value
     *        of -2 indicates that the method containing the execution point
     *        is a native method
     * @throws NullPointerException if {@code declaringClass} is {@code null}
     *         or {@code methodName} is {@code null}
     * @since 9
     */
    public StackTraceElement(String moduleName, String moduleVersion,
                             String declaringClass, String methodName,
                             String fileName, int lineNumber) {

    /**
     * Returns the module name of the module containing the execution point
     * represented by this stack trace element.
     *
     * @return the module name of the {@code Module} containing the execution
     *         point represented by this stack trace element; {@code null}
     *         if the module name is not available.
     * @since 9
     * @see java.lang.reflect.Module#getName()
     */
    public String getModuleName() {

    /**
     * Returns the module version of the module containing the execution point
     * represented by this stack trace element.
     *
     * @return the module version of the {@code Module} containing the execution
     *         point represented by this stack trace element; {@code null}
     *         if the module version is not available.
     * @since 9
     * @see java.lang.module.ModuleDescriptor.Version
     */
    public String getModuleVersion() {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\StackWalker.java
/**
 * A stack walker.
 *
 * <p> The {@link StackWalker#walk walk} method opens a sequential stream
 * of {@link StackFrame StackFrame}s for the current thread and then applies
 * the given function to walk the {@code StackFrame} stream.
 * The stream reports stack frame elements in order, from the top most frame
 * that represents the execution point at which the stack was generated to
 * the bottom most frame.
 * The {@code StackFrame} stream is closed when the {@code walk} method returns.
 * If an attempt is made to reuse the closed stream,
 * {@code IllegalStateException} will be thrown.
 *
 * <p> The {@linkplain Option <em>stack walking options</em>} of a
 * {@code StackWalker} determines the information of
 * {@link StackFrame StackFrame} objects to be returned.
 * By default, stack frames of the reflection API and implementation
 * classes are {@linkplain Option#SHOW_HIDDEN_FRAMES hidden}
 * and {@code StackFrame}s have the class name and method name
 * available but not the {@link StackFrame#getDeclaringClass() Class reference}.
 *
 * <p> {@code StackWalker} is thread-safe. Multiple threads can share
 * a single {@code StackWalker} object to traverse its own stack.
 * A permission check is performed when a {@code StackWalker} is created,
 * according to the options it requests.
 * No further permission check is done at stack walking time.
 *
 * @apiNote
 * Examples
 *
 * <p>1. To find the first caller filtering a known list of implementation class:
 * <pre>{@code
 *     StackWalker walker = StackWalker.getInstance(Option.RETAIN_CLASS_REFERENCE);
 *     Optional<Class<?>> callerClass = walker.walk(s ->
 *         s.map(StackFrame::getDeclaringClass)
 *          .filter(interestingClasses::contains)
 *          .findFirst());
 * }</pre>
 *
 * <p>2. To snapshot the top 10 stack frames of the current thread,
 * <pre>{@code
 *     List<StackFrame> stack = StackWalker.getInstance().walk(s ->
 *         s.limit(10).collect(Collectors.toList()));
 * }</pre>
 *
 * Unless otherwise noted, passing a {@code null} argument to a
 * constructor or method in this {@code StackWalker} class
 * will cause a {@link NullPointerException NullPointerException}
 * to be thrown.
 *
 * @since 9
 */
public final class StackWalker {

    /**
     * A {@code StackFrame} object represents a method invocation returned by
     * {@link StackWalker}.
     *
     * <p> The {@link #getDeclaringClass()} method may be unsupported as determined
     * by the {@linkplain Option stack walking options} of a {@linkplain
     * StackWalker stack walker}.
     *
     * @since 9
     * @jvms 2.6
     */
    public static interface StackFrame {

    /**
     * Stack walker option to configure the {@linkplain StackFrame stack frame}
     * information obtained by a {@code StackWalker}.
     *
     * @since 9
     */
    public enum Option {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\StrictMath.java
    /**
     * Returns the product of the arguments, throwing an exception if the result
     * overflows a {@code long}.
     *
     * @param x the first value
     * @param y the second value
     * @return the result
     * @throws ArithmeticException if the result overflows a long
     * @see Math#multiplyExact(long,int)
     * @since 9
     */
    public static long multiplyExact(long x, int y) {

    /**
     * Returns the exact mathematical product of the arguments.
     *
     * @param x the first value
     * @param y the second value
     * @return the result
     * @see Math#multiplyFull(int,int)
     * @since 9
     */
    public static long multiplyFull(int x, int y) {

    /**
     * Returns as a {@code long} the most significant 64 bits of the 128-bit
     * product of two 64-bit factors.
     *
     * @param x the first value
     * @param y the second value
     * @return the result
     * @see Math#multiplyHigh(long,long)
     * @since 9
     */
    public static long multiplyHigh(long x, long y) {

    /**
     * Returns the largest (closest to positive infinity)
     * {@code long} value that is less than or equal to the algebraic quotient.
     * There is one special case, if the dividend is the
     * {@linkplain Long#MIN_VALUE Long.MIN_VALUE} and the divisor is {@code -1},
     * then integer overflow occurs and
     * the result is equal to {@code Long.MIN_VALUE}.
     * <p>
     * See {@link Math#floorDiv(int, int) Math.floorDiv} for examples and
     * a comparison to the integer division {@code /} operator.
     *
     * @param x the dividend
     * @param y the divisor
     * @return the largest (closest to positive infinity)
     * {@code int} value that is less than or equal to the algebraic quotient.
     * @throws ArithmeticException if the divisor {@code y} is zero
     * @see Math#floorDiv(long, int)
     * @see Math#floor(double)
     * @since 9
     */
    public static long floorDiv(long x, int y) {

    /**
     * Returns the floor modulus of the {@code long} and {@int} arguments.
     * <p>
     * The floor modulus is {@code x - (floorDiv(x, y) * y)},
     * has the same sign as the divisor {@code y}, and
     * is in the range of {@code -abs(y) < r < +abs(y)}.
     *
     * <p>
     * The relationship between {@code floorDiv} and {@code floorMod} is such that:
     * <ul>
     *   <li>{@code floorDiv(x, y) * y + floorMod(x, y) == x}
     * </ul>
     * <p>
     * See {@link Math#floorMod(int, int) Math.floorMod} for examples and
     * a comparison to the {@code %} operator.
     *
     * @param x the dividend
     * @param y the divisor
     * @return the floor modulus {@code x - (floorDiv(x, y) * y)}
     * @throws ArithmeticException if the divisor {@code y} is zero
     * @see Math#floorMod(long, int)
     * @see StrictMath#floorDiv(long, int)
     * @since 9
     */
    public static int floorMod(long x, int y) {

    /**
     * Returns the fused multiply add of the three arguments; that is,
     * returns the exact product of the first two arguments summed
     * with the third argument and then rounded once to the nearest
     * {@code double}.
     *
     * The rounding is done using the {@linkplain
     * java.math.RoundingMode#HALF_EVEN round to nearest even
     * rounding mode}.
     *
     * In contrast, if {@code a * b + c} is evaluated as a regular
     * floating-point expression, two rounding errors are involved,
     * the first for the multiply operation, the second for the
     * addition operation.
     *
     * <p>Special cases:
     * <ul>
     * <li> If any argument is NaN, the result is NaN.
     *
     * <li> If one of the first two arguments is infinite and the
     * other is zero, the result is NaN.
     *
     * <li> If the exact product of the first two arguments is infinite
     * (in other words, at least one of the arguments is infinite and
     * the other is neither zero nor NaN) and the third argument is an
     * infinity of the opposite sign, the result is NaN.
     *
     * </ul>
     *
     * <p>Note that {@code fusedMac(a, 1.0, c)} returns the same
     * result as ({@code a + c}).  However,
     * {@code fusedMac(a, b, +0.0)} does <em>not</em> always return the
     * same result as ({@code a * b}) since
     * {@code fusedMac(-0.0, +0.0, +0.0)} is {@code +0.0} while
     * ({@code -0.0 * +0.0}) is {@code -0.0}; {@code fusedMac(a, b, -0.0)} is
     * equivalent to ({@code a * b}) however.
     *
     * @apiNote This method corresponds to the fusedMultiplyAdd
     * operation defined in IEEE 754-2008.
     *
     * @param a a value
     * @param b a value
     * @param c a value
     *
     * @return (<i>a</i>&nbsp;&times;&nbsp;<i>b</i>&nbsp;+&nbsp;<i>c</i>)
     * computed, as if with unlimited range and precision, and rounded
     * once to the nearest {@code double} value
     *
     * @since 9
     */
    public static double fma(double a, double b, double c) {

    /**
     * Returns the fused multiply add of the three arguments; that is,
     * returns the exact product of the first two arguments summed
     * with the third argument and then rounded once to the nearest
     * {@code float}.
     *
     * The rounding is done using the {@linkplain
     * java.math.RoundingMode#HALF_EVEN round to nearest even
     * rounding mode}.
     *
     * In contrast, if {@code a * b + c} is evaluated as a regular
     * floating-point expression, two rounding errors are involved,
     * the first for the multiply operation, the second for the
     * addition operation.
     *
     * <p>Special cases:
     * <ul>
     * <li> If any argument is NaN, the result is NaN.
     *
     * <li> If one of the first two arguments is infinite and the
     * other is zero, the result is NaN.
     *
     * <li> If the exact product of the first two arguments is infinite
     * (in other words, at least one of the arguments is infinite and
     * the other is neither zero nor NaN) and the third argument is an
     * infinity of the opposite sign, the result is NaN.
     *
     * </ul>
     *
     * <p>Note that {@code fma(a, 1.0f, c)} returns the same
     * result as ({@code a + c}).  However,
     * {@code fma(a, b, +0.0f)} does <em>not</em> always return the
     * same result as ({@code a * b}) since
     * {@code fma(-0.0f, +0.0f, +0.0f)} is {@code +0.0f} while
     * ({@code -0.0f * +0.0f}) is {@code -0.0f}; {@code fma(a, b, -0.0f)} is
     * equivalent to ({@code a * b}) however.
     *
     * @apiNote This method corresponds to the fusedMultiplyAdd
     * operation defined in IEEE 754-2008.
     *
     * @param a a value
     * @param b a value
     * @param c a value
     *
     * @return (<i>a</i>&nbsp;&times;&nbsp;<i>b</i>&nbsp;+&nbsp;<i>c</i>)
     * computed, as if with unlimited range and precision, and rounded
     * once to the nearest {@code float} value
     *
     * @since 9
     */
    public static float fma(float a, float b, float c) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\String.java
    /**
     * Returns a stream of {@code int} zero-extending the {@code char} values
     * from this sequence.  Any char which maps to a <a
     * href="{@docRoot}/java/lang/Character.html#unicode">surrogate code
     * point</a> is passed through uninterpreted.
     *
     * @return an IntStream of char values from this sequence
     * @since 9
     */
    @Override
    public IntStream chars() {

    /**
     * Returns a stream of code point values from this sequence.  Any surrogate
     * pairs encountered in the sequence are combined as if by {@linkplain
     * Character#toCodePoint Character.toCodePoint} and the result is passed
     * to the stream. Any other code units, including ordinary BMP characters,
     * unpaired surrogates, and undefined code units, are zero-extended to
     * {@code int} values which are then passed to the stream.
     *
     * @return an IntStream of Unicode code points from this sequence
     * @since 9
     */
    @Override
    public IntStream codePoints() {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\System.java
    /**
     * {@code System.Logger} instances log messages that will be
     * routed to the underlying logging framework the {@link System.LoggerFinder
     * LoggerFinder} uses.
     * <p>
     * {@code System.Logger} instances are typically obtained from
     * the {@link java.lang.System System} class, by calling
     * {@link java.lang.System#getLogger(java.lang.String) System.getLogger(loggerName)}
     * or {@link java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)
     * System.getLogger(loggerName, bundle)}.
     *
     * @see java.lang.System#getLogger(java.lang.String)
     * @see java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)
     * @see java.lang.System.LoggerFinder
     *
     * @since 9
     *
     */
    public interface Logger {

        /**
         * System {@linkplain Logger loggers} levels.
         * <p>
         * A level has a {@linkplain #getName() name} and {@linkplain
         * #getSeverity() severity}.
         * Level values are {@link #ALL}, {@link #TRACE}, {@link #DEBUG},
         * {@link #INFO}, {@link #WARNING}, {@link #ERROR}, {@link #OFF},
         * by order of increasing severity.
         * <br>
         * {@link #ALL} and {@link #OFF}
         * are simple markers with severities mapped respectively to
         * {@link java.lang.Integer#MIN_VALUE Integer.MIN_VALUE} and
         * {@link java.lang.Integer#MAX_VALUE Integer.MAX_VALUE}.
         * <p>
         * <b>Severity values and Mapping to {@code java.util.logging.Level}.</b>
         * <p>
         * {@linkplain System.Logger.Level System logger levels} are mapped to
         * {@linkplain java.util.logging.Level  java.util.logging levels}
         * of corresponding severity.
         * <br>The mapping is as follows:
         * <br><br>
         * <table border="1">
         * <caption>System.Logger Severity Level Mapping</caption>
         * <tr><td><b>System.Logger Levels</b></td>
         * <td>{@link Logger.Level#ALL ALL}</td>
         * <td>{@link Logger.Level#TRACE TRACE}</td>
         * <td>{@link Logger.Level#DEBUG DEBUG}</td>
         * <td>{@link Logger.Level#INFO INFO}</td>
         * <td>{@link Logger.Level#WARNING WARNING}</td>
         * <td>{@link Logger.Level#ERROR ERROR}</td>
         * <td>{@link Logger.Level#OFF OFF}</td>
         * </tr>
         * <tr><td><b>java.util.logging Levels</b></td>
         * <td>{@link java.util.logging.Level#ALL ALL}</td>
         * <td>{@link java.util.logging.Level#FINER FINER}</td>
         * <td>{@link java.util.logging.Level#FINE FINE}</td>
         * <td>{@link java.util.logging.Level#INFO INFO}</td>
         * <td>{@link java.util.logging.Level#WARNING WARNING}</td>
         * <td>{@link java.util.logging.Level#SEVERE SEVERE}</td>
         * <td>{@link java.util.logging.Level#OFF OFF}</td>
         * </tr>
         * </table>
         *
         * @since 9
         *
         * @see java.lang.System.LoggerFinder
         * @see java.lang.System.Logger
         */
        public enum Level {

    /**
     * The {@code LoggerFinder} service is responsible for creating, managing,
     * and configuring loggers to the underlying framework it uses.
     * <p>
     * A logger finder is a concrete implementation of this class that has a
     * zero-argument constructor and implements the abstract methods defined
     * by this class.
     * The loggers returned from a logger finder are capable of routing log
     * messages to the logging backend this provider supports.
     * A given invocation of the Java Runtime maintains a single
     * system-wide LoggerFinder instance that is loaded as follows:
     * <ul>
     *    <li>First it finds any custom {@code LoggerFinder} provider
     *        using the {@link java.util.ServiceLoader} facility with the
     *        {@linkplain ClassLoader#getSystemClassLoader() system class
     *        loader}.</li>
     *    <li>If no {@code LoggerFinder} provider is found, the system default
     *        {@code LoggerFinder} implementation will be used.</li>
     * </ul>
     * <p>
     * An application can replace the logging backend
     * <i>even when the java.logging module is present</i>, by simply providing
     * and declaring an implementation of the {@link LoggerFinder} service.
     * <p>
     * <b>Default Implementation</b>
     * <p>
     * The system default {@code LoggerFinder} implementation uses
     * {@code java.util.logging} as the backend framework when the
     * {@code java.logging} module is present.
     * It returns a {@linkplain System.Logger logger} instance
     * that will route log messages to a {@link java.util.logging.Logger
     * java.util.logging.Logger}. Otherwise, if {@code java.logging} is not
     * present, the default implementation will return a simple logger
     * instance that will route log messages of {@code INFO} level and above to
     * the console ({@code System.err}).
     * <p>
     * <b>Logging Configuration</b>
     * <p>
     * {@linkplain Logger Logger} instances obtained from the
     * {@code LoggerFinder} factory methods are not directly configurable by
     * the application. Configuration is the responsibility of the underlying
     * logging backend, and usually requires using APIs specific to that backend.
     * <p>For the default {@code LoggerFinder} implementation
     * using {@code java.util.logging} as its backend, refer to
     * {@link java.util.logging java.util.logging} for logging configuration.
     * For the default {@code LoggerFinder} implementation returning simple loggers
     * when the {@code java.logging} module is absent, the configuration
     * is implementation dependent.
     * <p>
     * Usually an application that uses a logging framework will log messages
     * through a logger facade defined (or supported) by that framework.
     * Applications that wish to use an external framework should log
     * through the facade associated with that framework.
     * <p>
     * A system class that needs to log messages will typically obtain
     * a {@link System.Logger} instance to route messages to the logging
     * framework selected by the application.
     * <p>
     * Libraries and classes that only need loggers to produce log messages
     * should not attempt to configure loggers by themselves, as that
     * would make them dependent from a specific implementation of the
     * {@code LoggerFinder} service.
     * <p>
     * In addition, when a security manager is present, loggers provided to
     * system classes should not be directly configurable through the logging
     * backend without requiring permissions.
     * <br>
     * It is the responsibility of the provider of
     * the concrete {@code LoggerFinder} implementation to ensure that
     * these loggers are not configured by untrusted code without proper
     * permission checks, as configuration performed on such loggers usually
     * affects all applications in the same Java Runtime.
     * <p>
     * <b>Message Levels and Mapping to backend levels</b>
     * <p>
     * A logger finder is responsible for mapping from a {@code
     * System.Logger.Level} to a level supported by the logging backend it uses.
     * <br>The default LoggerFinder using {@code java.util.logging} as the backend
     * maps {@code System.Logger} levels to
     * {@linkplain java.util.logging.Level java.util.logging} levels
     * of corresponding severity - as described in {@link Logger.Level
     * Logger.Level}.
     *
     * @see java.lang.System
     * @see java.lang.System.Logger
     *
     * @since 9
     */
    public static abstract class LoggerFinder {

    /**
     * Returns an instance of {@link Logger Logger} for the caller's
     * use.
     *
     * @implSpec
     * Instances returned by this method route messages to loggers
     * obtained by calling {@link LoggerFinder#getLogger(java.lang.String,
     * java.lang.reflect.Module) LoggerFinder.getLogger(name, module)}, where
     * {@code module} is the caller's module.
     *
     * @apiNote
     * This method may defer calling the {@link
     * LoggerFinder#getLogger(java.lang.String, java.lang.reflect.Module)
     * LoggerFinder.getLogger} method to create an actual logger supplied by
     * the logging backend, for instance, to allow loggers to be obtained during
     * the system initialization time.
     *
     * @param name the name of the logger.
     * @return an instance of {@link Logger} that can be used by the calling
     *         class.
     * @throws NullPointerException if {@code name} is {@code null}.
     *
     * @since 9
     */
    @CallerSensitive
    public static Logger getLogger(String name) {

    /**
     * Returns a localizable instance of {@link Logger
     * Logger} for the caller's use.
     * The returned logger will use the provided resource bundle for message
     * localization.
     *
     * @implSpec
     * The returned logger will perform message localization as specified
     * by {@link LoggerFinder#getLocalizedLogger(java.lang.String,
     * java.util.ResourceBundle, java.lang.reflect.Module)
     * LoggerFinder.getLocalizedLogger(name, bundle, module}, where
     * {@code module} is the caller's module.
     *
     * @apiNote
     * This method is intended to be used after the system is fully initialized.
     * This method may trigger the immediate loading and initialization
     * of the {@link LoggerFinder} service, which may cause issues if the
     * Java Runtime is not ready to initialize the concrete service
     * implementation yet.
     * System classes which may be loaded early in the boot sequence and
     * need to log localized messages should create a logger using
     * {@link #getLogger(java.lang.String)} and then use the log methods that
     * take a resource bundle as parameter.
     *
     * @param name    the name of the logger.
     * @param bundle  a resource bundle.
     * @return an instance of {@link Logger} which will use the provided
     * resource bundle for message localization.
     * @throws NullPointerException if {@code name} is {@code null} or
     *         {@code bundle} is {@code null}.
     *
     * @since 9
     */
    @CallerSensitive
    public static Logger getLogger(String name, ResourceBundle bundle) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\lang\Thread.java
    /**
     * Indicates that the caller is momentarily unable to progress, until the
     * occurrence of one or more actions on the part of other activities. By
     * invoking this method within each iteration of a spin-wait loop construct,
     * the calling thread indicates to the runtime that it is busy-waiting.
     * The runtime may take action to improve the performance of invoking
     * spin-wait loop constructions.
     * <p>
     * @apiNote
     * As an example consider a method in a class that spins in a loop until
     * some flag is set outside of that method. A call to the {@code onSpinWait}
     * method should be placed inside the spin loop.
     * <pre>{@code
     *     class EventHandler {
     *         volatile boolean eventNotificationNotReceived;
     *         void waitForEventAndHandleIt() {
     *             while ( eventNotificationNotReceived ) {
     *                 java.lang.Thread.onSpinWait();
     *             }
     *             readAndProcessEvent();
     *         }
     *
     *         void readAndProcessEvent() {
     *             // Read event from some source and process it
     *              . . .
     *         }
     *     }
     * }</pre>
     * <p>
     * The code above would remain correct even if the {@code onSpinWait}
     * method was not called at all. However on some architectures the Java
     * Virtual Machine may issue the processor instructions to address such
     * code patterns in a more beneficial way.
     * <p>
     * @since 9
     */
    @HotSpotIntrinsicCandidate
    public static void onSpinWait() {}

    /**
     * Initializes a Thread with the current AccessControlContext.
     * @see #init(ThreadGroup,Runnable,String,long,AccessControlContext,boolean)
     */
    private void init(ThreadGroup g, Runnable target, String name,
                      long stackSize) {

    /**
     * Allocates a new {@code Thread} object so that it has {@code target}
     * as its run object, has the specified {@code name} as its name,
     * belongs to the thread group referred to by {@code group}, has
     * the specified {@code stackSize}, and inherits initial values for
     * {@linkplain InheritableThreadLocal inheritable thread-local} variables
     * if {@code inheritThreadLocals} is {@code true}.
     *
     * <p> This constructor is identical to {@link
     * #Thread(ThreadGroup,Runnable,String,long)} with the added ability to
     * suppress, or not, the inheriting of initial values for inheritable
     * thread-local variables from the constructing thread. This allows for
     * finer grain control over inheritable thread-locals. Care must be taken
     * when passing a value of {@code false} for {@code inheritThreadLocals},
     * as it may lead to unexpected behavior if the new thread executes code
     * that expects a specific thread-local value to be inherited.
     *
     * <p> Specifying a value of {@code true} for the {@code inheritThreadLocals}
     * parameter will cause this constructor to behave exactly like the
     * {@code Thread(ThreadGroup, Runnable, String, long)} constructor.
     *
     * @param  group
     *         the thread group. If {@code null} and there is a security
     *         manager, the group is determined by {@linkplain
     *         SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}.
     *         If there is not a security manager or {@code
     *         SecurityManager.getThreadGroup()} returns {@code null}, the group
     *         is set to the current thread's thread group.
     *
     * @param  target
     *         the object whose {@code run} method is invoked when this thread
     *         is started. If {@code null}, this thread's run method is invoked.
     *
     * @param  name
     *         the name of the new thread
     *
     * @param  stackSize
     *         the desired stack size for the new thread, or zero to indicate
     *         that this parameter is to be ignored
     *
     * @param  inheritThreadLocals
     *         if {@code true}, inherit initial values for inheritable
     *         thread-locals from the constructing thread, otherwise no initial
     *         values are inherited
     *
     * @throws  SecurityException
     *          if the current thread cannot create a thread in the specified
     *          thread group
     *
     * @since 9
     */
    public Thread(ThreadGroup group, Runnable target, String name,
                  long stackSize, boolean inheritThreadLocals) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\math\BigInteger.java
    /**
     * Translates a byte sub-array containing the two's-complement binary
     * representation of a BigInteger into a BigInteger.  The sub-array is
     * specified via an offset into the array and a length.  The sub-array is
     * assumed to be in <i>big-endian</i> byte-order: the most significant
     * byte is the element at index {@code off}.  The {@code val} array is
     * assumed to be unchanged for the duration of the constructor call.
     *
     * An {@code IndexOutOfBoundsException} is thrown if the length of the array
     * {@code val} is non-zero and either {@code off} is negative, {@code len}
     * is negative, or {@code off+len} is greater than the length of
     * {@code val}.
     *
     * @param  val byte array containing a sub-array which is the big-endian
     *         two's-complement binary representation of a BigInteger.
     * @param  off the start offset of the binary representation.
     * @param  len the number of bytes to use.
     * @throws NumberFormatException {@code val} is zero bytes long.
     * @throws IndexOutOfBoundsException if the provided array offset and
     *         length would cause an index into the byte array to be
     *         negative or greater than or equal to the array length.
     * @since 9
     */
    public BigInteger(byte[] val, int off, int len) {

    /**
     * Translates the sign-magnitude representation of a BigInteger into a
     * BigInteger.  The sign is represented as an integer signum value: -1 for
     * negative, 0 for zero, or 1 for positive.  The magnitude is a sub-array of
     * a byte array in <i>big-endian</i> byte-order: the most significant byte
     * is the element at index {@code off}.  A zero value of the length
     * {@code len} is permissible, and will result in a BigInteger value of 0,
     * whether signum is -1, 0 or 1.  The {@code magnitude} array is assumed to
     * be unchanged for the duration of the constructor call.
     *
     * An {@code IndexOutOfBoundsException} is thrown if the length of the array
     * {@code magnitude} is non-zero and either {@code off} is negative,
     * {@code len} is negative, or {@code off+len} is greater than the length of
     * {@code magnitude}.
     *
     * @param  signum signum of the number (-1 for negative, 0 for zero, 1
     *         for positive).
     * @param  magnitude big-endian binary representation of the magnitude of
     *         the number.
     * @param  off the start offset of the binary representation.
     * @param  len the number of bytes to use.
     * @throws NumberFormatException {@code signum} is not one of the three
     *         legal values (-1, 0, and 1), or {@code signum} is 0 and
     *         {@code magnitude} contains one or more non-zero bytes.
     * @throws IndexOutOfBoundsException if the provided array offset and
     *         length would cause an index into the byte array to be
     *         negative or greater than or equal to the array length.
     * @since 9
     */
    public BigInteger(int signum, byte[] magnitude, int off, int len) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\math\MutableBigInteger.java
    /**
     * Calculate the integer square root {@code floor(sqrt(this))} where
     * {@code sqrt(.)} denotes the mathematical square root. The contents of
     * {@code this} are <b>not</b> changed. The value of {@code this} is assumed
     * to be non-negative.
     *
     * @implNote The implementation is based on the material in Henry S. Warren,
     * Jr., <i>Hacker's Delight (2nd ed.)</i> (Addison Wesley, 2013), 279-282.
     *
     * @throws ArithmeticException if the value returned by {@code bitLength()}
     * overflows the range of {@code int}.
     * @return the integer square root of {@code this}
     * @since 9
     */
    MutableBigInteger sqrt() {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\net\Authenticator.java
    /**
     * Ask this authenticator for a password.
     *
     * @param host The hostname of the site requesting authentication.
     * @param addr The InetAddress of the site requesting authorization,
     *             or null if not known.
     * @param port the port for the requested connection
     * @param protocol The protocol that's requesting the connection
     *          ({@link java.net.Authenticator#getRequestingProtocol()})
     * @param prompt A prompt string for the user
     * @param scheme The authentication scheme
     * @param url The requesting URL that caused the authentication
     * @param reqType The type (server or proxy) of the entity requesting
     *              authentication.
     *
     * @return The username/password, or null if one can't be gotten
     *
     * @since 9
     */
    public PasswordAuthentication
    requestPasswordAuthenticationInstance(String host,
                                          InetAddress addr,
                                          int port,
                                          String protocol,
                                          String prompt,
                                          String scheme,
                                          URL url,
                                          RequestorType reqType) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\net\DatagramSocket.java
    /**
     * Sets the value of a socket option.
     *
     * @param <T> The type of the socket option value
     * @param name The socket option
     * @param value The value of the socket option. A value of {@code null}
     *              may be valid for some options.
     *
     * @return this DatagramSocket
     *
     * @throws UnsupportedOperationException if the datagram socket
     *         does not support the option.
     *
     * @throws IllegalArgumentException if the value is not valid for
     *         the option.
     *
     * @throws IOException if an I/O error occurs, or if the socket is closed.
     *
     * @throws SecurityException if a security manager is set and if the socket
     *         option requires a security permission and if the caller does
     *         not have the required permission.
     *         {@link java.net.StandardSocketOptions StandardSocketOptions}
     *         do not require any security permission.
     *
     * @throws NullPointerException if name is {@code null}
     *
     * @since 9
     */
    public <T> DatagramSocket setOption(SocketOption<T> name, T value)
        throws IOException
    {

    /**
     * Returns the value of a socket option.
     *
     * @param <T> The type of the socket option value
     * @param name The socket option
     *
     * @return The value of the socket option.
     *
     * @throws UnsupportedOperationException if the datagram socket
     *         does not support the option.
     *
     * @throws IOException if an I/O error occurs, or if the socket is closed.
     *
     * @throws NullPointerException if name is {@code null}
     *
     * @throws SecurityException if a security manager is set and if the socket
     *         option requires a security permission and if the caller does
     *         not have the required permission.
     *         {@link java.net.StandardSocketOptions StandardSocketOptions}
     *         do not require any security permission.
     *
     * @since 9
     */
    public <T> T getOption(SocketOption<T> name) throws IOException {

    /**
     * Returns a set of the socket options supported by this socket.
     *
     * This method will continue to return the set of options even after
     * the socket has been closed.
     *
     * @return A set of the socket options supported by this socket. This set
     *        may be empty if the socket's DatagramSocketImpl cannot be created.
     *
     * @since 9
     */
    public Set<SocketOption<?>> supportedOptions() {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\net\DatagramSocketImpl.java
    /**
     * Called to set a socket option.
     *
     * @param <T> The type of the socket option value
     * @param name The socket option
     *
     * @param value The value of the socket option. A value of {@code null}
     *              may be valid for some options.
     *
     * @throws UnsupportedOperationException if the DatagramSocketImpl does not
     *         support the option
     *
     * @throws NullPointerException if name is {@code null}
     * @throws IOException if an I/O problem occurs while attempting to set the option
     * @since 9
     */
    protected <T> void setOption(SocketOption<T> name, T value) throws IOException {

    /**
     * Called to get a socket option.
     *
     * @return the socket option
     * @param <T> The type of the socket option value
     * @param name The socket option
     *
     * @throws UnsupportedOperationException if the DatagramSocketImpl does not
     *         support the option
     *
     * @throws NullPointerException if name is {@code null}
     * @throws IOException if an I/O problem occurs while attempting to set the option
     *
     * @since 9
     */
    @SuppressWarnings("unchecked")
    protected <T> T getOption(SocketOption<T> name) throws IOException {

    /**
     * Returns a set of SocketOptions supported by this impl
     * and by this impl's socket (DatagramSocket or MulticastSocket)
     *
     * @return a Set of SocketOptions
     *
     * @since 9
     */
    protected Set<SocketOption<?>> supportedOptions() {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\net\http\HttpClient.java
/**
 * A container for configuration information common to multiple {@link
 * HttpRequest}s. All requests are associated with, and created from a {@code
 * HttpClient}.
 *
 * <p> {@code HttpClient}s are immutable and created from a builder returned
 * from {@link HttpClient#create()}. Request builders that are associated with
 * an application created client, are created by calling {@link #request(URI) }.
 * It is also possible to create a request builder directly which is associated
 * with the <i>default</i> {@code HttpClient} by calling {@link
 * HttpRequest#create(URI)}.
 *
 * <p> The HTTP API functions asynchronously (using {@link
 * java.util.concurrent.CompletableFuture}) and also in a simple synchronous
 * mode, where all work may be done on the calling thread. In asynchronous mode,
 * work is done on the threads supplied by the client's {@link
 * java.util.concurrent.ExecutorService}.
 *
 * <p> <a name="defaultclient"></a> The <i>default</i> {@code HttpClient} is
 * used whenever a request is created without specifying a client explicitly
 * (by calling {@link HttpRequest#create(java.net.URI) HttpRequest.create}).
 * There is only one static instance of this {@code HttpClient}. A reference to
 * the default client can be obtained by calling {@link #getDefault() }. If a
 * security manager is set, then a permission is required for this.
 *
 * <p> See {@link HttpRequest} for examples of usage of this API.
 *
 * @since 9
 */
public abstract class HttpClient {

    /**
     * A builder of immutable {@link HttpClient}s. {@code HttpClient.Builder}s
     * are created by calling {@link HttpClient#create()}.
     *
     * <p> Each of the setter methods in this class modifies the state of the
     * builder and returns <i>this</i> (ie. the same instance). The methods are
     * not synchronized and should not be called from multiple threads without
     * external synchronization.
     *
     * <p> {@link #build() } returns a new {@code HttpClient} each time it is
     * called.
     *
     * @since 9
     */
    public abstract static class Builder {

    /**
     * The HTTP protocol version.
     *
     * @since 9
     */
    public static enum Version {

    /**
     * Defines automatic redirection policy. This is checked whenever a 3XX
     * response code is received. If redirection does not happen automatically
     * then the response is returned to the user, where it can be handled
     * manually.
     *
     * <p> {@code Redirect} policy is set via the {@link
     * HttpClient.Builder#followRedirects(HttpClient.Redirect)} method.
     *
     * @since 9
     */
    public static enum Redirect {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\net\http\HttpHeaders.java
/**
 * A read-only view of a set of received HTTP headers.
 *
 * @since 9
 */
public interface HttpHeaders {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\net\http\HttpRequest.java
/**
 * Represents one HTTP request which can be sent to a server. {@code
 * HttpRequest}s are built from {@code HttpRequest} {@link HttpRequest.Builder
 * builder}s. {@code HttpRequest} builders are obtained from a {@link HttpClient}
 * by calling {@link HttpClient#request(java.net.URI) HttpClient.request}, or
 * by calling {@link #create(java.net.URI) HttpRequest.create} which returns a
 * builder on the <a href="HttpClient.html#defaultclient">default</a> client.
 * A request's {@link java.net.URI}, headers and body can be set. Request bodies
 * are provided through a {@link BodyProcessor} object. Once all required
 * parameters have been set in the builder, one of the builder methods should be
 * called, which sets the request method and returns a {@code HttpRequest}.
 * These methods are {@link Builder#GET() GET}, {@link HttpRequest.Builder#POST()
 * POST} and {@link HttpRequest.Builder#PUT() PUT} which return a GET, POST or
 * PUT request respectively. Alternatively, {@link
 * HttpRequest.Builder#method(String) method} can be called to set an arbitrary
 * method type (and return a {@code HttpRequest}). Builders can also be copied
 * and modified multiple times in order to build multiple related requests that
 * differ in some parameters.
 *
 * <p> Two simple, example HTTP interactions are shown below:
 * <pre>
 * {@code
 *      // GET
 *      HttpResponse response = HttpRequest
 *          .create(new URI("http://www.foo.com"))
 *          .headers("Foo", "foovalue", "Bar", "barvalue")
 *          .GET()
 *          .response();
 *
 *      int statusCode = response.statusCode();
 *      String responseBody = response.body(asString());
 *
 *      // POST
 *      response = HttpRequest
 *          .create(new URI("http://www.foo.com"))
 *          .body(fromString("param1=foo,param2=bar"))
 *          .POST()
 *          .response();}
 * </pre>
 *
 * <p> The request is sent and the response obtained by calling one of the
 * following methods.
 * <ul><li>{@link #response() response} blocks until the entire request has been
 * sent and the response status code and headers have been received.</li>
 * <li>{@link #responseAsync() responseAsync} sends the request and receives the
 * response asynchronously. Returns immediately with a
 * {@link java.util.concurrent.CompletableFuture CompletableFuture}&lt;{@link
 * HttpResponse}&gt;.</li>
 * <li>{@link #multiResponseAsync(HttpResponse.MultiProcessor) multiResponseAsync}
 * sends the request asynchronously, expecting multiple responses. This
 * capability is of most relevance to HTTP/2 server push, but can be used for
 * single responses (HTTP/1.1 or HTTP/2) also.</li>
 * </ul>
 *
 * <p> Once a request has been sent, it is an error to try and send it again.
 *
 * <p> Once a {@code HttpResponse} is received, the headers and response code are
 * available. The body can then be received by calling one of the body methods
 * on {@code HttpResponse}.
 *
 * <p> See below for discussion of synchronous versus asynchronous usage.
 *
 * <p> <b>Request bodies</b>
 *
 * <p> Request bodies are sent using one of the request processor implementations
 * below provided in {@code HttpRequest}, or else a custom implementation can be
 * used.
 * <ul>
 * <li>{@link #fromByteArray(byte[]) } from byte array</li>
 * <li>{@link #fromByteArrays(java.util.Iterator) fromByteArrays(Iterator)}
 *      from an iterator of byte arrays</li>
 * <li>{@link #fromFile(java.nio.file.Path) fromFile(Path)} from the file located
 *     at the given Path</li>
 * <li>{@link #fromString(java.lang.String) fromString(String)} from a String </li>
 * <li>{@link #fromInputStream(java.io.InputStream) fromInputStream(InputStream)}
 *      request body from InputStream</li>
 * <li>{@link #noBody() } no request body is sent</li>
 * </ul>
 *
 * <p> <b>Response bodies</b>
 *
 * <p> Responses bodies are handled by the {@link HttpResponse.BodyProcessor}
 * {@code <T>} supplied to the {@link HttpResponse#body(HttpResponse.BodyProcessor)
 * HttpResponse.body} and {@link HttpResponse#bodyAsync(HttpResponse.BodyProcessor)
 * HttpResponse.bodyAsync} methods. Some implementations of {@code
 * HttpResponse.BodyProcessor} are provided in {@link HttpResponse}:
 * <ul>
 * <li>{@link HttpResponse#asByteArray() } stores the body in a byte array</li>
 * <li>{@link HttpResponse#asString()} stores the body as a String </li>
 * <li>{@link HttpResponse#asFile(java.nio.file.Path) } stores the body in a
 * named file</li>
 * <li>{@link HttpResponse#ignoreBody() } ignores any received response body</li>
 * </ul>
 *
 * <p> The output of a response processor is the response body, and its
 * parameterized type {@code T} determines the type of the body object returned
 * from {@code HttpResponse.body} and {@code HttpResponse.bodyAsync}. Therefore,
 * as an example, the second response processor in the list above has the type
 * {@code HttpResponse.BodyProcessor<String>} which means the type returned by
 * {@code HttpResponse.body()} is a String. Response processors can be defined
 * to return potentially any type as body.
 *
 * <p> <b>Multi responses</b>
 *
 * <p> With HTTP/2 it is possible for a server to return a main response and zero
 * or more additional responses (known as server pushes) to a client-initiated
 * request. These are handled using a special response processor called {@link
 * HttpResponse.MultiProcessor}.
 *
 * <p> <b>Blocking/asynchronous behavior and thread usage</b>
 *
 * <p> There are two styles of request sending: <i>synchronous</i> and
 * <i>asynchronous</i>. {@link #response() response} blocks the calling thread
 * until the request has been sent and the response received.
 *
 * <p> {@link #responseAsync() responseAsync} is asynchronous and returns
 * immediately with a {@link java.util.concurrent.CompletableFuture}&lt;{@link
 * HttpResponse}&gt; and when this object completes (in a background thread) the
 * response has been received.
 *
 * <p> {@link #multiResponseAsync(HttpResponse.MultiProcessor) multiResponseAsync}
 * is the variant for multi responses and is also asynchronous.
 *
 * <p> CompletableFutures can be combined in different ways to declare the
 * dependencies among several asynchronous tasks, while allowing for the maximum
 * level of parallelism to be utilized.
 *
 * <p> <b>Security checks</b>
 *
 * <p> If a security manager is present then security checks are performed by
 * the {@link #response() } and {@link #responseAsync() } methods. A {@link
 * java.net.URLPermission} or {@link java.net.SocketPermission} is required to
 * access any destination origin server and proxy server utilised. URLPermissions
 * should be preferred in policy files over SocketPermissions given the more
 * limited scope of URLPermission. Permission is always implicitly granted to a
 * system's default proxies. The URLPermission form used to access proxies uses
 * a method parameter of "CONNECT" (for all kinds of proxying) and a url string
 * of the form "socket://host:port" where host and port specify the proxy's
 * address.
 *
 * <p> <b>Examples</b>
 * <pre>
 *     import static java.net.http.HttpRequest.*;
 *     import static java.net.http.HttpResponse.*;
 *
 *     //Simple blocking
 *
 *     HttpResponse r1 = HttpRequest.create(new URI("http://www.foo.com/"))
 *                                  .GET()
 *                                 .response();
 *     int responseCode = r1.statusCode());
 *     String body = r1.body(asString());
 *
 *     HttpResponse r2 = HttpRequest.create(new URI("http://www.foo.com/"))
 *                                  .GET()
 *                                  .response();
 *
 *     System.out.println("Response was " + r1.statusCode());
 *     Path body1 = r2.body(asFile(Paths.get("/tmp/response.txt")));
 *     // Content stored in /tmp/response.txt
 *
 *     HttpResponse r3 = HttpRequest.create(new URI("http://www.foo.com/"))
 *                                  .body(fromString("param1=1, param2=2"))
 *                                  .POST()
 *                                  .response();
 *
 *     Void body2 = r3.body(ignoreBody()); // body is Void in this case
 * </pre>
 *
 * <p><b>Asynchronous Example</b>
 *
 * <p> All of the above examples will work asynchronously, if {@link
 * #responseAsync()} is used instead of {@link #response()} in which case the
 * returned object is a {@code CompletableFuture<HttpResponse>} instead of
 * {@code HttpResponse}. The following example shows how multiple requests can
 * be sent asynchronously. It also shows how dependent asynchronous operations
 * (receiving response, and receiving response body) can be chained easily using
 * one of the many methods in {@code CompletableFuture}.
 * <pre>
 * {@code
 *      // fetch a list of target URIs asynchronously and store them in Files.
 *
 *      List<URI> targets = ...
 *
 *      List<CompletableFuture<File>> futures = targets
 *          .stream()
 *          .map(target -> {
 *              return HttpRequest
 *                  .create(target)
 *                  .GET()
 *                  .responseAsync()
 *                  .thenCompose(response -> {
 *                      Path dest = Paths.get("base", target.getPath());
 *                      if (response.statusCode() == 200) {
 *                          return response.bodyAsync(asFile(dest));
 *                      } else {
 *                          return CompletableFuture.completedFuture(dest);
 *                      }
 *                  })
 *                  // convert Path -> File
 *                  .thenApply((Path dest) -> {
 *                      return dest.toFile();
 *                  });
 *              })
 *          .collect(Collectors.toList());
 *
 *      // all async operations waited for here
 *
 *      CompletableFuture.allOf(futures.toArray(new CompletableFuture<?>[0]))
 *          .join();
 *
 *      // all elements of futures have completed and can be examined.
 *      // Use File.exists() to check whether file was successfully downloaded
 * }
 * </pre>
 *
 * @since 9
 */
public abstract class HttpRequest {

    /**
     * A builder of {@link HttpRequest}s. {@code HttpRequest.Builder}s are
     * created by calling {@link HttpRequest#create(URI)} or {@link
     * HttpClient#request(URI)}.
     *
     * <p> Each of the setter methods in this class modifies the state of the
     * builder and returns <i>this</i> (ie. the same instance). The methods are
     * not synchronized and should not be called from multiple threads without
     * external synchronization.
     *
     * <p> The build methods return a new {@code HttpRequest} each time they are
     * called.
     *
     * @since 9
     */
    public abstract static class Builder {

    /**
     * A request processor which obtains the request body from some source.
     * Implementations of this interface are provided which allow request bodies
     * to be supplied from standard types, such as {@code String, byte[], File,
     * InputStream}. Other implementations can be provided.
     *
     * <p> The methods of this interface may be called from multiple threads,
     * but only one method is invoked at a time, and behaves as if called from
     * one thread.
     *
     * <p> See {@link HttpRequest} for implementations that take request bodies
     * from {@code byte arrays, Strings, Paths} etc.
     *
     * @since 9
     */
    public interface BodyProcessor {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\net\http\HttpResponse.java
/**
 * Represents a response to a {@link HttpRequest}. A {@code HttpResponse} is
 * available when the response status code and headers have been received, but
 * before the response body is received.
 *
 * <p> Methods are provided in this class for accessing the response headers,
 * and status code immediately and also methods for retrieving the response body.
 * Static methods are provided which implement {@link BodyProcessor} for
 * standard body types such as {@code String, byte arrays, files}.
 *
 * <p> The {@link #body(BodyProcessor) body} or {@link #bodyAsync(BodyProcessor)
 * bodyAsync} which retrieve any response body must be called to ensure that the
 * TCP connection can be re-used subsequently, and any response trailers
 * accessed, if they exist, unless it is known that no response body was received.
 *
 * @since 9
 */
public abstract class HttpResponse {

    /**
     * A processor for response bodies, which determines the type of the
     * response body returned from {@link HttpResponse}. Response processors can
     * either return an object that represents the body itself (after it has
     * been read) or else an object that is used to read the body (such as an
     * {@code InputStream}). The parameterized type {@code <T>} is the type of
     * the returned body object from
     * {@link HttpResponse#body(BodyProcessor) HttpResponse.body} and
     * (indirectly) from {@link HttpResponse#bodyAsync(BodyProcessor)
     * HttpResponse.bodyAsync}.
     *
     * <p> Implementations of this interface are provided in {@link HttpResponse}
     * which write responses to {@code String, byte[], File, Consumer<byte[]>}.
     * Custom implementations can also be used.
     *
     * <p> The methods of this interface may be called from multiple threads,
     * but only one method is invoked at a time, and behaves as if called from
     * one thread.
     *
     * @param <T> the type of the response body
     *
     * @since 9
     */
    public interface BodyProcessor<T> {

    /**
     * A response processor for a HTTP/2 multi response. A multi response
     * comprises a main response, and zero or more additional responses. Each
     * additional response is sent by the server in response to requests that
     * the server also generates. Additional responses are typically resources
     * that the server guesses the client will need which are related to the
     * initial request.
     *
     * <p>The server generated requests are also known as <i>push promises</i>.
     * The server is permitted to send any number of these requests up to the
     * point where the main response is fully received. Therefore, after
     * completion of the main response body, the final number of additional
     * responses is known. Additional responses may be cancelled, but given that
     * the server does not wait for any acknowledgment before sending the
     * response, this must be done quickly to avoid unnecessary data transmission.
     *
     * <p> {@code MultiProcessor}s are parameterised with a type {@code T} which
     * represents some meaningful aggregate of the responses received. This
     * would typically be a Collection of response or response body objects. One
     * example implementation can be found at {@link
     * HttpResponse#multiFile(java.nio.file.Path)}.
     *
     * @param <T> a type representing the aggregated results
     *
     * @since 9
     */
    public interface MultiProcessor<T> {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\net\http\package-info.java
/**
 * <h2>High level HTTP and WebSocket API</h2>
 * This provides a high-level client interfaces to HTTP (versions 1.1 and 2)
 * and WebSocket. Synchronous and asynchronous (via {@link
 * java.util.concurrent.CompletableFuture}) modes are provided for HTTP.
 * WebSocket works in asynchronous mode only. The main types defined are:
 * <ul>
 *    <li>{@link java.net.http.HttpClient}</li>
 *    <li>{@link java.net.http.HttpRequest}</li>
 *    <li>{@link java.net.http.HttpResponse}</li>
 *    <li>{@link java.net.http.WebSocket}</li>
 * </ul>
 *
 * @since 9
 */
package java.net.http;

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\net\http\WebSocket.java
/**
 * A WebSocket client conforming to RFC&nbsp;6455.
 *
 * <p> A {@code WebSocket} provides full-duplex communication over a TCP
 * connection.
 *
 * <p> To create a {@code WebSocket} use a {@linkplain #newBuilder(URI, Listener)
 * builder}. Once a {@code WebSocket} is obtained, it's ready to send and
 * receive messages. When the {@code WebSocket} is no longer
 * needed it must be closed: a Close message must both be {@linkplain
 * #sendClose() sent} and {@linkplain Listener#onClose(WebSocket, Optional,
 * String) received}. Otherwise, invoke {@link #abort() abort} to close abruptly.
 *
 * <p> Once closed the {@code WebSocket} remains closed and cannot be reopened.
 *
 * <p> Messages of type {@code X} are sent through the {@code WebSocket.sendX}
 * methods and received through {@link WebSocket.Listener}{@code .onX} methods
 * asynchronously. Each of the methods returns a {@link CompletionStage} which
 * completes when the operation has completed.
 *
 * <p> Messages are received only if {@linkplain #request(long) requested}.
 *
 * <p> One outstanding send operation is permitted: if another send operation is
 * initiated before the previous one has completed, an {@link
 * IllegalStateException IllegalStateException} will be thrown. When sending, a
 * message should not be modified until the returned {@code CompletableFuture}
 * completes (either normally or exceptionally).
 *
 * <p> Messages can be sent and received as a whole or in parts. A whole message
 * is a sequence of one or more messages in which the last message is marked
 * when it is sent or received.
 *
 * <p> If the message is contained in a {@link ByteBuffer}, bytes are considered
 * arranged from the {@code buffer}'s {@link ByteBuffer#position() position} to
 * the {@code buffer}'s {@link ByteBuffer#limit() limit}.
 *
 * <p> Unless otherwise noted, passing a {@code null} argument to a constructor
 * or method of this type will cause a {@link NullPointerException
 * NullPointerException} to be thrown.
 *
 * @implNote The default implementation's methods do not block before returning
 * a {@code CompletableFuture}.
 *
 * @since 9
 */
public interface WebSocket {

    /**
     * A builder for creating {@code WebSocket} instances.
     *
     * <p> To build a {@code WebSocket}, instantiate a builder, configure it
     * as required by calling intermediate methods (the ones that return the
     * builder itself), then finally call {@link #buildAsync()} to get a {@link
     * CompletableFuture} with resulting {@code WebSocket}.
     *
     * <p> If an intermediate method has not been called, an appropriate
     * default value (or behavior) will be used. Unless otherwise noted, a
     * repeated call to an intermediate method overwrites the previous value (or
     * overrides the previous behaviour), if no exception is thrown.
     *
     * <p> Instances of {@code Builder} may not be safe for use by multiple
     * threads.
     *
     * @since 9
     */
    interface Builder {

    /**
     * A listener for events and messages on a {@code WebSocket}.
     *
     * <p> Each method below corresponds to a type of event.
     * <ul>
     * <li> {@link #onOpen onOpen} <br>
     * This method is always the first to be invoked.
     * <li> {@link #onText(WebSocket, CharSequence, WebSocket.MessagePart)
     * onText}, {@link #onBinary(WebSocket, ByteBuffer, WebSocket.MessagePart)
     * onBinary}, {@link #onPing(WebSocket, ByteBuffer) onPing} and {@link
     * #onPong(WebSocket, ByteBuffer) onPong} <br>
     * These methods are invoked zero or more times after {@code onOpen}.
     * <li> {@link #onClose(WebSocket, Optional, String) onClose}, {@link
     * #onError(WebSocket, Throwable) onError} <br>
     * Only one of these methods is invoked, and that method is invoked last and
     * at most once.
     * </ul>
     *
     * <pre><code>
     *     onOpen (onText|onBinary|onPing|onPong)* (onClose|onError)?
     * </code></pre>
     *
     * <p> Messages received by the {@code Listener} conform to the WebSocket
     * Protocol, otherwise {@code onError} with a {@link ProtocolException} is
     * invoked.
     *
     * <p> If a whole message is received, then the corresponding method
     * ({@code onText} or {@code onBinary}) will be invoked with {@link
     * WebSocket.MessagePart#WHOLE WHOLE} marker. Otherwise the method will be
     * invoked with {@link WebSocket.MessagePart#FIRST FIRST}, zero or more
     * times with {@link WebSocket.MessagePart#FIRST PART} and, finally, with
     * {@link WebSocket.MessagePart#LAST LAST} markers.
     *
     * <pre><code>
     *     WHOLE|(FIRST PART* LAST)
     * </code></pre>
     *
     * <p> All methods are invoked in a sequential (and
     * <a href="../../../java/util/concurrent/package-summary.html#MemoryVisibility">
     * happens-before</a>) order, one after another, possibly by different
     * threads. If any of the methods above throws an exception, {@code onError}
     * is then invoked with that exception. Exceptions thrown from {@code
     * onError} or {@code onClose} are ignored.
     *
     * <p> When the method returns, the message is deemed received. After this
     * another messages may be received.
     *
     * <p> These invocations begin asynchronous processing which might not end
     * with the invocation. To provide coordination, methods of {@code
     * Listener} return a {@link CompletionStage CompletionStage}. The {@code
     * CompletionStage} signals the {@code WebSocket} that the
     * processing of a message has ended. For
     * convenience, methods may return {@code null}, which means
     * the same as returning an already completed {@code CompletionStage}. If
     * the returned {@code CompletionStage} completes exceptionally, then {@link
     * #onError(WebSocket, Throwable) onError} will be invoked with the
     * exception.
     *
     * <p> Control of the message passes to the {@code Listener} with the
     * invocation of the method. Control of the message returns to the {@code
     * WebSocket} at the earliest of, either returning {@code null} from the
     * method, or the completion of the {@code CompletionStage} returned from
     * the method. The {@code WebSocket} does not access the message while it's
     * not in its control. The {@code Listener} must not access the message
     * after its control has been returned to the {@code WebSocket}.
     *
     * <p> It is the responsibility of the listener to make additional
     * {@linkplain WebSocket#request(long) message requests}, when ready, so
     * that messages are received eventually.
     *
     * <p> Methods above are never invoked with {@code null}s as their
     * arguments.
     *
     * @since 9
     */
    interface Listener {

    /**
     * A marker used by {@link WebSocket.Listener} in cases where a partial
     * message may be received.
     *
     * @since 9
     */
    enum MessagePart {

    /**
     * A {@code WebSocket} close status code.
     *
     * <p> Some codes <a href="https://tools.ietf.org/html/rfc6455#section-7.4">
     * specified</a> in the WebSocket Protocol are defined as named constants
     * here. Others can be {@linkplain #of(int) retrieved on demand}.
     *
     * <p> This is a
     * <a href="../../lang/doc-files/ValueBased.html">value-based</a> class;
     * use of identity-sensitive operations (including reference equality
     * ({@code ==}), identity hash code, or synchronization) on instances of
     * {@code CloseCode} may have unpredictable results and should be avoided.
     *
     * @since 9
     */
    final class CloseCode {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\net\http\WebSocketHandshakeException.java
/**
 * An exception used to signal the opening handshake failed.
 *
 * @since 9
 */
public final class WebSocketHandshakeException extends Exception {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\net\InetAddress.java
    /**
     * NameService provides host and address lookup service
     *
     * @since 9
     */
    private interface NameService {

    /**
     * The default NameService implementation, which delegates to the underlying
     * OS network libraries to resolve host address mappings.
     *
     * @since 9
     */
    private static final class PlatformNameService implements NameService {

    /**
     * The HostsFileNameService provides host address mapping
     * by reading the entries in a hosts file, which is specified by
     * {@code jdk.net.hosts.file} system property
     *
     * <p>The file format is that which corresponds with the /etc/hosts file
     * IP Address host alias list.
     *
     * <p>When the file lookup is enabled it replaces the default NameService
     * implementation
     *
     * @since 9
     */
    private static final class HostsFileNameService implements NameService {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\net\NetworkInterface.java
    /**
     * Get a Stream of all or a subset of the InetAddresses bound to this
     * network interface.
     * <p>
     * If there is a security manager, its {@code checkConnect}
     * method is called for each InetAddress. Only InetAddresses where
     * the {@code checkConnect} doesn't throw a SecurityException will be
     * returned in the Stream. However, if the caller has the
     * {@link NetPermission}("getNetworkInformation") permission, then all
     * InetAddresses are returned.
     *
     * @return a Stream object with all or a subset of the InetAddresses
     * bound to this network interface
     * @since 9
     */
    public Stream<InetAddress> inetAddresses() {

    /**
     * Get a Stream of all subinterfaces (also known as virtual
     * interfaces) attached to this network interface.
     *
     * @return a Stream object with all of the subinterfaces
     * of this network interface
     * @since 9
     */
    public Stream<NetworkInterface> subInterfaces() {

    /**
     * Returns a {@code Stream} of all the interfaces on this machine.  The
     * {@code Stream} contains at least one interface, possibly representing a
     * loopback interface that only supports communication between entities on
     * this machine.
     *
     * @apiNote this method can be used in combination with
     * {@link #inetAddresses()}} to obtain a stream of all IP addresses for
     * this node, for example:
     * <pre> {@code
     * Stream<InetAddress> addrs = NetworkInterface.networkInterfaces()
     *     .flatMap(NetworkInterface::inetAddresses);
     * }</pre>
     *
     * @return a Stream of NetworkInterfaces found on this machine
     * @exception  SocketException  if an I/O error occurs.
     * @since 9
     */
    public static Stream<NetworkInterface> networkInterfaces()
        throws SocketException {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\net\ProxySelector.java
    /**
     * Returns a ProxySelector which uses the given proxy address for all HTTP
     * and HTTPS requests. If proxy is {@code null} then proxying is disabled.
     *
     * @param proxyAddress
     *        The address of the proxy
     *
     * @return a ProxySelector
     *
     * @since 9
     */
    public static ProxySelector of(InetSocketAddress proxyAddress) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\net\ServerSocket.java
    /**
     * Sets the value of a socket option.
     *
     * @param <T> The type of the socket option value
     * @param name The socket option
     * @param value The value of the socket option. A value of {@code null}
     *              may be valid for some options.
     * @return this ServerSocket
     *
     * @throws UnsupportedOperationException if the server socket does not
     *         support the option.
     *
     * @throws IllegalArgumentException if the value is not valid for
     *         the option.
     *
     * @throws IOException if an I/O error occurs, or if the socket is closed.
     *
     * @throws NullPointerException if name is {@code null}
     *
     * @throws SecurityException if a security manager is set and if the socket
     *         option requires a security permission and if the caller does
     *         not have the required permission.
     *         {@link java.net.StandardSocketOptions StandardSocketOptions}
     *         do not require any security permission.
     *
     * @since 9
     */
    public <T> ServerSocket setOption(SocketOption<T> name, T value)
        throws IOException
    {

    /**
     * Returns the value of a socket option.
     *
     * @param <T> The type of the socket option value
     * @param name The socket option
     *
     * @return The value of the socket option.
     *
     * @throws UnsupportedOperationException if the server socket does not
     *         support the option.
     *
     * @throws IOException if an I/O error occurs, or if the socket is closed.
     *
     * @throws NullPointerException if name is {@code null}
     *
     * @throws SecurityException if a security manager is set and if the socket
     *         option requires a security permission and if the caller does
     *         not have the required permission.
     *         {@link java.net.StandardSocketOptions StandardSocketOptions}
     *         do not require any security permission.
     *
     * @since 9
     */
    public <T> T getOption(SocketOption<T> name) throws IOException {

    /**
     * Returns a set of the socket options supported by this server socket.
     *
     * This method will continue to return the set of options even after
     * the socket has been closed.
     *
     * @return A set of the socket options supported by this socket. This set
     *         may be empty if the socket's SocketImpl cannot be created.
     *
     * @since 9
     */
    public Set<SocketOption<?>> supportedOptions() {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\net\Socket.java
    /**
     * Sets the value of a socket option.
     *
     * @param <T> The type of the socket option value
     * @param name The socket option
     * @param value The value of the socket option. A value of {@code null}
     *              may be valid for some options.
     * @return this Socket
     *
     * @throws UnsupportedOperationException if the socket does not support
     *         the option.
     *
     * @throws IllegalArgumentException if the value is not valid for
     *         the option.
     *
     * @throws IOException if an I/O error occurs, or if the socket is closed.
     *
     * @throws NullPointerException if name is {@code null}
     *
     * @throws SecurityException if a security manager is set and if the socket
     *         option requires a security permission and if the caller does
     *         not have the required permission.
     *         {@link java.net.StandardSocketOptions StandardSocketOptions}
     *         do not require any security permission.
     *
     * @since 9
     */
    public <T> Socket setOption(SocketOption<T> name, T value) throws IOException {

    /**
     * Returns the value of a socket option.
     *
     * @param <T> The type of the socket option value
     * @param name The socket option
     *
     * @return The value of the socket option.
     *
     * @throws UnsupportedOperationException if the socket does not support
     *         the option.
     *
     * @throws IOException if an I/O error occurs, or if the socket is closed.
     *
     * @throws NullPointerException if name is {@code null}
     *
     * @throws SecurityException if a security manager is set and if the socket
     *         option requires a security permission and if the caller does
     *         not have the required permission.
     *         {@link java.net.StandardSocketOptions StandardSocketOptions}
     *         do not require any security permission.
     *
     * @since 9
     */
    @SuppressWarnings("unchecked")
    public <T> T getOption(SocketOption<T> name) throws IOException {

    /**
     * Returns a set of the socket options supported by this socket.
     *
     * This method will continue to return the set of options even after
     * the socket has been closed.
     *
     * @return A set of the socket options supported by this socket. This set
     *         may be empty if the socket's SocketImpl cannot be created.
     *
     * @since 9
     */
    public Set<SocketOption<?>> supportedOptions() {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\net\SocketImpl.java
    /**
     * Called to set a socket option.
     *
     * @param <T> The type of the socket option value
     * @param name The socket option
     *
     * @param value The value of the socket option. A value of {@code null}
     *              may be valid for some options.
     *
     * @throws UnsupportedOperationException if the SocketImpl does not
     *         support the option
     *
     * @throws IOException if an I/O error occurs, or if the socket is closed.
     *
     * @since 9
     */
    protected <T> void setOption(SocketOption<T> name, T value) throws IOException {

    /**
     * Called to get a socket option.
     *
     * @param <T> The type of the socket option value
     * @param name The socket option
     *
     * @return the value of the named option
     *
     * @throws UnsupportedOperationException if the SocketImpl does not
     *         support the option.
     *
     * @throws IOException if an I/O error occurs, or if the socket is closed.
     *
     * @since 9
     */
    @SuppressWarnings("unchecked")
    protected <T> T getOption(SocketOption<T> name) throws IOException {

    /**
     * Returns a set of SocketOptions supported by this impl
     * and by this impl's socket (Socket or ServerSocket)
     *
     * @return a Set of SocketOptions
     *
     * @since 9
     */
    protected Set<SocketOption<?>> supportedOptions() {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\net\SocketOptions.java
    /** Sets SO_REUSEPORT for a socket. This option enables and disables
     *  the ability to have multiple sockets listen to the same address
     *  and port.
     * <P>
     * Valid for: SocketImpl, DatagramSocketImpl
     *
     * @since 9
     * @see StandardSocketOptions#SO_REUSEPORT
     */
    @Native public static final int SO_REUSEPORT = 0x0E;

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\net\spi\package-info.java
/**
 * Service-provider classes for the {@link java.net} package.
 *
 * <p> Only developers who are defining new URL stream handler providers
 * should need to make direct use of this package.
 *
 * @since 9
 */

package java.net.spi;

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\net\spi\URLStreamHandlerProvider.java
/**
 * URL stream handler service-provider class.
 *
 *<p> A URL stream handler provider is a concrete subclass of this class that
 * has a zero-argument constructor. URL stream handler providers may be
 * installed in an instance of the Java platform by adding them to the
 * application class path.
 *
 * <p> A URL stream handler provider identifies itself with a
 * provider-configuration file named java.net.spi.URLStreamHandlerProvider in
 * the resource directory META-INF/services. The file should contain a list of
 * fully-qualified concrete URL stream handler provider class names, one per
 * line.
 *
 * <p> URL stream handler providers are located at runtime, as specified in the
 * {@linkplain java.net.URL#URL(String,String,int,String) URL constructor}.
 *
 * @since 9
 */
public abstract class URLStreamHandlerProvider
    implements URLStreamHandlerFactory
{

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\net\StandardSocketOptions.java
    /**
     * Re-use port.
     *
     * <p> The value of this socket option is a {@code Boolean} that represents
     * whether the option is enabled or disabled. The exact semantics of this
     * socket option are socket type and system dependent.
     *
     * <p> In the case of stream-oriented sockets, this socket option usually allows
     * multiple listening sockets to be bound to both same address
     * and same port.
     *
     * <p> For datagram-oriented sockets the socket option usually allows
     * multiple UDP sockets to be bound to the same address and port.
     *
     * <p> An implementation allows this socket option to be set before the
     * socket is bound or connected. Changing the value of this socket option
     * after the socket is bound has no effect.
     *
     * @since 9
     */
    public static final SocketOption<Boolean> SO_REUSEPORT =
        new StdSocketOption<Boolean>("SO_REUSEPORT", Boolean.class);

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\nio\Buffer.java
    /**
     * Creates a new buffer whose content is a shared subsequence of
     * this buffer's content.
     *
     * <p> The content of the new buffer will start at this buffer's current
     * position.  Changes to this buffer's content will be visible in the new
     * buffer, and vice versa; the two buffers' position, limit, and mark
     * values will be independent.
     *
     * <p> The new buffer's position will be zero, its capacity and its limit
     * will be the number of elements remaining in this buffer, its mark will be
     * undefined. The new buffer will be direct if, and only if, this buffer is
     * direct, and it will be read-only if, and only if, this buffer is
     * read-only.  </p>
     *
     * @return  The new buffer
     *
     * @since 9
     */
    public abstract Buffer slice();

    /**
     * Creates a new buffer that shares this buffer's content.
     *
     * <p> The content of the new buffer will be that of this buffer.  Changes
     * to this buffer's content will be visible in the new buffer, and vice
     * versa; the two buffers' position, limit, and mark values will be
     * independent.
     *
     * <p> The new buffer's capacity, limit, position and mark values will be
     * identical to those of this buffer. The new buffer will be direct if, and
     * only if, this buffer is direct, and it will be read-only if, and only if,
     * this buffer is read-only.  </p>
     *
     * @return  The new buffer
     *
     * @since 9
     */
    public abstract Buffer duplicate();

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\nio\ByteBuffer.java
    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public



    ByteBuffer position(int newPosition) {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public



    ByteBuffer limit(int newLimit) {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public 



    ByteBuffer mark() {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public 



    ByteBuffer reset() {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public 



    ByteBuffer clear() {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public 



    ByteBuffer flip() {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public 



    ByteBuffer rewind() {

    /**
     * Returns the memory address, pointing to the byte at the given index,
     * modulus the given unit size.
     *
     * <p> A return value greater than zero indicates the address of the byte at
     * the index is misaligned for the unit size, and the value's quantity
     * indicates how much the index should be rounded up or down to locate a
     * byte at an aligned address.  Otherwise, a value of {@code 0} indicates
     * that the address of the byte at the index is aligned for the unit size.
     *
     * @apiNote
     * This method may be utilized to determine if unit size bytes from an
     * index can be accessed atomically, if supported by the native platform.
     *
     * @implNote
     * This implementation throws {@code UnsupportedOperationException} for
     * non-direct buffers when the given unit size is greater then {@code 8}.
     *
     * @param  index
     *         The index to query for alignment offset, must be non-negative, no
     *         upper bounds check is performed
     *
     * @param  unitSize
     *         The unit size in bytes, must be a power of {@code 2}
     *
     * @return  The indexed byte's memory address modulus the unit size
     *
     * @throws IllegalArgumentException
     *         If the index is negative or the unit size is not a power of
     *         {@code 2}
     *
     * @throws UnsupportedOperationException
     *         If the native platform does not guarantee stable alignment offset
     *         values for the given unit size when managing the memory regions
     *         of buffers of the same kind as this buffer (direct or
     *         non-direct).  For example, if garbage collection would result
     *         in the moving of a memory region covered by a non-direct buffer
     *         from one location to another and both locations have different
     *         alignment characteristics.
     *
     * @see #alignedSlice(int)
     * @since 9
     */
    public final int alignmentOffset(int index, int unitSize) {

    /**
     * Creates a new byte buffer whose content is a shared and aligned
     * subsequence of this buffer's content.
     *
     * <p> The content of the new buffer will start at this buffer's current
     * position rounded up to the index of the nearest aligned byte for the
     * given unit size, and end at this buffer's limit rounded down to the index
     * of the nearest aligned byte for the given unit size.
     * If rounding results in out-of-bound values then the new buffer's capacity
     * and limit will be zero.  If rounding is within bounds the following
     * expressions will be true for a new buffer {@code nb} and unit size
     * {@code unitSize}:
     * <pre>{@code
     * nb.alignmentOffset(0, unitSize) == 0
     * nb.alignmentOffset(nb.limit(), unitSize) == 0
     * }</pre>
     *
     * <p> Changes to this buffer's content will be visible in the new
     * buffer, and vice versa; the two buffers' position, limit, and mark
     * values will be independent.
     *
     * <p> The new buffer's position will be zero, its capacity and its limit
     * will be the number of bytes remaining in this buffer or fewer subject to
     * alignment, its mark will be undefined, and its byte order will be
     * {@link ByteOrder#BIG_ENDIAN BIG_ENDIAN}.
     *
     * The new buffer will be direct if, and only if, this buffer is direct, and
     * it will be read-only if, and only if, this buffer is read-only.  </p>
     *
     * @apiNote
     * This method may be utilized to create a new buffer where unit size bytes
     * from index, that is a multiple of the unit size, may be accessed
     * atomically, if supported by the native platform.
     *
     * @implNote
     * This implementation throws {@code UnsupportedOperationException} for
     * non-direct buffers when the given unit size is greater then {@code 8}.
     *
     * @param  unitSize
     *         The unit size in bytes, must be a power of {@code 2}
     *
     * @return  The new byte buffer
     *
     * @throws IllegalArgumentException
     *         If the unit size not a power of {@code 2}
     *
     * @throws UnsupportedOperationException
     *         If the native platform does not guarantee stable aligned slices
     *         for the given unit size when managing the memory regions
     *         of buffers of the same kind as this buffer (direct or
     *         non-direct).  For example, if garbage collection would result
     *         in the moving of a memory region covered by a non-direct buffer
     *         from one location to another and both locations have different
     *         alignment characteristics.
     *
     * @see #alignmentOffset(int, int)
     * @see #slice()
     * @since 9
     */
    public final ByteBuffer alignedSlice(int unitSize) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\nio\CharBuffer.java
    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public

    final

    CharBuffer position(int newPosition) {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public

    final

    CharBuffer limit(int newLimit) {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public 

    final

    CharBuffer mark() {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public 

    final

    CharBuffer reset() {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public 

    final

    CharBuffer clear() {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public 

    final

    CharBuffer flip() {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public 

    final

    CharBuffer rewind() {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\nio\DoubleBuffer.java
    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public

    final

    DoubleBuffer position(int newPosition) {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public

    final

    DoubleBuffer limit(int newLimit) {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public 

    final

    DoubleBuffer mark() {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public 

    final

    DoubleBuffer reset() {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public 

    final

    DoubleBuffer clear() {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public 

    final

    DoubleBuffer flip() {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public 

    final

    DoubleBuffer rewind() {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\nio\FloatBuffer.java
    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public

    final

    FloatBuffer position(int newPosition) {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public

    final

    FloatBuffer limit(int newLimit) {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public 

    final

    FloatBuffer mark() {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public 

    final

    FloatBuffer reset() {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public 

    final

    FloatBuffer clear() {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public 

    final

    FloatBuffer flip() {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public 

    final

    FloatBuffer rewind() {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\nio\IntBuffer.java
    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public

    final

    IntBuffer position(int newPosition) {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public

    final

    IntBuffer limit(int newLimit) {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public 

    final

    IntBuffer mark() {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public 

    final

    IntBuffer reset() {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public 

    final

    IntBuffer clear() {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public 

    final

    IntBuffer flip() {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public 

    final

    IntBuffer rewind() {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\nio\LongBuffer.java
    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public

    final

    LongBuffer position(int newPosition) {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public

    final

    LongBuffer limit(int newLimit) {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public 

    final

    LongBuffer mark() {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public 

    final

    LongBuffer reset() {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public 

    final

    LongBuffer clear() {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public 

    final

    LongBuffer flip() {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public 

    final

    LongBuffer rewind() {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\nio\MappedByteBuffer.java
    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public final MappedByteBuffer position(int newPosition) {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public final MappedByteBuffer limit(int newLimit) {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public final MappedByteBuffer mark() {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public final MappedByteBuffer reset() {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public final MappedByteBuffer clear() {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public final MappedByteBuffer flip() {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public final MappedByteBuffer rewind() {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\nio\ShortBuffer.java
    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public

    final

    ShortBuffer position(int newPosition) {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public

    final

    ShortBuffer limit(int newLimit) {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public 

    final

    ShortBuffer mark() {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public 

    final

    ShortBuffer reset() {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public 

    final

    ShortBuffer clear() {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public 

    final

    ShortBuffer flip() {

    /**
     * {@inheritDoc}
     * @since 9
     */
    @Override
    public 

    final

    ShortBuffer rewind() {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\security\AuthProvider.java
    /**
     * Constructs a provider with the specified name, version string,
     * and information.
     *
     * @param name the provider name.
     * @param versionStr the provider version string.
     * @param info a description of the provider and its services.
     * @since 9
     */
    protected AuthProvider(String name, String versionStr, String info) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\security\DrbgParameters.java
/**
 * This class specifies the parameters used by a DRBG (Deterministic
 * Random Bit Generator).
 * <p>
 * According to
 * <a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf">
 * NIST Special Publication 800-90A Revision 1, Recommendation for Random
 * Number Generation Using Deterministic Random Bit Generators</a> (800-90Ar1),
 * <blockquote>
 * A DRBG is based on a DRBG mechanism as specified in this Recommendation
 * and includes a source of randomness. A DRBG mechanism uses an algorithm
 * (i.e., a DRBG algorithm) that produces a sequence of bits from an initial
 * value that is determined by a seed that is determined from the output of
 * the randomness source."
 * </blockquote>
 * <p>
 * The 800-90Ar1 specification allows for a variety of DRBG implementation
 * choices, such as:
 * <ul>
 * <li> an entropy source,
 * <li> a DRBG mechanism (for example, Hash_DRBG),
 * <li> a DRBG algorithm (for example, SHA-256 for Hash_DRBG and AES-256
 * for CTR_DRBG. Please note that it is not the algorithm used in
 * {@link SecureRandom#getInstance}, which we will call a
 * <em>SecureRandom algorithm</em> below),
 * <li> optionally features, including prediction resistance
 * and reseeding supports.
 * <li> highest security strength.
 * </ul>
 * <p>
 * These choices are set in each implementation and are not directly
 * managed by the {@code SecureRandom} API.  Check your DRBG provider's
 * documentation to find an appropriate implementation for the situation.
 * <p>
 * On the other hand, the 800-90Ar1 specification does have some configurable
 * options, such as:
 * <ul>
 * <li> required security strength,
 * <li> if prediction resistance is required,
 * <li> personalization string and additional input.
 * </ul>
 * <p>
 * A DRBG instance can be instantiated with parameters from an
 * {@link DrbgParameters.Instantiation} object and other information
 * (for example, the nonce, which is not managed by this API). This maps
 * to the {@code Instantiate_function} defined in NIST SP 800-90Ar1.
 * <p>
 * A DRBG instance can be reseeded with parameters from a
 * {@link DrbgParameters.Reseed} object. This maps to the
 * {@code Reseed_function} defined in NIST SP 800-90Ar1. Calling
 * {@link SecureRandom#reseed()} is equivalent to calling
 * {@link SecureRandom#reseed(SecureRandomParameters)} with the effective
 * instantiated prediction resistance flag (as returned by
 * {@link SecureRandom#getParameters()}) with no additional input.
 * <p>
 * A DRBG instance generates data with additional parameters from a
 * {@link DrbgParameters.NextBytes} object. This maps to the
 * {@code Generate_function} defined in NIST SP 800-90Ar1. Calling
 * {@link SecureRandom#nextBytes(byte[])} is equivalent to calling
 * {@link SecureRandom#nextBytes(byte[], SecureRandomParameters)}
 * with the effective instantiated strength and prediction resistance flag
 * (as returned by {@link SecureRandom#getParameters()}) with no
 * additional input.
 * <p>
 * A DRBG should be implemented as a subclass of {@link SecureRandomSpi}.
 * It is recommended that the implementation contain the 1-arg
 * {@linkplain SecureRandomSpi#SecureRandomSpi(SecureRandomParameters) constructor}
 * that takes a {@code DrbgParameters.Instantiation} argument. If implemented
 * this way, this implementation can be chosen by any
 * {@code SecureRandom.getInstance()} method. If it is chosen by a
 * {@code SecureRandom.getInstance()} with a {@link SecureRandomParameters}
 * parameter, the parameter is passed into this constructor. If it is chosen
 * by a {@code SecureRandom.getInstance()} without a
 * {@code SecureRandomParameters} parameter, the constructor is called with
 * a {@code null} argument and the implementation should choose its own
 * parameters. Its {@link SecureRandom#getParameters()} must always return a
 * non-null effective {@code DrbgParameters.Instantiation} object that reflects
 * how the DRBG is actually instantiated. A caller can use this information
 * to determine whether a {@code SecureRandom} object is a DRBG and what
 * features it supports. Please note that the returned value does not
 * necessarily equal to the {@code DrbgParameters.Instantiation} object passed
 * into the {@code SecureRandom.getInstance()} call. For example,
 * the requested capability can be {@link DrbgParameters.Capability#NONE}
 * but the effective value can be {@link DrbgParameters.Capability#RESEED_ONLY}
 * if the implementation supports reseeding. The implementation must implement
 * the {@link SecureRandomSpi#engineNextBytes(byte[], SecureRandomParameters)}
 * method which takes a {@code DrbgParameters.NextBytes} parameter. Unless
 * the result of {@link SecureRandom#getParameters()} has its
 * {@linkplain DrbgParameters.Instantiation#getCapability() capability} being
 * {@link Capability#NONE NONE}, it must implement
 * {@link SecureRandomSpi#engineReseed(SecureRandomParameters)} which takes
 * a {@code DrbgParameters.Reseed} parameter.
 * <p>
 * On the other hand, if a DRBG implementation does not contain a constructor
 * that has an {@code DrbgParameters.Instantiation} argument (not recommended),
 * it can only be chosen by a {@code SecureRandom.getInstance()} without
 * a {@code SecureRandomParameters} parameter, but will not be chosen if
 * a {@code getInstance} method with a {@code SecureRandomParameters} parameter
 * is called. If implemented this way, its {@link SecureRandom#getParameters()}
 * must return {@code null}, and it does not need to implement either
 * {@link SecureRandomSpi#engineNextBytes(byte[], SecureRandomParameters)}
 * or {@link SecureRandomSpi#engineReseed(SecureRandomParameters)}.
 * <p>
 * A DRBG might reseed itself automatically if the seed period is bigger
 * than the maximum seed life defined by the DRBG mechanism.
 * <p>
 * A DRBG implementation should support serialization and deserialization
 * by retaining the configuration and effective parameters, but the internal
 * state must not be serialized and the deserialized object must be
 * reinstantiated.
 * <p>
 * Examples:
 * <blockquote><pre>
 * SecureRandom drbg;
 * byte[] buffer = new byte[32];
 *
 * // Any DRBG is OK
 * drbg = SecureRandom.getInstance("DRBG");
 * drbg.nextBytes(buffer);
 *
 * SecureRandomParameters params = drbg.getParameters();
 * if (params instanceof DrbgParameters.Instantiation) {
 *     DrbgParameters.Instantiation ins = (DrbgParameters.Instantiation) params;
 *     if (ins.getCapability().supportsReseeding()) {
 *         drbg.reseed();
 *     }
 * }
 *
 * // The following call requests a weak DRBG instance. It is only
 * // guaranteed to support 112 bits of security strength.
 * drbg = SecureRandom.getInstance("DRBG",
 *         DrbgParameters.instantiation(112, NONE, null));
 *
 * // Both the next two calls will likely fail, because drbg could be
 * // instantiated with a smaller strength with no prediction resistance
 * // support.
 * drbg.nextBytes(buffer,
 *         DrbgParameters.nextBytes(256, false, "more".getBytes()));
 * drbg.nextBytes(buffer,
 *         DrbgParameters.nextBytes(112, true, "more".getBytes()));
 *
 * // The following call requests a strong DRBG instance, with a
 * // personalization string. If it successfully returns an instance,
 * // that instance is guaranteed to support 256 bits of security strength
 * // with prediction resistance available.
 * drbg = SecureRandom.getInstance("DRBG", DrbgParameters.instantiation(
 *         256, PR_AND_RESEED, "hello".getBytes()));
 *
 * // Prediction resistance is not requested in this single call,
 * // but an additional input is used.
 * drbg.nextBytes(buffer,
 *         DrbgParameters.nextBytes(-1, false, "more".getBytes()));
 *
 * // Same for this call.
 * drbg.reseed(DrbgParameters.reseed(false, "extra".getBytes()));</pre>
 * </blockquote>
 *
 * @implSpec
 * By convention, a provider should name its primary DRBG implementation
 * with the <a href=
 * "{@docRoot}/../technotes/guides/security/StandardNames.html#SecureRandom">
 * standard {@code SecureRandom} algorithm name</a> "DRBG".
 *
 * @implNote
 * The following notes apply to the "DRBG" implementation in the SUN provider
 * of the JDK reference implementation.
 * <p>
 * This implementation supports the Hash_DRBG and HMAC_DRBG mechanisms with
 * DRBG algorithm SHA-224, SHA-512/224, SHA-256, SHA-512/256, SHA-384 and
 * SHA-512, and CTR_DRBG (both using derivation function and not using
 * derivation function) with DRBG algorithm AES-128, AES-192 and AES-256.
 * <p>
 * The mechanism name and DRBG algorithm name are determined by the
 * {@linkplain Security#getProperty(String) security property}
 * {@code securerandom.drbg.config}. The default choice is Hash_DRBG
 * with SHA-256.
 * <p>
 * For each combination, the security strength can be requested from 112
 * up to the highest strength it supports. Both reseeding and prediction
 * resistance are supported.
 * <p>
 * Personalization string is supported through the
 * {@link DrbgParameters.Instantiation} class and additional input is supported
 * through the {@link DrbgParameters.NextBytes} and
 * {@link DrbgParameters.Reseed} classes.
 * <p>
 * If a DRBG is not instantiated with a {@link DrbgParameters.Instantiation}
 * object explicitly, this implementation instantiates it with a default
 * requested strength of 128 bits, no prediction resistance request, and
 * no personalization string. These default instantiation parameters can also
 * be customized with the {@code securerandom.drbg.config} security property.
 * <p>
 * This implementation reads fresh entropy from the system default entropy
 * source determined by the security property {@code securerandom.source}.
 * <p>
 * Calling {@link SecureRandom#generateSeed(int)} will directly read
 * from this system default entropy source.
 * <p>
 * This implementation has passed all tests included in the 20151104 version of
 * <a href="http://csrc.nist.gov/groups/STM/cavp/documents/drbg/drbgtestvectors.zip">
 * The DRBG Test Vectors</a>.
 *
 * @since 9
 */
public class DrbgParameters {

    /**
     * The reseedable and prediction resistance capabilities of a DRBG.
     * <p>
     * When this object is passed to a {@code SecureRandom.getInstance()} call,
     * it is the requested minimum capability. When it's returned from
     * {@code SecureRandom.getParameters()}, it is the effective capability.
     * <p>
     * Please note that while the {@code Instantiate_function} defined in
     * NIST SP 800-90Ar1 only includes a {@code prediction_resistance_flag}
     * parameter, the {@code Capability} type includes an extra value
     * {@link #RESEED_ONLY} because reseeding is an optional function.
     * If {@code NONE} is used in an {@code Instantiation} object in calling the
     * {@code SecureRandom.getInstance} method, the returned DRBG instance
     * is not guaranteed to support reseeding. If {@code RESEED_ONLY} or
     * {@code PR_AND_RESEED} is used, the instance must support reseeding.
     * <p>
     * The table below lists possible effective values if a certain
     * capability is requested, i.e.
     * <blockquote><pre>
     * Capability requested = ...;
     * SecureRandom s = SecureRandom.getInstance("DRBG",
     *         DrbgParameters(-1, requested, null));
     * Capability effective = ((DrbgParametes.Initiate) s.getParameters())
     *         .getCapability();</pre>
     * </blockquote>
     * <table border=1 summary="requested and effective capabilities">
     * <tr>
     * <th>Requested Value</th>
     * <th>Possible Effective Values</th>
     * </tr>
     * <tr><td>NONE</td><td>NONE, RESEED_ONLY, PR_AND_RESEED</td></tr>
     * <tr><td>RESEED_ONLY</td><td>RESEED_ONLY, PR_AND_RESEED</td></tr>
     * <tr><td>PR_AND_RESEED</td><td>PR_AND_RESEED</td></tr>
     * </table>
     * <p>
     * A DRBG implementation supporting prediction resistance must also
     * support reseeding.
     *
     * @since 9
     */
    public enum Capability {

    /**
     * DRBG parameters for instantiation.
     * <p>
     * When used in
     * {@link SecureRandom#getInstance(String, SecureRandomParameters)}
     * or one of the other similar {@code getInstance} calls that take a
     * {@code SecureRandomParameters} parameter, it means the
     * requested instantiate parameters the newly created {@code SecureRandom}
     * object must minimally support. When used as the return value of the
     * {@link SecureRandom#getParameters()} method, it means the effective
     * instantiate parameters of the {@code SecureRandom} object.
     *
     * @since 9
     */
    public static final class Instantiation
            implements SecureRandomParameters {

    /**
     * DRBG parameters for random bits generation. It is used in
     * {@link SecureRandom#nextBytes(byte[], SecureRandomParameters)}.
     *
     * @since 9
     */
    public static final class NextBytes
            implements SecureRandomParameters {

    /**
     * DRBG parameters for reseed. It is used in
     * {@link SecureRandom#reseed(SecureRandomParameters)}.
     *
     * @since 9
     */
    public static final class Reseed implements SecureRandomParameters {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\security\KeyStore.java
    /**
     * Returns a loaded keystore object of the appropriate keystore type.
     * First the keystore type is determined by probing the specified file.
     * Then a keystore object is instantiated and loaded using the data from
     * that file.
     *
     * <p>
     * A password may be given to unlock the keystore
     * (e.g. the keystore resides on a hardware token device),
     * or to check the integrity of the keystore data.
     * If a password is not given for integrity checking,
     * then integrity checking is not performed.
     *
     * <p>
     * This method traverses the list of registered security
     * {@linkplain Provider providers}, starting with the most
     * preferred Provider.
     * For each {@link KeyStoreSpi} implementation supported by a
     * Provider, it invokes the {@link
     * KeyStoreSpi#engineProbe(InputStream) engineProbe} method to
     * determine if it supports the specified keystore.
     * A new KeyStore object is returned that encapsulates the KeyStoreSpi
     * implementation from the first Provider that supports the specified file.
     *
     * <p> Note that the list of registered providers may be retrieved via
     * the {@link Security#getProviders() Security.getProviders()} method.
     *
     * @param  file the keystore file
     * @param  password the keystore password, which may be {@code null}
     *
     * @return a keystore object loaded with keystore data
     *
     * @throws KeyStoreException if no Provider supports a KeyStoreSpi
     *             implementation for the specified keystore file.
     * @throws IOException if there is an I/O or format problem with the
     *             keystore data, if a password is required but not given,
     *             or if the given password was incorrect. If the error is
     *             due to a wrong password, the {@link Throwable#getCause cause}
     *             of the {@code IOException} should be an
     *             {@code UnrecoverableKeyException}.
     * @throws NoSuchAlgorithmException if the algorithm used to check the
     *             integrity of the keystore cannot be found.
     * @throws CertificateException if any of the certificates in the
     *             keystore could not be loaded.
     * @throws IllegalArgumentException if file does not exist or does not
     *             refer to a normal file.
     * @throws NullPointerException if file is {@code null}.
     * @throws SecurityException if a security manager exists and its
     *             {@link java.lang.SecurityManager#checkRead} method denies
     *             read access to the specified file.
     *
     * @see Provider
     *
     * @since 9
     */
    public static final KeyStore getInstance(File file, char[] password)
        throws KeyStoreException, IOException, NoSuchAlgorithmException,
            CertificateException {

    /**
     * Returns a loaded keystore object of the appropriate keystore type.
     * First the keystore type is determined by probing the specified file.
     * Then a keystore object is instantiated and loaded using the data from
     * that file.
     * A {@code LoadStoreParameter} may be supplied which specifies how to
     * unlock the keystore data or perform an integrity check.
     *
     * <p>
     * This method traverses the list of registered security {@linkplain
     * Provider providers}, starting with the most preferred Provider.
     * For each {@link KeyStoreSpi} implementation supported by a
     * Provider, it invokes the {@link
     * KeyStoreSpi#engineProbe(InputStream) engineProbe} method to
     * determine if it supports the specified keystore.
     * A new KeyStore object is returned that encapsulates the KeyStoreSpi
     * implementation from the first Provider that supports the specified file.
     *
     * <p> Note that the list of registered providers may be retrieved via
     * the {@link Security#getProviders() Security.getProviders()} method.
     *
     * @param  file the keystore file
     * @param  param the {@code LoadStoreParameter} that specifies how to load
     *             the keystore, which may be {@code null}
     *
     * @return a keystore object loaded with keystore data
     *
     * @throws KeyStoreException if no Provider supports a KeyStoreSpi
     *             implementation for the specified keystore file.
     * @throws IOException if there is an I/O or format problem with the
     *             keystore data. If the error is due to an incorrect
     *             {@code ProtectionParameter} (e.g. wrong password)
     *             the {@link Throwable#getCause cause} of the
     *             {@code IOException} should be an
     *             {@code UnrecoverableKeyException}.
     * @throws NoSuchAlgorithmException if the algorithm used to check the
     *             integrity of the keystore cannot be found.
     * @throws CertificateException if any of the certificates in the
     *             keystore could not be loaded.
     * @throws IllegalArgumentException if file does not exist or does not
     *             refer to a normal file, or if param is not recognized.
     * @throws NullPointerException if file is {@code null}.
     * @throws SecurityException if a security manager exists and its
     *             {@link java.lang.SecurityManager#checkRead} method denies
     *             read access to the specified file.
     *
     * @see Provider
     *
     * @since 9
     */
    public static final KeyStore getInstance(File file,
        LoadStoreParameter param) throws KeyStoreException, IOException,
            NoSuchAlgorithmException, CertificateException {

        /**
         * Returns a new Builder object.
         *
         * <p>The first call to the {@link #getKeyStore} method on the returned
         * builder will create a KeyStore using {@code file} to detect the
         * keystore type and then call its {@link KeyStore#load load()} method.
         * It uses the same algorithm to determine the keystore type as
         * described in {@link KeyStore#getInstance(File, LoadStoreParameter)}.
         * The {@code inputStream} argument is constructed from {@code file}.
         * If {@code protection} is a {@code PasswordProtection}, the password
         * is obtained by calling the {@code getPassword} method.
         * Otherwise, if {@code protection} is a
         * {@code CallbackHandlerProtection},
         * the password is obtained by invoking the CallbackHandler.
         *
         * <p>Subsequent calls to {@link #getKeyStore} return the same object
         * as the initial call. If the initial call failed with a
         * KeyStoreException, subsequent calls also throw a KeyStoreException.
         *
         * <p>Calls to {@link #getProtectionParameter getProtectionParameter()}
         * will return a {@link KeyStore.PasswordProtection PasswordProtection}
         * object encapsulating the password that was used to invoke the
         * {@code load} method.
         *
         * <p><em>Note</em> that the {@link #getKeyStore} method is executed
         * within the {@link AccessControlContext} of the code invoking this
         * method.
         *
         * @return a new Builder object
         * @param file the File that contains the KeyStore data
         * @param protection the ProtectionParameter securing the KeyStore data
         * @throws NullPointerException if file or protection is null
         * @throws IllegalArgumentException if protection is not an instance
         *   of either PasswordProtection or CallbackHandlerProtection; or
         *   if file does not exist or does not refer to a normal file
         *
         * @since 9
         */
        public static Builder newInstance(File file,
            ProtectionParameter protection) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\security\KeyStoreSpi.java
    /**
     * Probes the specified input stream to determine whether it contains a
     * keystore that is supported by this implementation, or not.
     *
     * @implSpec
     * This method returns false by default. Keystore implementations should
     * override this method to peek at the data stream directly or to use other
     * content detection mechanisms.
     *
     * @param  stream the keystore data to be probed
     *
     * @return true if the keystore data is supported, otherwise false
     *
     * @throws IOException if there is an I/O problem with the keystore data.
     * @throws NullPointerException if stream is {@code null}.
     *
     * @since 9
     */
    public boolean engineProbe(InputStream stream) throws IOException {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\security\PermissionCollection.java
    /**
     * Returns a stream of all the Permission objects in the collection.
     *
     * <p> The collection should not be modified (see {@link #add}) during the
     * execution of the terminal stream operation. Otherwise, the result of the
     * terminal stream operation is undefined.
     *
     * @implSpec
     * The default implementation creates a stream whose source is derived from
     * the enumeration returned from a call to {@link #elements()}.
     *
     * @return a stream of all the Permissions.
     * @since 9
     */
    public Stream<Permission> elementsAsStream() {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\security\ProtectionDomain.java
    /**
     * Returns true if this domain contains only static permissions
     * and does not check the current {@code Policy} at the time of
     * permission checking.
     *
     * @return true if this domain contains only static permissions.
     *
     * @since 9
     */
    public final boolean staticPermissionsOnly() {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\security\Provider.java
    /**
     * Constructs a provider with the specified name, version string,
     * and information.
     *
     * <p>The version string contains a version number optionally followed
     * by other information separated by one of the characters of '+', '-'.
     *
     * The format for the version number is:
     *
     * <blockquote><pre>
     *     ^[0-9]+(\.[0-9]+)*
     * </pre></blockquote>
     *
     * <p>In order to return the version number in a double, when there are
     * more than two components (separated by '.' as defined above), only
     * the first two components are retained. The resulting string is then
     * passed to {@link Double#valueOf(String)} to generate version number,
     * i.e. {@link #getVersion}.
     * <p>If the conversion failed, value 0 will be used.
     *
     * @param name the provider name.
     *
     * @param versionStr the provider version string.
     *
     * @param info a description of the provider and its services.
     *
     * @since 9
     */
    protected Provider(String name, String versionStr, String info) {

    /**
     * Apply the supplied configuration argument to this provider instance
     * and return the configured provider. Note that if this provider cannot
     * be configured in-place, a new provider will be created and returned.
     * Therefore, callers should always use the returned provider.
     *
     * @implSpec
     * The default implementation throws {@code UnsupportedOperationException}.
     * Subclasses should override this method only if a configuration argument
     * is supported.
     *
     * @param configArg the configuration information for configuring this
     *         provider.
     *
     * @throws UnsupportedOperationException if a configuration argument is
     *         not supported.
     * @throws NullPointerException if the supplied configuration argument is
               null.
     * @throws InvalidParameterException if the supplied configuration argument
     *         is invalid.
     * @return a provider configured with the supplied configuration argument.
     *
     * @since 9
     */
    public Provider configure(String configArg) {

    /**
     * Check if this provider instance has been configured.
     *
     * @implSpec
     * The default implementation returns true.
     * Subclasses should override this method if the provider instance requires
     * an explicit {@code configure} call after being constructed.
     *
     * @return true if no further configuration is needed, false otherwise.
     *
     * @since 9
     */
    public boolean isConfigured() {

    /**
     * Returns the version string for this provider.
     *
     * @return the version string for this provider.
     *
     * @since 9
     */
    public String getVersionStr() {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\security\SecureRandom.java
    /**
     * Returns a {@code SecureRandom} object that implements the specified
     * Random Number Generator (RNG) algorithm and supports the specified
     * {@code SecureRandomParameters} request.
     *
     * <p> This method traverses the list of registered security Providers,
     * starting with the most preferred Provider.
     * A new {@code SecureRandom} object encapsulating the
     * {@code SecureRandomSpi} implementation from the first
     * Provider that supports the specified algorithm and the specified
     * {@code SecureRandomParameters} is returned.
     *
     * <p> Note that the list of registered providers may be retrieved via
     * the {@link Security#getProviders() Security.getProviders()} method.
     *
     * @implNote
     * The JDK Reference Implementation additionally uses the
     * {@code jdk.security.provider.preferred} property to determine
     * the preferred provider order for the specified algorithm. This
     * may be different than the order of providers returned by
     * {@link Security#getProviders() Security.getProviders()}.
     *
     * @param algorithm the name of the RNG algorithm.
     * See the {@code SecureRandom} section in the <a href=
     * "{@docRoot}/../technotes/guides/security/StandardNames.html#SecureRandom">
     * Java Cryptography Architecture Standard Algorithm Name Documentation</a>
     * for information about standard RNG algorithm names.
     *
     * @param params the {@code SecureRandomParameters}
     *               the newly created {@code SecureRandom} object must support.
     *
     * @return the new {@code SecureRandom} object.
     *
     * @throws NoSuchAlgorithmException if no Provider supports a
     *         {@code SecureRandomSpi} implementation for the specified
     *         algorithm and parameters.
     *
     * @throws IllegalArgumentException if the specified params is null.
     *
     * @see Provider
     *
     * @since 9
     */
    public static SecureRandom getInstance(
            String algorithm, SecureRandomParameters params)
            throws NoSuchAlgorithmException {

    /**
     * Returns a {@code SecureRandom} object that implements the specified
     * Random Number Generator (RNG) algorithm and supports the specified
     * {@code SecureRandomParameters} request.
     *
     * <p> A new {@code SecureRandom} object encapsulating the
     * {@code SecureRandomSpi} implementation from the specified provider
     * is returned.  The specified provider must be registered
     * in the security provider list.
     *
     * <p> Note that the list of registered providers may be retrieved via
     * the {@link Security#getProviders() Security.getProviders()} method.
     *
     * @param algorithm the name of the RNG algorithm.
     * See the {@code SecureRandom} section in the <a href=
     * "{@docRoot}/../technotes/guides/security/StandardNames.html#SecureRandom">
     * Java Cryptography Architecture Standard Algorithm Name Documentation</a>
     * for information about standard RNG algorithm names.
     *
     * @param params the {@code SecureRandomParameters}
     *               the newly created {@code SecureRandom} object must support.
     *
     * @param provider the name of the provider.
     *
     * @return the new {@code SecureRandom} object.
     *
     * @throws NoSuchAlgorithmException if the specified provider does not
     *         support a {@code SecureRandomSpi} implementation for the
     *         specified algorithm and parameters.
     *
     * @throws NoSuchProviderException if the specified provider is not
     *         registered in the security provider list.
     *
     * @throws IllegalArgumentException if the provider name is null
     *         or empty, or params is null.
     *
     * @see Provider
     *
     * @since 9
     */
    public static SecureRandom getInstance(String algorithm,
            SecureRandomParameters params, String provider)
            throws NoSuchAlgorithmException, NoSuchProviderException {

    /**
     * Returns a {@code SecureRandom} object that implements the specified
     * Random Number Generator (RNG) algorithm and supports the specified
     * {@code SecureRandomParameters} request.
     *
     * <p> A new {@code SecureRandom} object encapsulating the
     * {@code SecureRandomSpi} implementation from the specified
     * {@code Provider} object is returned.  Note that the specified
     * {@code Provider} object does not have to be registered in the
     * provider list.
     *
     * @param algorithm the name of the RNG algorithm.
     * See the {@code SecureRandom} section in the <a href=
     * "{@docRoot}/../technotes/guides/security/StandardNames.html#SecureRandom">
     * Java Cryptography Architecture Standard Algorithm Name Documentation</a>
     * for information about standard RNG algorithm names.
     *
     * @param params the {@code SecureRandomParameters}
     *               the newly created {@code SecureRandom} object must support.
     *
     * @param provider the provider.
     *
     * @return the new {@code SecureRandom} object.
     *
     * @throws NoSuchAlgorithmException if the specified provider does not
     *         support a {@code SecureRandomSpi} implementation for the
     *         specified algorithm and parameters.
     *
     * @throws IllegalArgumentException if the specified provider or params
     *         is null.
     *
     * @see Provider
     *
     * @since 9
     */
    public static SecureRandom getInstance(String algorithm,
            SecureRandomParameters params, Provider provider)
            throws NoSuchAlgorithmException {

    /**
     * Returns a Human-readable string representation of this
     * {@code SecureRandom}.
     *
     * @return the string representation
     *
     * @since 9
     */
    @Override
    public String toString() {

    /**
     * Returns the effective {@link SecureRandomParameters} for this
     * {@code SecureRandom} instance.
     * <p>
     * The returned value can be different from the
     * {@code SecureRandomParameters} object passed into a {@code getInstance}
     * method, but it cannot change during the lifetime of this
     * {@code SecureRandom} object.
     * <p>
     * A caller can use the returned value to find out what features this
     * {@code SecureRandom} supports.
     *
     * @return the effective {@link SecureRandomParameters} parameters,
     * or {@code null} if no parameters were used.
     *
     * @since 9
     * @see SecureRandomSpi
     */
    public SecureRandomParameters getParameters() {

    /**
     * Generates a user-specified number of random bytes with
     * additional parameters.
     *
     * @param bytes the array to be filled in with random bytes
     * @param params additional parameters
     * @throws NullPointerException if {@code bytes} is null
     * @throws UnsupportedOperationException if the underlying provider
     *         implementation has not overridden this method
     * @throws IllegalArgumentException if {@code params} is {@code null},
     *         illegal or unsupported by this {@code SecureRandom}
     *
     * @since 9
     */
    public synchronized void nextBytes(
            byte[] bytes, SecureRandomParameters params) {

    /**
     * Reseeds this {@code SecureRandom} with entropy input read from its
     * entropy source.
     *
     * @throws UnsupportedOperationException if the underlying provider
     *         implementation has not overridden this method.
     *
     * @since 9
     */
    public synchronized void reseed() {

    /**
     * Reseeds this {@code SecureRandom} with entropy input read from its
     * entropy source with additional parameters.
     * <p>
     * Note that entropy is obtained from an entropy source. While
     * some data in {@code params} may contain entropy, its main usage is to
     * provide diversity.
     *
     * @param params extra parameters
     * @throws UnsupportedOperationException if the underlying provider
     *         implementation has not overridden this method.
     * @throws IllegalArgumentException if {@code params} is {@code null},
     *         illegal or unsupported by this {@code SecureRandom}
     *
     * @since 9
     */
    public synchronized void reseed(SecureRandomParameters params) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\security\SecureRandomParameters.java
/**
 * A marker interface for parameters used in various {@code SecureRandom}
 * methods.
 * <p>
 * Some {@code SecureRandom} implementations might require additional
 * operational parameters. Objects of classes which implement this interface
 * can be passed to those implementations that support them.
 *
 * @see DrbgParameters
 * @since 9
 */
public interface SecureRandomParameters {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\security\SecureRandomSpi.java
    /**
     * Constructor with a parameter.
     *
     * @param params the {@link SecureRandomParameters} object.
     *               This argument can be {@code null}.
     * @throws IllegalArgumentException if {@code params} is
     *         unrecognizable or unsupported by this {@code SecureRandom}
     *
     * @since 9
     */
    protected SecureRandomSpi(SecureRandomParameters params) {

    /**
     * Generates a user-specified number of random bytes with
     * additional parameters.
     * <p>
     * Some random number generators can only generate a limited amount
     * of random bytes per invocation. If the size of {@code bytes}
     * is greater than this limit, the implementation should invoke
     * its generation process multiple times to completely fill the
     * buffer before returning from this method.
     *
     * @implSpec The default implementation throws
     * an {@link UnsupportedOperationException}.
     *
     * @param bytes the array to be filled in with random bytes
     * @param params additional parameters
     * @throws UnsupportedOperationException if the implementation
     *         has not overridden this method
     * @throws IllegalArgumentException if {@code params} is {@code null},
     *         illegal or unsupported by this {@code SecureRandom}
     *
     * @since 9
     */
    protected void engineNextBytes(
            byte[] bytes, SecureRandomParameters params) {

    /**
     * Reseeds this random object with entropy input read from its
     * entropy source with additional parameters.
     * <p>
     * If this method is called by {@link SecureRandom#reseed()},
     * {@code params} will be {@code null}.
     * <p>
     * Do not override this method if the implementation does not
     * support reseeding.
     *
     * @implSpec The default implementation throws
     *           an {@link UnsupportedOperationException}.
     *
     * @param params extra parameters, can be {@code null}.
     * @throws UnsupportedOperationException if the implementation
     *         has not overridden this method
     * @throws IllegalArgumentException if {@code params} is
     *         illegal or unsupported by this {@code SecureRandom}
     *
     * @since 9
     */
    protected void engineReseed(SecureRandomParameters params) {

    /**
     * Returns the effective {@link SecureRandomParameters} for this
     * {@code SecureRandom} instance.
     *
     * @implSpec The default implementation returns {@code null}.
     *
     * @return the effective {@link SecureRandomParameters} parameters,
     * or {@code null} if no parameters were used.
     *
     * @since 9
     */
    protected SecureRandomParameters engineGetParameters() {

    /**
     * Returns a Human-readable string representation of this
     * {@code SecureRandom}.
     *
     * @return the string representation
     *
     * @since 9
     */
    @Override
    public String toString() {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\security\spec\EncodedKeySpec.java
    /**
     * Creates a new {@code EncodedKeySpec} with the given encoded key.
     * This constructor is useful when subsequent callers of the
     * {@code EncodedKeySpec} object might not know the algorithm
     * of the key.
     *
     * @param encodedKey the encoded key. The contents of the
     * array are copied to protect against subsequent modification.
     * @param algorithm the algorithm name of the encoded key
     * See the KeyFactory section in the <a href=
     * "{@docRoot}/../technotes/guides/security/StandardNames.html#KeyFactory">
     * Java Cryptography Architecture Standard Algorithm Name Documentation</a>
     * for information about standard algorithm names.
     * @throws NullPointerException if {@code encodedKey}
     * or {@code algorithm} is null.
     * @throws IllegalArgumentException if {@code algorithm} is
     * the empty string {@code ""}
     * @since 9
     */
    protected EncodedKeySpec(byte[] encodedKey, String algorithm) {

    /**
     * Returns the name of the algorithm of the encoded key.
     *
     * @return the name of the algorithm, or null if not specified
     * @since 9
     */
    public String getAlgorithm() {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\security\spec\PKCS8EncodedKeySpec.java
    /**
     * Creates a new {@code PKCS8EncodedKeySpec} with the given encoded key and
     * algorithm. This constructor is useful when subsequent callers of
     * the {@code PKCS8EncodedKeySpec} object might not know the
     * algorithm of the private key.
     *
     * @param encodedKey the key, which is assumed to be
     * encoded according to the PKCS #8 standard. The contents of
     * the array are copied to protect against subsequent modification.
     * @param algorithm the algorithm name of the encoded private key
     * See the KeyFactory section in the <a href=
     * "{@docRoot}/../technotes/guides/security/StandardNames.html#KeyFactory">
     * Java Cryptography Architecture Standard Algorithm Name Documentation</a>
     * for information about standard algorithm names.
     * @throws NullPointerException if {@code encodedKey}
     * or {@code algorithm} is null.
     * @throws IllegalArgumentException if {@code algorithm} is
     * the empty string {@code ""}
     * @since 9
     */
    public PKCS8EncodedKeySpec(byte[] encodedKey, String algorithm) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\security\spec\X509EncodedKeySpec.java
    /**
     * Creates a new {@code X509EncodedKeySpec} with the given encoded key.
     * This constructor is useful when subsequent callers of the
     * {@code X509EncodedKeySpec} object might not know the algorithm
     * of the key.
     *
     * @param encodedKey the key, which is assumed to be
     * encoded according to the X.509 standard. The contents of the
     * array are copied to protect against subsequent modification.
     * @param algorithm the algorithm name of the encoded public key
     * See the KeyFactory section in the <a href=
     * "{@docRoot}/../technotes/guides/security/StandardNames.html#KeyFactory">
     * Java Cryptography Architecture Standard Algorithm Name Documentation</a>
     * for information about standard algorithm names.
     * @throws NullPointerException if {@code encodedKey}
     * or {@code algorithm} is null.
     * @throws IllegalArgumentException if {@code algorithm} is
     * the empty string {@code ""}
     * @since 9
     */
    public X509EncodedKeySpec(byte[] encodedKey, String algorithm) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\sql\Connection.java
     /**
     * Hints to the driver that a request, an independent unit of work, is beginning
     * on this connection. Each request is independent of all other requests
     * with regard to state local to the connection either on the client or the
     * server. Work done between {@code beginRequest}, {@code endRequest}
     * pairs does not depend on any other work done on the connection either as
     * part of another request or outside of any request. A request may include multiple
     * transactions. There may be dependencies on committed database state as
     * that is not local to the connection.
     * <p>
     * Local state is defined as any state associated with a Connection that is
     * local to the current Connection either in the client or the database that
     * is not transparently reproducible.
     * <p>
     * Calls to {@code beginRequest} and {@code endRequest}  are not nested.
     * Multiple calls to {@code beginRequest} without an intervening call
     * to {@code endRequest} is not an error. The first {@code beginRequest} call
     * marks the start of the request and subsequent calls are treated as
     * a no-op
     * <p>
     * Use of {@code beginRequest} and {@code endRequest} is optional, vendor
     * specific and should largely be transparent. In particular
     * implementations may detect conditions that indicate dependence on
     * other work such as an open transaction. It is recommended though not
     * required that implementations throw a {@code SQLException} if there is an active
     * transaction and {@code beginRequest} is called.
     * Using these methods may improve performance or provide other benefits.
     * Consult your vendors documentation for additional information.
     * <p>
     * It is recommended to
     * enclose each unit of work in {@code beginRequest}, {@code endRequest}
     * pairs such that there is no open transaction at the beginning or end of
     * the request and no dependency on local state that crosses request
     * boundaries. Committed database state is not local.
     *
     * @implSpec
     * The default implementation is a no-op.
     * <p>
     * @apiNote
     * This method is to be used by Connection pooling managers.
     * <p>
     * The pooling manager should call {@code beginRequest} on the underlying connection
     * prior to returning a connection to the caller.
     * <p>
     * The pooling manager does not need to call {@code beginRequest} if:
     * <ul>
     * <li>The connection pool caches {@code PooledConnection} objects</li>
     * <li>Returns a logical connection handle when {@code getConnection} is
     * called by the application</li>
     * <li>The pool manager calls {@code Connection.close} on the logical connection handle
     * prior to returning the {@code PooledConnection} back to the cache</li>
     * </ul>
     * @throws SQLException if an error occurs
     * @since 9
     * @see endRequest
     * @see javax.sql.PooledConnection
     */
    default void beginRequest() throws SQLException {

    /**
     * Hints to the driver that a request, an independent unit of work,
     * has completed. Calls to {@code beginRequest}
     * and {@code endRequest} are not nested. Multiple
     * calls to {@code endRequest} without an intervening call to {@code beginRequest}
     * is not an error. The first {@code endRequest} call
     * marks the request completed and subsequent calls are treated as
     * a no-op. If {@code endRequest} is called without an initial call to
     * {@code beginRequest} is a no-op.
     *<p>
     * The exact behavior of this method is vendor specific. In particular
     * implementations may detect conditions that indicate dependence on
     * other work such as an open transaction. It is recommended though not
     * required that implementations throw a {@code SQLException} if there is an active
     * transaction and {@code endRequest} is called.
     *
     * @implSpec
     * The default implementation is a no-op.
     * @apiNote
     *
     * This method is to be used by Connection pooling managers.
     * <p>
     * The pooling manager should call {@code endRequest} on the underlying connection
     * when the applications returns the connection back to the connection pool.
     * <p>
     * The pooling manager does not need to call {@code endRequest} if:
     * <ul>
     * <li>The connection pool caches {@code PooledConnection} objects</li>
     * <li>Returns a logical connection handle when {@code getConnection} is
     * called by the application</li>
     * <li>The pool manager calls {@code Connection.close} on the logical connection handle
     * prior to returning the {@code PooledConnection} back to the cache</li>
     * </ul>
     * @throws SQLException if an error occurs
     * @since 9
     * @see beginRequest
     * @see javax.sql.PooledConnection
     */
    default void endRequest() throws SQLException {

    /**
     * Sets and validates the sharding keys for this connection.
     * @implSpec
     * The default implementation will throw a
     * {@code SQLFeatureNotSupportedException}.
     *
     * @apiNote
     * This method validates that the sharding keys are valid for the
     * {@code Connection}. The timeout value indicates how long the driver
     * should wait for the {@code Connection} to verify that the sharding key
     * is valid before {@code setShardingKeyIfValid} returns false.
     * @param shardingKey the sharding key to be validated against this connection
     * @param superShardingKey the super sharding key to be validated against this
     * connection. The super sharding key may be {@code null}.
     * @param timeout time in seconds before which the validation process is expected to
     * be completed, otherwise the validation process is aborted. A value of 0 indicates
     * the validation process will not time out.
     * @return true if the connection is valid and the sharding keys are valid
     * and set on this connection; false if the sharding keys are not valid or
     * the timeout period expires before the operation completes.
     * @throws SQLException if an error occurs while performing this validation;
     * the {@code shardingkey} is {@code null}; a {@code superSharedingKey} is specified
     * without a {@code shardingKey};
     * this method is called on a closed {@code connection}; or
     * the {@code timeout} value is less than 0.
     * @throws SQLFeatureNotSupportedException if the driver does not support sharding
     * @since 9
     * @see ShardingKey
     * @see ShardingKeyBuilder
     */
    default boolean setShardingKeyIfValid(ShardingKey shardingKey,
            ShardingKey superShardingKey, int timeout)
            throws SQLException {

    /**
     * Sets and validates the sharding key for this connection.
     * @implSpec
     * The default implementation will throw a
     * {@code SQLFeatureNotSupportedException}.
     * @apiNote
     * This method validates  that the sharding key is valid for the
     * {@code Connection}. The timeout value indicates how long the driver
     * should wait for the {@code Connection} to verify that the sharding key
     * is valid before {@code setShardingKeyIfValid} returns false.
     * @param shardingKey the sharding key to be validated against this connection
     * @param timeout time in seconds before which the validation process is expected to
     * be completed,else the validation process is aborted. A value of 0 indicates
     * the validation process will not time out.
     * @return true if the connection is valid and the sharding key is valid to be
     * set on this connection; false if the sharding key is not valid or
     * the timeout period expires before the operation completes.
     * @throws SQLException if there is an error while performing this validation;
     * this method is called on a closed {@code connection}; the {@code shardingkey}
     * is {@code null}; or the {@code timeout} value is less than 0.
     * @throws SQLFeatureNotSupportedException if the driver does not support sharding
     * @since 9
     * @see ShardingKey
     * @see ShardingKeyBuilder
     */
    default boolean setShardingKeyIfValid(ShardingKey shardingKey, int timeout)
            throws SQLException {

    /**
     * Specifies a shardingKey and superShardingKey to use with this Connection
     * @implSpec
     * The default implementation will throw a
     * {@code SQLFeatureNotSupportedException}.
     * @apiNote
     * This method sets the specified sharding keys but does not require a
     * round trip to the database to validate that the sharding keys are valid
     * for the {@code Connection}.
     * @param shardingKey the sharding key to set on this connection.
     * @param superShardingKey the super sharding key to set on this connection.
     * The super sharding key may be {@code null}
     * @throws SQLException if an error  occurs setting the sharding keys;
     * this method is called on a closed {@code connection};
     * the {@code shardingkey} is {@code null}; or
     * a {@code superSharedingKey} is specified without a {@code shardingKey}
     * @throws SQLFeatureNotSupportedException if the driver does not support sharding
     * @since 9
     * @see ShardingKey
     * @see ShardingKeyBuilder
     */
    default void setShardingKey(ShardingKey shardingKey, ShardingKey superShardingKey)
            throws SQLException {

    /**
     * Specifies a shardingKey to use with this Connection
     * @implSpec
     * The default implementation will throw a
     * {@code SQLFeatureNotSupportedException}.
     * @apiNote
     * This method sets the specified sharding key but does not require a
     * round trip to the database to validate that the sharding key is valid
     * for the {@code Connection}.
     * @param shardingKey the sharding key to set on this connection.
     * @throws SQLException if an error  occurs setting the sharding key;
     * this method is called on a closed {@code connection}; or the
     * {@code shardkingKey} is {@code null}
     * @throws SQLFeatureNotSupportedException if the driver does not support sharding
     * @since 9
     * @see ShardingKey
     * @see ShardingKeyBuilder
     */
    default void setShardingKey(ShardingKey shardingKey)
            throws SQLException {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\sql\ConnectionBuilder.java
/**
 * A builder created from a {@code DataSource} object,
 * used to establish a connection to the database that the
 * {@code data source} object represents.  The connection
 * properties that were specified for the {@code data source} are used as the
 * default values by the {@code ConnectionBuilder}.
 * <p>The following example illustrates the use of {@code ConnectionBuilder}
 * to create a {@link Connection}:
 *
 * <pre>{@code
 *     DataSource ds = new MyDataSource();
 *     ShardingKey superShardingKey = ds.createShardingKeyBuilder()
 *                           .subkey("EASTERN_REGION", JDBCType.VARCHAR)
 *                           .build();
 *     ShardingKey shardingKey = ds.createShardingKeyBuilder()
 *                           .subkey("PITTSBURGH_BRANCH", JDBCType.VARCHAR)
 *                           .build();
 *     Connection con = ds.createConnectionBuilder()
 *                       .user("rafa")
 *                       .password("tennis")
 *                       .setShardingKey(shardingKey)
 *                       .setSuperShardingKey(superShardingKey)
 *                       .build();
 * }</pre>
 *
 * @since 9
 *
 */
public interface ConnectionBuilder  {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\sql\DatabaseMetaData.java
    /**
     * Retrieves whether this database supports sharding.
     * @implSpec
     * The default implementation will return {@code false}
     *
     * @return {@code true} if this database supports sharding;
     *         {@code false} otherwise
     * @exception SQLException if a database access error occurs
     * @since 9
     */
    default boolean supportsSharding() throws SQLException {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\sql\DriverManager.java
    /**
     * Retrieves a Stream with all of the currently loaded JDBC drivers
     * to which the current caller has access.
     *
     * @return the stream of JDBC Drivers loaded by the caller's class loader
     * @since 9
     */
    @CallerSensitive
    public static Stream<Driver> drivers() {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\sql\ShardingKey.java
/**
 * Interface used to indicate that this object represents a Sharding Key. A
 * {@code ShardingKey} instance is only guaranteed to be compatible with the
 * data source instance that it was derived from. A {@code ShardingKey} is
 * created using {@link ShardingKeyBuilder}.
 * <p>
 * The following example illustrates the use of {@link ShardingKeyBuilder} to
 * create a {@code ShardingKey}:
 * <pre>
 * {@code
 *
 *     DataSource ds = new MyDataSource();
 *     ShardingKey shardingKey = ds.createShardingKeyBuilder()
 *                           .subkey("abc", JDBCType.VARCHAR)
 *                           .subkey(94002, JDBCType.INTEGER)
 *                           .build();
 * }
 * </pre>
 * <p>
 *
 * A {@code ShardingKey} may also be used for specifying a
 * {@code superShardingKey}. Databases that support composite Sharding may use a
 * {@code superShardingKey} to specify a additional level of partitioning within
 * the Shard.
 * <p>
 * The following example illustrates the use of {@link ShardingKeyBuilder} to
 * create a {@code superShardingKey} for an eastern region with a
 * {@code ShardingKey} specified for the Pittsburgh branch office:
 * <pre>
 * {@code
 *
 *     DataSource ds = new MyDataSource();
 *     ShardingKey superShardingKey = ds.createShardingKeyBuilder()
 *                           .subkey("EASTERN_REGION", JDBCType.VARCHAR)
 *                           .build();
 *     ShardingKey shardingKey = ds.createShardingKeyBuilder()
 *                           .subkey("PITTSBURGH_BRANCH", JDBCType.VARCHAR)
 *                           .build();
 *     Connection con = ds.createConnectionBuilder()
 *                           .superShardingKey(superShardingKey)
 *                           .shardingKey(shardingKey)
 *                           .build();
 * }
 * </pre>
 *
 * @since 9
 */
public interface ShardingKey {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\time\chrono\Chronology.java
    /**
     * Gets the number of seconds from the epoch of 1970-01-01T00:00:00Z.
     * <p>
     * The number of seconds is calculated using the proleptic-year,
     * month, day-of-month, hour, minute, second, and zoneOffset.
     *
     * @param prolepticYear the chronology proleptic-year
     * @param month the chronology month-of-year
     * @param dayOfMonth the chronology day-of-month
     * @param hour the hour-of-day, from 0 to 23
     * @param minute the minute-of-hour, from 0 to 59
     * @param second the second-of-minute, from 0 to 59
     * @param zoneOffset the zone offset, not null
     * @return the number of seconds relative to 1970-01-01T00:00:00Z, may be negative
     * @throws DateTimeException if any of the values are out of range
     * @since 9
     */
     public default long epochSecond(int prolepticYear, int month, int dayOfMonth,
                                     int hour, int minute, int second, ZoneOffset zoneOffset) {

    /**
     * Gets the number of seconds from the epoch of 1970-01-01T00:00:00Z.
     * <p>
     * The number of seconds is calculated using the era, year-of-era,
     * month, day-of-month, hour, minute, second, and zoneOffset.
     *
     * @param era  the era of the correct type for the chronology, not null
     * @param yearOfEra the chronology year-of-era
     * @param month the chronology month-of-year
     * @param dayOfMonth the chronology day-of-month
     * @param hour the hour-of-day, from 0 to 23
     * @param minute the minute-of-hour, from 0 to 59
     * @param second the second-of-minute, from 0 to 59
     * @param zoneOffset the zone offset, not null
     * @return the number of seconds relative to 1970-01-01T00:00:00Z, may be negative
     * @throws DateTimeException if any of the values are out of range
     * @since 9
     */
     public default long epochSecond(Era era, int yearOfEra, int month, int dayOfMonth,
                                     int hour, int minute, int second, ZoneOffset zoneOffset) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\time\chrono\IsoChronology.java
    /**
     * Gets the number of seconds from the epoch of 1970-01-01T00:00:00Z.
     * <p>
     * The number of seconds is calculated using the year,
     * month, day-of-month, hour, minute, second, and zoneOffset.
     *
     * @param prolepticYear  the year, from MIN_YEAR to MAX_YEAR
     * @param month  the month-of-year, from 1 to 12
     * @param dayOfMonth  the day-of-month, from 1 to 31
     * @param hour  the hour-of-day, from 0 to 23
     * @param minute  the minute-of-hour, from 0 to 59
     * @param second  the second-of-minute, from 0 to 59
     * @param zoneOffset the zone offset, not null
     * @return the number of seconds relative to 1970-01-01T00:00:00Z, may be negative
     * @throws DateTimeException if the value of any argument is out of range,
     *         or if the day-of-month is invalid for the month-of-year
     * @since 9
     */
     @Override
     public long epochSecond(int prolepticYear, int month, int dayOfMonth,
                             int hour, int minute, int second, ZoneOffset zoneOffset) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\time\Clock.java
    /**
     * Obtains a clock that returns the current instant ticking in whole milliseconds
     * using the best available system clock.
     * <p>
     * This clock will always have the nano-of-second field truncated to milliseconds.
     * This ensures that the visible time ticks in whole milliseconds.
     * The underlying clock is the best available system clock, equivalent to
     * using {@link #system(ZoneId)}.
     * <p>
     * Implementations may use a caching strategy for performance reasons.
     * As such, it is possible that the start of the millisecond observed via this
     * clock will be later than that observed directly via the underlying clock.
     * <p>
     * The returned implementation is immutable, thread-safe and {@code Serializable}.
     * It is equivalent to {@code tick(system(zone), Duration.ofMillis(1))}.
     *
     * @param zone  the time-zone to use to convert the instant to date-time, not null
     * @return a clock that ticks in whole milliseconds using the specified zone, not null
     * @since 9
     */
    public static Clock tickMillis(ZoneId zone) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\time\Duration.java
    /**
     * Returns number of whole times a specified Duration occurs within this Duration.
     * <p>
     * This instance is immutable and unaffected by this method call.
     *
     * @param divisor the value to divide the duration by, positive or negative, not null
     * @return number of whole times, rounded toward zero, a specified
     *         {@code Duration} occurs within this Duration, may be negative
     * @throws ArithmeticException if the divisor is zero, or if numeric overflow occurs
     * @since 9
     */
    public long dividedBy(Duration divisor) {

    /**
     * Gets the number of seconds in this duration.
     * <p>
     * This returns the total number of whole seconds in the duration.
     * <p>
     * This instance is immutable and unaffected by this method call.
     *
     * @return the whole seconds part of the length of the duration, positive or negative
     * @since 9
     */
    public long toSeconds() {

    /**
     * Extracts the number of days in the duration.
     * <p>
     * This returns the total number of days in the duration by dividing the
     * number of seconds by 86400.
     * This is based on the standard definition of a day as 24 hours.
     * <p>
     * This instance is immutable and unaffected by this method call.
     *
     * @return the number of days in the duration, may be negative
     * @since 9
     */
    public long toDaysPart(){

    /**
     * Extracts the number of hours part in the duration.
     * <p>
     * This returns the number of remaining hours when dividing {@link #toHours}
     * by hours in a day.
     * This is based on the standard definition of a day as 24 hours.
     * <p>
     * This instance is immutable and unaffected by this method call.
     *
     * @return the number of hours part in the duration, may be negative
     * @since 9
     */
    public int toHoursPart(){

    /**
     * Extracts the number of minutes part in the duration.
     * <p>
     * This returns the number of remaining minutes when dividing {@link #toMinutes}
     * by minutes in an hour.
     * This is based on the standard definition of an hour as 60 minutes.
     * <p>
     * This instance is immutable and unaffected by this method call.
     *
     * @return the number of minutes parts in the duration, may be negative
     * @since 9
     */
    public int toMinutesPart(){

    /**
     * Extracts the number of seconds part in the duration.
     * <p>
     * This returns the remaining seconds when dividing {@link #toSeconds}
     * by seconds in a minute.
     * This is based on the standard definition of a minute as 60 seconds.
     * <p>
     * This instance is immutable and unaffected by this method call.
     *
     * @return the number of seconds parts in the duration, may be negative
     * @since 9
     */
    public int toSecondsPart(){

    /**
     * Extracts the number of milliseconds part of the duration.
     * <p>
     * This returns the milliseconds part by dividing the number of nanoseconds by 1,000,000.
     * The length of the duration is stored using two fields - seconds and nanoseconds.
     * The nanoseconds part is a value from 0 to 999,999,999 that is an adjustment to
     * the length in seconds.
     * The total duration is defined by calling {@link #getNano()} and {@link #getSeconds()}.
     * <p>
     * This instance is immutable and unaffected by this method call.
     *
     * @return the number of milliseconds part of the duration.
     * @since 9
     */
    public int toMillisPart(){

    /**
     * Get the nanoseconds part within seconds of the duration.
     * <p>
     * The length of the duration is stored using two fields - seconds and nanoseconds.
     * The nanoseconds part is a value from 0 to 999,999,999 that is an adjustment to
     * the length in seconds.
     * The total duration is defined by calling {@link #getNano()} and {@link #getSeconds()}.
     * <p>
     * This instance is immutable and unaffected by this method call.
     *
     * @return the nanoseconds within the second part of the length of the duration, from 0 to 999,999,999
     * @since 9
     */
    public int toNanosPart(){

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\time\LocalDate.java
    /**
     * Obtains an instance of {@code LocalDate} from an {@code Instant} and zone ID.
     * <p>
     * This creates a local date based on the specified instant.
     * First, the offset from UTC/Greenwich is obtained using the zone ID and instant,
     * which is simple as there is only one valid offset for each instant.
     * Then, the instant and offset are used to calculate the local date.
     *
     * @param instant  the instant to create the date from, not null
     * @param zone  the time-zone, which may be an offset, not null
     * @return the local date, not null
     * @throws DateTimeException if the result exceeds the supported range
     * @since 9
     */
    public static LocalDate ofInstant(Instant instant, ZoneId zone) {

    /**
     * Returns a sequential ordered stream of dates. The returned stream starts from this date
     * (inclusive) and goes to {@code endExclusive} (exclusive) by an incremental step of 1 day.
     * <p>
     * This method is equivalent to {@code datesUntil(endExclusive, Period.ofDays(1))}.
     *
     * @param endExclusive  the end date, exclusive, not null
     * @return a sequential {@code Stream} for the range of {@code LocalDate} values
     * @throws IllegalArgumentException if end date is before this date
     * @since 9
     */
    public Stream<LocalDate> datesUntil(LocalDate endExclusive) {

    /**
     * Returns a sequential ordered stream of dates by given incremental step. The returned stream
     * starts from this date (inclusive) and goes to {@code endExclusive} (exclusive).
     * <p>
     * The n-th date which appears in the stream is equal to {@code this.plus(step.multipliedBy(n))}
     * (but the result of step multiplication never overflows). For example, if this date is
     * {@code 2015-01-31}, the end date is {@code 2015-05-01} and the step is 1 month, then the
     * stream contains {@code 2015-01-31}, {@code 2015-02-28}, {@code 2015-03-31}, and
     * {@code 2015-04-30}.
     *
     * @param endExclusive  the end date, exclusive, not null
     * @param step  the non-zero, non-negative {@code Period} which represents the step.
     * @return a sequential {@code Stream} for the range of {@code LocalDate} values
     * @throws IllegalArgumentException if step is zero, or {@code step.getDays()} and
     *             {@code step.toTotalMonths()} have opposite sign, or end date is before this date
     *             and step is positive, or end date is after this date and step is negative
     * @since 9
     */
    public Stream<LocalDate> datesUntil(LocalDate endExclusive, Period step) {

    /**
     * Converts this {@code LocalDate} to the number of seconds since the epoch
     * of 1970-01-01T00:00:00Z.
     * <p>
     * This combines this local date with the specified time and
     * offset to calculate the epoch-second value, which is the
     * number of elapsed seconds from 1970-01-01T00:00:00Z.
     * Instants on the time-line after the epoch are positive, earlier
     * are negative.
     *
     * @param time the local time, not null
     * @param offset the zone offset, not null
     * @return the number of seconds since the epoch of 1970-01-01T00:00:00Z, may be negative
     * @since 9
     */
    public long toEpochSecond(LocalTime time, ZoneOffset offset) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\time\LocalTime.java
    /**
     * Obtains an instance of {@code LocalTime} from an {@code Instant} and zone ID.
     * <p>
     * This creates a local time based on the specified instant.
     * First, the offset from UTC/Greenwich is obtained using the zone ID and instant,
     * which is simple as there is only one valid offset for each instant.
     * Then, the instant and offset are used to calculate the local time.
     *
     * @param instant  the instant to create the time from, not null
     * @param zone  the time-zone, which may be an offset, not null
     * @return the local time, not null
     * @since 9
     */
     public static LocalTime ofInstant(Instant instant, ZoneId zone) {

    /**
     * Converts this {@code LocalTime} to the number of seconds since the epoch
     * of 1970-01-01T00:00:00Z.
     * <p>
     * This combines this local time with the specified date and
     * offset to calculate the epoch-second value, which is the
     * number of elapsed seconds from 1970-01-01T00:00:00Z.
     * Instants on the time-line after the epoch are positive, earlier
     * are negative.
     *
     * @param date the local date, not null
     * @param offset the zone offset, not null
     * @return the number of seconds since the epoch of 1970-01-01T00:00:00Z, may be negative
     * @since 9
     */
    public long toEpochSecond(LocalDate date, ZoneOffset offset) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\time\OffsetTime.java
    /**
     * Converts this {@code OffsetTime} to the number of seconds since the epoch
     * of 1970-01-01T00:00:00Z.
     * <p>
     * This combines this offset time with the specified date to calculate the
     * epoch-second value, which is the number of elapsed seconds from
     * 1970-01-01T00:00:00Z.
     * Instants on the time-line after the epoch are positive, earlier
     * are negative.
     *
     * @param date the localdate, not null
     * @return the number of seconds since the epoch of 1970-01-01T00:00:00Z, may be negative
     * @since 9
     */
    public long toEpochSecond(LocalDate date) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\Arrays.java
    /**
     * Returns true if the two specified arrays of longs, over the specified
     * ranges, are <i>equal</i> to one another.
     *
     * <p>Two arrays are considered equal if the number of elements covered by
     * each range is the same, and all corresponding pairs of elements over the
     * specified ranges in the two arrays are equal.  In other words, two arrays
     * are equal if they contain, over the specified ranges, the same elements
     * in the same order.
     *
     * @param a the first array to be tested for equality
     * @param aFromIndex the index (inclusive) of the first element in the
     *                   first array to be tested
     * @param aToIndex the index (exclusive) of the last element in the
     *                 first array to be tested
     * @param b the second array to be tested fro equality
     * @param bFromIndex the index (inclusive) of the first element in the
     *                   second array to be tested
     * @param bToIndex the index (exclusive) of the last element in the
     *                 second array to be tested
     * @return {@code true} if the two arrays, over the specified ranges, are
     *         equal
     * @throws IllegalArgumentException
     *         if {@code aFromIndex > aToIndex} or
     *         if {@code bFromIndex > bToIndex}
     * @throws ArrayIndexOutOfBoundsException
     *         if {@code aFromIndex < 0 or aToIndex > a.length} or
     *         if {@code bFromIndex < 0 or bToIndex > b.length}
     * @throws NullPointerException
     *         if either array is {@code null}
     * @since 9
     */
    public static boolean equals(long[] a, int aFromIndex, int aToIndex,
                                 long[] b, int bFromIndex, int bToIndex) {

    /**
     * Returns true if the two specified arrays of ints, over the specified
     * ranges, are <i>equal</i> to one another.
     *
     * <p>Two arrays are considered equal if the number of elements covered by
     * each range is the same, and all corresponding pairs of elements over the
     * specified ranges in the two arrays are equal.  In other words, two arrays
     * are equal if they contain, over the specified ranges, the same elements
     * in the same order.
     *
     * @param a the first array to be tested for equality
     * @param aFromIndex the index (inclusive) of the first element in the
     *                   first array to be tested
     * @param aToIndex the index (exclusive) of the last element in the
     *                 first array to be tested
     * @param b the second array to be tested fro equality
     * @param bFromIndex the index (inclusive) of the first element in the
     *                   second array to be tested
     * @param bToIndex the index (exclusive) of the last element in the
     *                 second array to be tested
     * @return {@code true} if the two arrays, over the specified ranges, are
     *         equal
     * @throws IllegalArgumentException
     *         if {@code aFromIndex > aToIndex} or
     *         if {@code bFromIndex > bToIndex}
     * @throws ArrayIndexOutOfBoundsException
     *         if {@code aFromIndex < 0 or aToIndex > a.length} or
     *         if {@code bFromIndex < 0 or bToIndex > b.length}
     * @throws NullPointerException
     *         if either array is {@code null}
     * @since 9
     */
    public static boolean equals(int[] a, int aFromIndex, int aToIndex,
                                 int[] b, int bFromIndex, int bToIndex) {

    /**
     * Returns true if the two specified arrays of shorts, over the specified
     * ranges, are <i>equal</i> to one another.
     *
     * <p>Two arrays are considered equal if the number of elements covered by
     * each range is the same, and all corresponding pairs of elements over the
     * specified ranges in the two arrays are equal.  In other words, two arrays
     * are equal if they contain, over the specified ranges, the same elements
     * in the same order.
     *
     * @param a the first array to be tested for equality
     * @param aFromIndex the index (inclusive) of the first element in the
     *                   first array to be tested
     * @param aToIndex the index (exclusive) of the last element in the
     *                 first array to be tested
     * @param b the second array to be tested fro equality
     * @param bFromIndex the index (inclusive) of the first element in the
     *                   second array to be tested
     * @param bToIndex the index (exclusive) of the last element in the
     *                 second array to be tested
     * @return {@code true} if the two arrays, over the specified ranges, are
     *         equal
     * @throws IllegalArgumentException
     *         if {@code aFromIndex > aToIndex} or
     *         if {@code bFromIndex > bToIndex}
     * @throws ArrayIndexOutOfBoundsException
     *         if {@code aFromIndex < 0 or aToIndex > a.length} or
     *         if {@code bFromIndex < 0 or bToIndex > b.length}
     * @throws NullPointerException
     *         if either array is {@code null}
     * @since 9
     */
    public static boolean equals(short[] a, int aFromIndex, int aToIndex,
                                 short[] b, int bFromIndex, int bToIndex) {

    /**
     * Returns true if the two specified arrays of chars, over the specified
     * ranges, are <i>equal</i> to one another.
     *
     * <p>Two arrays are considered equal if the number of elements covered by
     * each range is the same, and all corresponding pairs of elements over the
     * specified ranges in the two arrays are equal.  In other words, two arrays
     * are equal if they contain, over the specified ranges, the same elements
     * in the same order.
     *
     * @param a the first array to be tested for equality
     * @param aFromIndex the index (inclusive) of the first element in the
     *                   first array to be tested
     * @param aToIndex the index (exclusive) of the last element in the
     *                 first array to be tested
     * @param b the second array to be tested fro equality
     * @param bFromIndex the index (inclusive) of the first element in the
     *                   second array to be tested
     * @param bToIndex the index (exclusive) of the last element in the
     *                 second array to be tested
     * @return {@code true} if the two arrays, over the specified ranges, are
     *         equal
     * @throws IllegalArgumentException
     *         if {@code aFromIndex > aToIndex} or
     *         if {@code bFromIndex > bToIndex}
     * @throws ArrayIndexOutOfBoundsException
     *         if {@code aFromIndex < 0 or aToIndex > a.length} or
     *         if {@code bFromIndex < 0 or bToIndex > b.length}
     * @throws NullPointerException
     *         if either array is {@code null}
     * @since 9
     */
    public static boolean equals(char[] a, int aFromIndex, int aToIndex,
                                 char[] b, int bFromIndex, int bToIndex) {

    /**
     * Returns true if the two specified arrays of bytes, over the specified
     * ranges, are <i>equal</i> to one another.
     *
     * <p>Two arrays are considered equal if the number of elements covered by
     * each range is the same, and all corresponding pairs of elements over the
     * specified ranges in the two arrays are equal.  In other words, two arrays
     * are equal if they contain, over the specified ranges, the same elements
     * in the same order.
     *
     * @param a the first array to be tested for equality
     * @param aFromIndex the index (inclusive) of the first element in the
     *                   first array to be tested
     * @param aToIndex the index (exclusive) of the last element in the
     *                 first array to be tested
     * @param b the second array to be tested fro equality
     * @param bFromIndex the index (inclusive) of the first element in the
     *                   second array to be tested
     * @param bToIndex the index (exclusive) of the last element in the
     *                 second array to be tested
     * @return {@code true} if the two arrays, over the specified ranges, are
     *         equal
     * @throws IllegalArgumentException
     *         if {@code aFromIndex > aToIndex} or
     *         if {@code bFromIndex > bToIndex}
     * @throws ArrayIndexOutOfBoundsException
     *         if {@code aFromIndex < 0 or aToIndex > a.length} or
     *         if {@code bFromIndex < 0 or bToIndex > b.length}
     * @throws NullPointerException
     *         if either array is {@code null}
     * @since 9
     */
    public static boolean equals(byte[] a, int aFromIndex, int aToIndex,
                                 byte[] b, int bFromIndex, int bToIndex) {

    /**
     * Returns true if the two specified arrays of booleans, over the specified
     * ranges, are <i>equal</i> to one another.
     *
     * <p>Two arrays are considered equal if the number of elements covered by
     * each range is the same, and all corresponding pairs of elements over the
     * specified ranges in the two arrays are equal.  In other words, two arrays
     * are equal if they contain, over the specified ranges, the same elements
     * in the same order.
     *
     * @param a the first array to be tested for equality
     * @param aFromIndex the index (inclusive) of the first element in the
     *                   first array to be tested
     * @param aToIndex the index (exclusive) of the last element in the
     *                 first array to be tested
     * @param b the second array to be tested fro equality
     * @param bFromIndex the index (inclusive) of the first element in the
     *                   second array to be tested
     * @param bToIndex the index (exclusive) of the last element in the
     *                 second array to be tested
     * @return {@code true} if the two arrays, over the specified ranges, are
     *         equal
     * @throws IllegalArgumentException
     *         if {@code aFromIndex > aToIndex} or
     *         if {@code bFromIndex > bToIndex}
     * @throws ArrayIndexOutOfBoundsException
     *         if {@code aFromIndex < 0 or aToIndex > a.length} or
     *         if {@code bFromIndex < 0 or bToIndex > b.length}
     * @throws NullPointerException
     *         if either array is {@code null}
     * @since 9
     */
    public static boolean equals(boolean[] a, int aFromIndex, int aToIndex,
                                 boolean[] b, int bFromIndex, int bToIndex) {

    /**
     * Returns true if the two specified arrays of doubles, over the specified
     * ranges, are <i>equal</i> to one another.
     *
     * <p>Two arrays are considered equal if the number of elements covered by
     * each range is the same, and all corresponding pairs of elements over the
     * specified ranges in the two arrays are equal.  In other words, two arrays
     * are equal if they contain, over the specified ranges, the same elements
     * in the same order.
     *
     * <p>Two doubles {@code d1} and {@code d2} are considered equal if:
     * <pre>    {@code new Double(d1).equals(new Double(d2))}</pre>
     * (Unlike the {@code ==} operator, this method considers
     * {@code NaN} equals to itself, and 0.0d unequal to -0.0d.)
     *
     * @param a the first array to be tested for equality
     * @param aFromIndex the index (inclusive) of the first element in the
     *                   first array to be tested
     * @param aToIndex the index (exclusive) of the last element in the
     *                 first array to be tested
     * @param b the second array to be tested fro equality
     * @param bFromIndex the index (inclusive) of the first element in the
     *                   second array to be tested
     * @param bToIndex the index (exclusive) of the last element in the
     *                 second array to be tested
     * @return {@code true} if the two arrays, over the specified ranges, are
     *         equal
     * @throws IllegalArgumentException
     *         if {@code aFromIndex > aToIndex} or
     *         if {@code bFromIndex > bToIndex}
     * @throws ArrayIndexOutOfBoundsException
     *         if {@code aFromIndex < 0 or aToIndex > a.length} or
     *         if {@code bFromIndex < 0 or bToIndex > b.length}
     * @throws NullPointerException
     *         if either array is {@code null}
     * @see Double#equals(Object)
     * @since 9
     */
    public static boolean equals(double[] a, int aFromIndex, int aToIndex,
                                 double[] b, int bFromIndex, int bToIndex) {

    /**
     * Returns true if the two specified arrays of floats, over the specified
     * ranges, are <i>equal</i> to one another.
     *
     * <p>Two arrays are considered equal if the number of elements covered by
     * each range is the same, and all corresponding pairs of elements over the
     * specified ranges in the two arrays are equal.  In other words, two arrays
     * are equal if they contain, over the specified ranges, the same elements
     * in the same order.
     *
     * <p>Two floats {@code f1} and {@code f2} are considered equal if:
     * <pre>    {@code new Float(f1).equals(new Float(f2))}</pre>
     * (Unlike the {@code ==} operator, this method considers
     * {@code NaN} equals to itself, and 0.0f unequal to -0.0f.)
     *
     * @param a the first array to be tested for equality
     * @param aFromIndex the index (inclusive) of the first element in the
     *                   first array to be tested
     * @param aToIndex the index (exclusive) of the last element in the
     *                 first array to be tested
     * @param b the second array to be tested fro equality
     * @param bFromIndex the index (inclusive) of the first element in the
     *                   second array to be tested
     * @param bToIndex the index (exclusive) of the last element in the
     *                 second array to be tested
     * @return {@code true} if the two arrays, over the specified ranges, are
     *         equal
     * @throws IllegalArgumentException
     *         if {@code aFromIndex > aToIndex} or
     *         if {@code bFromIndex > bToIndex}
     * @throws ArrayIndexOutOfBoundsException
     *         if {@code aFromIndex < 0 or aToIndex > a.length} or
     *         if {@code bFromIndex < 0 or bToIndex > b.length}
     * @throws NullPointerException
     *         if either array is {@code null}
     * @see Float#equals(Object)
     * @since 9
     */
    public static boolean equals(float[] a, int aFromIndex, int aToIndex,
                                 float[] b, int bFromIndex, int bToIndex) {

    /**
     * Returns true if the two specified arrays of Objects, over the specified
     * ranges, are <i>equal</i> to one another.
     *
     * <p>Two arrays are considered equal if the number of elements covered by
     * each range is the same, and all corresponding pairs of elements over the
     * specified ranges in the two arrays are equal.  In other words, two arrays
     * are equal if they contain, over the specified ranges, the same elements
     * in the same order.
     *
     * <p>Two objects {@code e1} and {@code e2} are considered <i>equal</i> if
     * {@code Objects.equals(e1, e2)}.
     *
     * @param a the first array to be tested for equality
     * @param aFromIndex the index (inclusive) of the first element in the
     *                   first array to be tested
     * @param aToIndex the index (exclusive) of the last element in the
     *                 first array to be tested
     * @param b the second array to be tested fro equality
     * @param bFromIndex the index (inclusive) of the first element in the
     *                   second array to be tested
     * @param bToIndex the index (exclusive) of the last element in the
     *                 second array to be tested
     * @return {@code true} if the two arrays, over the specified ranges, are
     *         equal
     * @throws IllegalArgumentException
     *         if {@code aFromIndex > aToIndex} or
     *         if {@code bFromIndex > bToIndex}
     * @throws ArrayIndexOutOfBoundsException
     *         if {@code aFromIndex < 0 or aToIndex > a.length} or
     *         if {@code bFromIndex < 0 or bToIndex > b.length}
     * @throws NullPointerException
     *         if either array is {@code null}
     * @since 9
     */
    public static boolean equals(Object[] a, int aFromIndex, int aToIndex,
                                 Object[] b, int bFromIndex, int bToIndex) {

    /**
     * Returns {@code true} if the two specified arrays of Objects are
     * <i>equal</i> to one another.
     *
     * <p>Two arrays are considered equal if both arrays contain the same number
     * of elements, and all corresponding pairs of elements in the two arrays
     * are equal.  In other words, the two arrays are equal if they contain the
     * same elements in the same order.  Also, two array references are
     * considered equal if both are {@code null}.
     *
     * <p>Two objects {@code e1} and {@code e2} are considered <i>equal</i> if,
     * given the specified comparator, {@code cmp.compare(e1, e2) == 0}.
     *
     * @param a one array to be tested for equality
     * @param a2 the other array to be tested for equality
     * @param cmp the comparator to compare array elements
     * @param <T> the type of array elements
     * @return {@code true} if the two arrays are equal
     * @throws NullPointerException if the comparator is {@code null}
     * @since 9
     */
    public static <T> boolean equals(T[] a, T[] a2, Comparator<? super T> cmp) {

    /**
     * Returns true if the two specified arrays of Objects, over the specified
     * ranges, are <i>equal</i> to one another.
     *
     * <p>Two arrays are considered equal if the number of elements covered by
     * each range is the same, and all corresponding pairs of elements over the
     * specified ranges in the two arrays are equal.  In other words, two arrays
     * are equal if they contain, over the specified ranges, the same elements
     * in the same order.
     *
     * <p>Two objects {@code e1} and {@code e2} are considered <i>equal</i> if,
     * given the specified comparator, {@code cmp.compare(e1, e2) == 0}.
     *
     * @param a the first array to be tested for equality
     * @param aFromIndex the index (inclusive) of the first element in the
     *                   first array to be tested
     * @param aToIndex the index (exclusive) of the last element in the
     *                 first array to be tested
     * @param b the second array to be tested fro equality
     * @param bFromIndex the index (inclusive) of the first element in the
     *                   second array to be tested
     * @param bToIndex the index (exclusive) of the last element in the
     *                 second array to be tested
     * @param cmp the comparator to compare array elements
     * @param <T> the type of array elements
     * @return {@code true} if the two arrays, over the specified ranges, are
     *         equal
     * @throws IllegalArgumentException
     *         if {@code aFromIndex > aToIndex} or
     *         if {@code bFromIndex > bToIndex}
     * @throws ArrayIndexOutOfBoundsException
     *         if {@code aFromIndex < 0 or aToIndex > a.length} or
     *         if {@code bFromIndex < 0 or bToIndex > b.length}
     * @throws NullPointerException
     *         if either array or the comparator is {@code null}
     * @since 9
     */
    public static <T> boolean equals(T[] a, int aFromIndex, int aToIndex,
                                     T[] b, int bFromIndex, int bToIndex,
                                     Comparator<? super T> cmp) {

    /**
     * Compares two {@code boolean} arrays lexicographically.
     *
     * <p>If the two arrays share a common prefix then the lexicographic
     * comparison is the result of comparing two elements, as if by
     * {@link Boolean#compare(boolean, boolean)}, at an index within the
     * respective arrays that is the prefix length.
     * Otherwise, one array is a proper prefix of the other and, lexicographic
     * comparison is the result of comparing the two array lengths.
     * (See {@link #mismatch(boolean[], boolean[])} for the definition of a
     * common and proper prefix.)
     *
     * <p>A {@code null} array reference is considered lexicographically less
     * than a non-{@code null} array reference.  Two {@code null} array
     * references are considered equal.
     *
     * <p>The comparison is consistent with {@link #equals(boolean[], boolean[]) equals},
     * more specifically the following holds for arrays {@code a} and {@code b}:
     * <pre>{@code
     *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)
     * }</pre>
     *
     * @apiNote
     * <p>This method behaves as if (for non-{@code null} array references):
     * <pre>{@code
     *     int i = Arrays.mismatch(a, b);
     *     if (i >= 0 && i < Math.min(a.length, b.length))
     *         return Boolean.compare(a[i], b[i]);
     *     return a.length - b.length;
     * }</pre>
     *
     * @param a the first array to compare
     * @param b the second array to compare
     * @return the value {@code 0} if the first and second array are equal and
     *         contain the same elements in the same order;
     *         a value less than {@code 0} if the first array is
     *         lexicographically less than the second array; and
     *         a value greater than {@code 0} if the first array is
     *         lexicographically greater than the second array
     * @since 9
     */
    public static int compare(boolean[] a, boolean[] b) {

    /**
     * Compares two {@code boolean} arrays lexicographically over the specified
     * ranges.
     *
     * <p>If the two arrays, over the specified ranges, share a common prefix
     * then the lexicographic comparison is the result of comparing two
     * elements, as if by {@link Boolean#compare(boolean, boolean)}, at a
     * relative index within the respective arrays that is the length of the
     * prefix.
     * Otherwise, one array is a proper prefix of the other and, lexicographic
     * comparison is the result of comparing the two range lengths.
     * (See {@link #mismatch(boolean[], int, int, boolean[], int, int)} for the
     * definition of a common and proper prefix.)
     *
     * <p>The comparison is consistent with
     * {@link #equals(boolean[], int, int, boolean[], int, int) equals}, more
     * specifically the following holds for arrays {@code a} and {@code b} with
     * specified ranges [{@code aFromIndex}, {@code atoIndex}) and
     * [{@code bFromIndex}, {@code btoIndex}) respectively:
     * <pre>{@code
     *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==
     *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)
     * }</pre>
     *
     * @apiNote
     * <p>This method behaves as if:
     * <pre>{@code
     *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,
     *                             b, bFromIndex, bToIndex);
     *     if (i >= 0 && i < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
     *         return Boolean.compare(a[aFromIndex + i], b[bFromIndex + i]);
     *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);
     * }</pre>
     *
     * @param a the first array to compare
     * @param aFromIndex the index (inclusive) of the first element in the
     *                   first array to be compared
     * @param aToIndex the index (exclusive) of the last element in the
     *                 first array to be compared
     * @param b the second array to compare
     * @param bFromIndex the index (inclusive) of the first element in the
     *                   second array to be compared
     * @param bToIndex the index (exclusive) of the last element in the
     *                 second array to be compared
     * @return the value {@code 0} if, over the specified ranges, the first and
     *         second array are equal and contain the same elements in the same
     *         order;
     *         a value less than {@code 0} if, over the specified ranges, the
     *         first array is lexicographically less than the second array; and
     *         a value greater than {@code 0} if, over the specified ranges, the
     *         first array is lexicographically greater than the second array
     * @throws IllegalArgumentException
     *         if {@code aFromIndex > aToIndex} or
     *         if {@code bFromIndex > bToIndex}
     * @throws ArrayIndexOutOfBoundsException
     *         if {@code aFromIndex < 0 or aToIndex > a.length} or
     *         if {@code bFromIndex < 0 or bToIndex > b.length}
     * @throws NullPointerException
     *         if either array is {@code null}
     * @since 9
     */
    public static int compare(boolean[] a, int aFromIndex, int aToIndex,
                              boolean[] b, int bFromIndex, int bToIndex) {

    /**
     * Compares two {@code byte} arrays lexicographically.
     *
     * <p>If the two arrays share a common prefix then the lexicographic
     * comparison is the result of comparing two elements, as if by
     * {@link Byte#compare(byte, byte)}, at an index within the respective
     * arrays that is the prefix length.
     * Otherwise, one array is a proper prefix of the other and, lexicographic
     * comparison is the result of comparing the two array lengths.
     * (See {@link #mismatch(byte[], byte[])} for the definition of a common and
     * proper prefix.)
     *
     * <p>A {@code null} array reference is considered lexicographically less
     * than a non-{@code null} array reference.  Two {@code null} array
     * references are considered equal.
     *
     * <p>The comparison is consistent with {@link #equals(byte[], byte[]) equals},
     * more specifically the following holds for arrays {@code a} and {@code b}:
     * <pre>{@code
     *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)
     * }</pre>
     *
     * @apiNote
     * <p>This method behaves as if (for non-{@code null} array references):
     * <pre>{@code
     *     int i = Arrays.mismatch(a, b);
     *     if (i >= 0 && i < Math.min(a.length, b.length))
     *         return Byte.compare(a[i], b[i]);
     *     return a.length - b.length;
     * }</pre>
     *
     * @param a the first array to compare
     * @param b the second array to compare
     * @return the value {@code 0} if the first and second array are equal and
     *         contain the same elements in the same order;
     *         a value less than {@code 0} if the first array is
     *         lexicographically less than the second array; and
     *         a value greater than {@code 0} if the first array is
     *         lexicographically greater than the second array
     * @since 9
     */
    public static int compare(byte[] a, byte[] b) {

    /**
     * Compares two {@code byte} arrays lexicographically over the specified
     * ranges.
     *
     * <p>If the two arrays, over the specified ranges, share a common prefix
     * then the lexicographic comparison is the result of comparing two
     * elements, as if by {@link Byte#compare(byte, byte)}, at a relative index
     * within the respective arrays that is the length of the prefix.
     * Otherwise, one array is a proper prefix of the other and, lexicographic
     * comparison is the result of comparing the two range lengths.
     * (See {@link #mismatch(byte[], int, int, byte[], int, int)} for the
     * definition of a common and proper prefix.)
     *
     * <p>The comparison is consistent with
     * {@link #equals(byte[], int, int, byte[], int, int) equals}, more
     * specifically the following holds for arrays {@code a} and {@code b} with
     * specified ranges [{@code aFromIndex}, {@code atoIndex}) and
     * [{@code bFromIndex}, {@code btoIndex}) respectively:
     * <pre>{@code
     *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==
     *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)
     * }</pre>
     *
     * @apiNote
     * <p>This method behaves as if:
     * <pre>{@code
     *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,
     *                             b, bFromIndex, bToIndex);
     *     if (i >= 0 && i < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
     *         return Byte.compare(a[aFromIndex + i], b[bFromIndex + i]);
     *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);
     * }</pre>
     *
     * @param a the first array to compare
     * @param aFromIndex the index (inclusive) of the first element in the
     *                   first array to be compared
     * @param aToIndex the index (exclusive) of the last element in the
     *                 first array to be compared
     * @param b the second array to compare
     * @param bFromIndex the index (inclusive) of the first element in the
     *                   second array to be compared
     * @param bToIndex the index (exclusive) of the last element in the
     *                 second array to be compared
     * @return the value {@code 0} if, over the specified ranges, the first and
     *         second array are equal and contain the same elements in the same
     *         order;
     *         a value less than {@code 0} if, over the specified ranges, the
     *         first array is lexicographically less than the second array; and
     *         a value greater than {@code 0} if, over the specified ranges, the
     *         first array is lexicographically greater than the second array
     * @throws IllegalArgumentException
     *         if {@code aFromIndex > aToIndex} or
     *         if {@code bFromIndex > bToIndex}
     * @throws ArrayIndexOutOfBoundsException
     *         if {@code aFromIndex < 0 or aToIndex > a.length} or
     *         if {@code bFromIndex < 0 or bToIndex > b.length}
     * @throws NullPointerException
     *         if either array is {@code null}
     * @since 9
     */
    public static int compare(byte[] a, int aFromIndex, int aToIndex,
                              byte[] b, int bFromIndex, int bToIndex) {

    /**
     * Compares two {@code byte} arrays lexicographically, numerically treating
     * elements as unsigned.
     *
     * <p>If the two arrays share a common prefix then the lexicographic
     * comparison is the result of comparing two elements, as if by
     * {@link Byte#compareUnsigned(byte, byte)}, at an index within the
     * respective arrays that is the prefix length.
     * Otherwise, one array is a proper prefix of the other and, lexicographic
     * comparison is the result of comparing the two array lengths.
     * (See {@link #mismatch(byte[], byte[])} for the definition of a common
     * and proper prefix.)
     *
     * <p>A {@code null} array reference is considered lexicographically less
     * than a non-{@code null} array reference.  Two {@code null} array
     * references are considered equal.
     *
     * @apiNote
     * <p>This method behaves as if (for non-{@code null} array references):
     * <pre>{@code
     *     int i = Arrays.mismatch(a, b);
     *     if (i >= 0 && i < Math.min(a.length, b.length))
     *         return Byte.compareUnsigned(a[i], b[i]);
     *     return a.length - b.length;
     * }</pre>
     *
     * @param a the first array to compare
     * @param b the second array to compare
     * @return the value {@code 0} if the first and second array are
     *         equal and contain the same elements in the same order;
     *         a value less than {@code 0} if the first array is
     *         lexicographically less than the second array; and
     *         a value greater than {@code 0} if the first array is
     *         lexicographically greater than the second array
     * @since 9
     */
    public static int compareUnsigned(byte[] a, byte[] b) {

    /**
     * Compares two {@code byte} arrays lexicographically over the specified
     * ranges, numerically treating elements as unsigned.
     *
     * <p>If the two arrays, over the specified ranges, share a common prefix
     * then the lexicographic comparison is the result of comparing two
     * elements, as if by {@link Byte#compareUnsigned(byte, byte)}, at a
     * relative index within the respective arrays that is the length of the
     * prefix.
     * Otherwise, one array is a proper prefix of the other and, lexicographic
     * comparison is the result of comparing the two range lengths.
     * (See {@link #mismatch(byte[], int, int, byte[], int, int)} for the
     * definition of a common and proper prefix.)
     *
     * @apiNote
     * <p>This method behaves as if:
     * <pre>{@code
     *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,
     *                             b, bFromIndex, bToIndex);
     *     if (i >= 0 && i < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
     *         return Byte.compareUnsigned(a[aFromIndex + i], b[bFromIndex + i]);
     *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);
     * }</pre>
     *
     * @param a the first array to compare
     * @param aFromIndex the index (inclusive) of the first element in the
     *                   first array to be compared
     * @param aToIndex the index (exclusive) of the last element in the
     *                 first array to be compared
     * @param b the second array to compare
     * @param bFromIndex the index (inclusive) of the first element in the
     *                   second array to be compared
     * @param bToIndex the index (exclusive) of the last element in the
     *                 second array to be compared
     * @return the value {@code 0} if, over the specified ranges, the first and
     *         second array are equal and contain the same elements in the same
     *         order;
     *         a value less than {@code 0} if, over the specified ranges, the
     *         first array is lexicographically less than the second array; and
     *         a value greater than {@code 0} if, over the specified ranges, the
     *         first array is lexicographically greater than the second array
     * @throws IllegalArgumentException
     *         if {@code aFromIndex > aToIndex} or
     *         if {@code bFromIndex > bToIndex}
     * @throws ArrayIndexOutOfBoundsException
     *         if {@code aFromIndex < 0 or aToIndex > a.length} or
     *         if {@code bFromIndex < 0 or bToIndex > b.length}
     * @throws NullPointerException
     *         if either array is null
     * @since 9
     */
    public static int compareUnsigned(byte[] a, int aFromIndex, int aToIndex,
                                      byte[] b, int bFromIndex, int bToIndex) {

    /**
     * Compares two {@code short} arrays lexicographically.
     *
     * <p>If the two arrays share a common prefix then the lexicographic
     * comparison is the result of comparing two elements, as if by
     * {@link Short#compare(short, short)}, at an index within the respective
     * arrays that is the prefix length.
     * Otherwise, one array is a proper prefix of the other and, lexicographic
     * comparison is the result of comparing the two array lengths.
     * (See {@link #mismatch(short[], short[])} for the definition of a common
     * and proper prefix.)
     *
     * <p>A {@code null} array reference is considered lexicographically less
     * than a non-{@code null} array reference.  Two {@code null} array
     * references are considered equal.
     *
     * <p>The comparison is consistent with {@link #equals(short[], short[]) equals},
     * more specifically the following holds for arrays {@code a} and {@code b}:
     * <pre>{@code
     *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)
     * }</pre>
     *
     * @apiNote
     * <p>This method behaves as if (for non-{@code null} array references):
     * <pre>{@code
     *     int i = Arrays.mismatch(a, b);
     *     if (i >= 0 && i < Math.min(a.length, b.length))
     *         return Short.compare(a[i], b[i]);
     *     return a.length - b.length;
     * }</pre>
     *
     * @param a the first array to compare
     * @param b the second array to compare
     * @return the value {@code 0} if the first and second array are equal and
     *         contain the same elements in the same order;
     *         a value less than {@code 0} if the first array is
     *         lexicographically less than the second array; and
     *         a value greater than {@code 0} if the first array is
     *         lexicographically greater than the second array
     * @since 9
     */
    public static int compare(short[] a, short[] b) {

    /**
     * Compares two {@code short} arrays lexicographically over the specified
     * ranges.
     *
     * <p>If the two arrays, over the specified ranges, share a common prefix
     * then the lexicographic comparison is the result of comparing two
     * elements, as if by {@link Short#compare(short, short)}, at a relative
     * index within the respective arrays that is the length of the prefix.
     * Otherwise, one array is a proper prefix of the other and, lexicographic
     * comparison is the result of comparing the two range lengths.
     * (See {@link #mismatch(short[], int, int, short[], int, int)} for the
     * definition of a common and proper prefix.)
     *
     * <p>The comparison is consistent with
     * {@link #equals(short[], int, int, short[], int, int) equals}, more
     * specifically the following holds for arrays {@code a} and {@code b} with
     * specified ranges [{@code aFromIndex}, {@code atoIndex}) and
     * [{@code bFromIndex}, {@code btoIndex}) respectively:
     * <pre>{@code
     *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==
     *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)
     * }</pre>
     *
     * @apiNote
     * <p>This method behaves as if:
     * <pre>{@code
     *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,
     *                             b, bFromIndex, bToIndex);
     *     if (i >= 0 && i < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
     *         return Short.compare(a[aFromIndex + i], b[bFromIndex + i]);
     *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);
     * }</pre>
     *
     * @param a the first array to compare
     * @param aFromIndex the index (inclusive) of the first element in the
     *                   first array to be compared
     * @param aToIndex the index (exclusive) of the last element in the
     *                 first array to be compared
     * @param b the second array to compare
     * @param bFromIndex the index (inclusive) of the first element in the
     *                   second array to be compared
     * @param bToIndex the index (exclusive) of the last element in the
     *                 second array to be compared
     * @return the value {@code 0} if, over the specified ranges, the first and
     *         second array are equal and contain the same elements in the same
     *         order;
     *         a value less than {@code 0} if, over the specified ranges, the
     *         first array is lexicographically less than the second array; and
     *         a value greater than {@code 0} if, over the specified ranges, the
     *         first array is lexicographically greater than the second array
     * @throws IllegalArgumentException
     *         if {@code aFromIndex > aToIndex} or
     *         if {@code bFromIndex > bToIndex}
     * @throws ArrayIndexOutOfBoundsException
     *         if {@code aFromIndex < 0 or aToIndex > a.length} or
     *         if {@code bFromIndex < 0 or bToIndex > b.length}
     * @throws NullPointerException
     *         if either array is {@code null}
     * @since 9
     */
    public static int compare(short[] a, int aFromIndex, int aToIndex,
                              short[] b, int bFromIndex, int bToIndex) {

    /**
     * Compares two {@code short} arrays lexicographically, numerically treating
     * elements as unsigned.
     *
     * <p>If the two arrays share a common prefix then the lexicographic
     * comparison is the result of comparing two elements, as if by
     * {@link Short#compareUnsigned(short, short)}, at an index within the
     * respective arrays that is the prefix length.
     * Otherwise, one array is a proper prefix of the other and, lexicographic
     * comparison is the result of comparing the two array lengths.
     * (See {@link #mismatch(short[], short[])} for the definition of a common
     * and proper prefix.)
     *
     * <p>A {@code null} array reference is considered lexicographically less
     * than a non-{@code null} array reference.  Two {@code null} array
     * references are considered equal.
     *
     * @apiNote
     * <p>This method behaves as if (for non-{@code null} array references):
     * <pre>{@code
     *     int i = Arrays.mismatch(a, b);
     *     if (i >= 0 && i < Math.min(a.length, b.length))
     *         return Short.compareUnsigned(a[i], b[i]);
     *     return a.length - b.length;
     * }</pre>
     *
     * @param a the first array to compare
     * @param b the second array to compare
     * @return the value {@code 0} if the first and second array are
     *         equal and contain the same elements in the same order;
     *         a value less than {@code 0} if the first array is
     *         lexicographically less than the second array; and
     *         a value greater than {@code 0} if the first array is
     *         lexicographically greater than the second array
     * @since 9
     */
    public static int compareUnsigned(short[] a, short[] b) {

    /**
     * Compares two {@code short} arrays lexicographically over the specified
     * ranges, numerically treating elements as unsigned.
     *
     * <p>If the two arrays, over the specified ranges, share a common prefix
     * then the lexicographic comparison is the result of comparing two
     * elements, as if by {@link Short#compareUnsigned(short, short)}, at a
     * relative index within the respective arrays that is the length of the
     * prefix.
     * Otherwise, one array is a proper prefix of the other and, lexicographic
     * comparison is the result of comparing the two range lengths.
     * (See {@link #mismatch(short[], int, int, short[], int, int)} for the
     * definition of a common and proper prefix.)
     *
     * @apiNote
     * <p>This method behaves as if:
     * <pre>{@code
     *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,
     *                             b, bFromIndex, bToIndex);
     *     if (i >= 0 && i < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
     *         return Short.compareUnsigned(a[aFromIndex + i], b[bFromIndex + i]);
     *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);
     * }</pre>
     *
     * @param a the first array to compare
     * @param aFromIndex the index (inclusive) of the first element in the
     *                   first array to be compared
     * @param aToIndex the index (exclusive) of the last element in the
     *                 first array to be compared
     * @param b the second array to compare
     * @param bFromIndex the index (inclusive) of the first element in the
     *                   second array to be compared
     * @param bToIndex the index (exclusive) of the last element in the
     *                 second array to be compared
     * @return the value {@code 0} if, over the specified ranges, the first and
     *         second array are equal and contain the same elements in the same
     *         order;
     *         a value less than {@code 0} if, over the specified ranges, the
     *         first array is lexicographically less than the second array; and
     *         a value greater than {@code 0} if, over the specified ranges, the
     *         first array is lexicographically greater than the second array
     * @throws IllegalArgumentException
     *         if {@code aFromIndex > aToIndex} or
     *         if {@code bFromIndex > bToIndex}
     * @throws ArrayIndexOutOfBoundsException
     *         if {@code aFromIndex < 0 or aToIndex > a.length} or
     *         if {@code bFromIndex < 0 or bToIndex > b.length}
     * @throws NullPointerException
     *         if either array is null
     * @since 9
     */
    public static int compareUnsigned(short[] a, int aFromIndex, int aToIndex,
                                      short[] b, int bFromIndex, int bToIndex) {

    /**
     * Compares two {@code char} arrays lexicographically.
     *
     * <p>If the two arrays share a common prefix then the lexicographic
     * comparison is the result of comparing two elements, as if by
     * {@link Character#compare(char, char)}, at an index within the respective
     * arrays that is the prefix length.
     * Otherwise, one array is a proper prefix of the other and, lexicographic
     * comparison is the result of comparing the two array lengths.
     * (See {@link #mismatch(char[], char[])} for the definition of a common and
     * proper prefix.)
     *
     * <p>A {@code null} array reference is considered lexicographically less
     * than a non-{@code null} array reference.  Two {@code null} array
     * references are considered equal.
     *
     * <p>The comparison is consistent with {@link #equals(char[], char[]) equals},
     * more specifically the following holds for arrays {@code a} and {@code b}:
     * <pre>{@code
     *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)
     * }</pre>
     *
     * @apiNote
     * <p>This method behaves as if (for non-{@code null} array references):
     * <pre>{@code
     *     int i = Arrays.mismatch(a, b);
     *     if (i >= 0 && i < Math.min(a.length, b.length))
     *         return Character.compare(a[i], b[i]);
     *     return a.length - b.length;
     * }</pre>
     *
     * @param a the first array to compare
     * @param b the second array to compare
     * @return the value {@code 0} if the first and second array are equal and
     *         contain the same elements in the same order;
     *         a value less than {@code 0} if the first array is
     *         lexicographically less than the second array; and
     *         a value greater than {@code 0} if the first array is
     *         lexicographically greater than the second array
     * @since 9
     */
    public static int compare(char[] a, char[] b) {

    /**
     * Compares two {@code char} arrays lexicographically over the specified
     * ranges.
     *
     * <p>If the two arrays, over the specified ranges, share a common prefix
     * then the lexicographic comparison is the result of comparing two
     * elements, as if by {@link Character#compare(char, char)}, at a relative
     * index within the respective arrays that is the length of the prefix.
     * Otherwise, one array is a proper prefix of the other and, lexicographic
     * comparison is the result of comparing the two range lengths.
     * (See {@link #mismatch(char[], int, int, char[], int, int)} for the
     * definition of a common and proper prefix.)
     *
     * <p>The comparison is consistent with
     * {@link #equals(char[], int, int, char[], int, int) equals}, more
     * specifically the following holds for arrays {@code a} and {@code b} with
     * specified ranges [{@code aFromIndex}, {@code atoIndex}) and
     * [{@code bFromIndex}, {@code btoIndex}) respectively:
     * <pre>{@code
     *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==
     *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)
     * }</pre>
     *
     * @apiNote
     * <p>This method behaves as if:
     * <pre>{@code
     *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,
     *                             b, bFromIndex, bToIndex);
     *     if (i >= 0 && i < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
     *         return Character.compare(a[aFromIndex + i], b[bFromIndex + i]);
     *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);
     * }</pre>
     *
     * @param a the first array to compare
     * @param aFromIndex the index (inclusive) of the first element in the
     *                   first array to be compared
     * @param aToIndex the index (exclusive) of the last element in the
     *                 first array to be compared
     * @param b the second array to compare
     * @param bFromIndex the index (inclusive) of the first element in the
     *                   second array to be compared
     * @param bToIndex the index (exclusive) of the last element in the
     *                 second array to be compared
     * @return the value {@code 0} if, over the specified ranges, the first and
     *         second array are equal and contain the same elements in the same
     *         order;
     *         a value less than {@code 0} if, over the specified ranges, the
     *         first array is lexicographically less than the second array; and
     *         a value greater than {@code 0} if, over the specified ranges, the
     *         first array is lexicographically greater than the second array
     * @throws IllegalArgumentException
     *         if {@code aFromIndex > aToIndex} or
     *         if {@code bFromIndex > bToIndex}
     * @throws ArrayIndexOutOfBoundsException
     *         if {@code aFromIndex < 0 or aToIndex > a.length} or
     *         if {@code bFromIndex < 0 or bToIndex > b.length}
     * @throws NullPointerException
     *         if either array is {@code null}
     * @since 9
     */
    public static int compare(char[] a, int aFromIndex, int aToIndex,
                              char[] b, int bFromIndex, int bToIndex) {

    /**
     * Compares two {@code int} arrays lexicographically.
     *
     * <p>If the two arrays share a common prefix then the lexicographic
     * comparison is the result of comparing two elements, as if by
     * {@link Integer#compare(int, int)}, at an index within the respective
     * arrays that is the prefix length.
     * Otherwise, one array is a proper prefix of the other and, lexicographic
     * comparison is the result of comparing the two array lengths.
     * (See {@link #mismatch(int[], int[])} for the definition of a common and
     * proper prefix.)
     *
     * <p>A {@code null} array reference is considered lexicographically less
     * than a non-{@code null} array reference.  Two {@code null} array
     * references are considered equal.
     *
     * <p>The comparison is consistent with {@link #equals(int[], int[]) equals},
     * more specifically the following holds for arrays {@code a} and {@code b}:
     * <pre>{@code
     *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)
     * }</pre>
     *
     * @apiNote
     * <p>This method behaves as if (for non-{@code null} array references):
     * <pre>{@code
     *     int i = Arrays.mismatch(a, b);
     *     if (i >= 0 && i < Math.min(a.length, b.length))
     *         return Integer.compare(a[i], b[i]);
     *     return a.length - b.length;
     * }</pre>
     *
     * @param a the first array to compare
     * @param b the second array to compare
     * @return the value {@code 0} if the first and second array are equal and
     *         contain the same elements in the same order;
     *         a value less than {@code 0} if the first array is
     *         lexicographically less than the second array; and
     *         a value greater than {@code 0} if the first array is
     *         lexicographically greater than the second array
     * @since 9
     */
    public static int compare(int[] a, int[] b) {

    /**
     * Compares two {@code int} arrays lexicographically over the specified
     * ranges.
     *
     * <p>If the two arrays, over the specified ranges, share a common prefix
     * then the lexicographic comparison is the result of comparing two
     * elements, as if by {@link Integer#compare(int, int)}, at a relative index
     * within the respective arrays that is the length of the prefix.
     * Otherwise, one array is a proper prefix of the other and, lexicographic
     * comparison is the result of comparing the two range lengths.
     * (See {@link #mismatch(int[], int, int, int[], int, int)} for the
     * definition of a common and proper prefix.)
     *
     * <p>The comparison is consistent with
     * {@link #equals(int[], int, int, int[], int, int) equals}, more
     * specifically the following holds for arrays {@code a} and {@code b} with
     * specified ranges [{@code aFromIndex}, {@code atoIndex}) and
     * [{@code bFromIndex}, {@code btoIndex}) respectively:
     * <pre>{@code
     *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==
     *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)
     * }</pre>
     *
     * @apiNote
     * <p>This method behaves as if:
     * <pre>{@code
     *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,
     *                             b, bFromIndex, bToIndex);
     *     if (i >= 0 && i < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
     *         return Integer.compare(a[aFromIndex + i], b[bFromIndex + i]);
     *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);
     * }</pre>
     *
     * @param a the first array to compare
     * @param aFromIndex the index (inclusive) of the first element in the
     *                   first array to be compared
     * @param aToIndex the index (exclusive) of the last element in the
     *                 first array to be compared
     * @param b the second array to compare
     * @param bFromIndex the index (inclusive) of the first element in the
     *                   second array to be compared
     * @param bToIndex the index (exclusive) of the last element in the
     *                 second array to be compared
     * @return the value {@code 0} if, over the specified ranges, the first and
     *         second array are equal and contain the same elements in the same
     *         order;
     *         a value less than {@code 0} if, over the specified ranges, the
     *         first array is lexicographically less than the second array; and
     *         a value greater than {@code 0} if, over the specified ranges, the
     *         first array is lexicographically greater than the second array
     * @throws IllegalArgumentException
     *         if {@code aFromIndex > aToIndex} or
     *         if {@code bFromIndex > bToIndex}
     * @throws ArrayIndexOutOfBoundsException
     *         if {@code aFromIndex < 0 or aToIndex > a.length} or
     *         if {@code bFromIndex < 0 or bToIndex > b.length}
     * @throws NullPointerException
     *         if either array is {@code null}
     * @since 9
     */
    public static int compare(int[] a, int aFromIndex, int aToIndex,
                              int[] b, int bFromIndex, int bToIndex) {

    /**
     * Compares two {@code int} arrays lexicographically, numerically treating
     * elements as unsigned.
     *
     * <p>If the two arrays share a common prefix then the lexicographic
     * comparison is the result of comparing two elements, as if by
     * {@link Integer#compareUnsigned(int, int)}, at an index within the
     * respective arrays that is the prefix length.
     * Otherwise, one array is a proper prefix of the other and, lexicographic
     * comparison is the result of comparing the two array lengths.
     * (See {@link #mismatch(int[], int[])} for the definition of a common
     * and proper prefix.)
     *
     * <p>A {@code null} array reference is considered lexicographically less
     * than a non-{@code null} array reference.  Two {@code null} array
     * references are considered equal.
     *
     * @apiNote
     * <p>This method behaves as if (for non-{@code null} array references):
     * <pre>{@code
     *     int i = Arrays.mismatch(a, b);
     *     if (i >= 0 && i < Math.min(a.length, b.length))
     *         return Integer.compareUnsigned(a[i], b[i]);
     *     return a.length - b.length;
     * }</pre>
     *
     * @param a the first array to compare
     * @param b the second array to compare
     * @return the value {@code 0} if the first and second array are
     *         equal and contain the same elements in the same order;
     *         a value less than {@code 0} if the first array is
     *         lexicographically less than the second array; and
     *         a value greater than {@code 0} if the first array is
     *         lexicographically greater than the second array
     * @since 9
     */
    public static int compareUnsigned(int[] a, int[] b) {

    /**
     * Compares two {@code int} arrays lexicographically over the specified
     * ranges, numerically treating elements as unsigned.
     *
     * <p>If the two arrays, over the specified ranges, share a common prefix
     * then the lexicographic comparison is the result of comparing two
     * elements, as if by {@link Integer#compareUnsigned(int, int)}, at a
     * relative index within the respective arrays that is the length of the
     * prefix.
     * Otherwise, one array is a proper prefix of the other and, lexicographic
     * comparison is the result of comparing the two range lengths.
     * (See {@link #mismatch(int[], int, int, int[], int, int)} for the
     * definition of a common and proper prefix.)
     *
     * @apiNote
     * <p>This method behaves as if:
     * <pre>{@code
     *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,
     *                             b, bFromIndex, bToIndex);
     *     if (i >= 0 && i < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
     *         return Integer.compareUnsigned(a[aFromIndex + i], b[bFromIndex + i]);
     *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);
     * }</pre>
     *
     * @param a the first array to compare
     * @param aFromIndex the index (inclusive) of the first element in the
     *                   first array to be compared
     * @param aToIndex the index (exclusive) of the last element in the
     *                 first array to be compared
     * @param b the second array to compare
     * @param bFromIndex the index (inclusive) of the first element in the
     *                   second array to be compared
     * @param bToIndex the index (exclusive) of the last element in the
     *                 second array to be compared
     * @return the value {@code 0} if, over the specified ranges, the first and
     *         second array are equal and contain the same elements in the same
     *         order;
     *         a value less than {@code 0} if, over the specified ranges, the
     *         first array is lexicographically less than the second array; and
     *         a value greater than {@code 0} if, over the specified ranges, the
     *         first array is lexicographically greater than the second array
     * @throws IllegalArgumentException
     *         if {@code aFromIndex > aToIndex} or
     *         if {@code bFromIndex > bToIndex}
     * @throws ArrayIndexOutOfBoundsException
     *         if {@code aFromIndex < 0 or aToIndex > a.length} or
     *         if {@code bFromIndex < 0 or bToIndex > b.length}
     * @throws NullPointerException
     *         if either array is null
     * @since 9
     */
    public static int compareUnsigned(int[] a, int aFromIndex, int aToIndex,
                                      int[] b, int bFromIndex, int bToIndex) {

    /**
     * Compares two {@code long} arrays lexicographically.
     *
     * <p>If the two arrays share a common prefix then the lexicographic
     * comparison is the result of comparing two elements, as if by
     * {@link Long#compare(long, long)}, at an index within the respective
     * arrays that is the prefix length.
     * Otherwise, one array is a proper prefix of the other and, lexicographic
     * comparison is the result of comparing the two array lengths.
     * (See {@link #mismatch(long[], long[])} for the definition of a common and
     * proper prefix.)
     *
     * <p>A {@code null} array reference is considered lexicographically less
     * than a non-{@code null} array reference.  Two {@code null} array
     * references are considered equal.
     *
     * <p>The comparison is consistent with {@link #equals(long[], long[]) equals},
     * more specifically the following holds for arrays {@code a} and {@code b}:
     * <pre>{@code
     *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)
     * }</pre>
     *
     * @apiNote
     * <p>This method behaves as if (for non-{@code null} array references):
     * <pre>{@code
     *     int i = Arrays.mismatch(a, b);
     *     if (i >= 0 && i < Math.min(a.length, b.length))
     *         return Long.compare(a[i], b[i]);
     *     return a.length - b.length;
     * }</pre>
     *
     * @param a the first array to compare
     * @param b the second array to compare
     * @return the value {@code 0} if the first and second array are equal and
     *         contain the same elements in the same order;
     *         a value less than {@code 0} if the first array is
     *         lexicographically less than the second array; and
     *         a value greater than {@code 0} if the first array is
     *         lexicographically greater than the second array
     * @since 9
     */
    public static int compare(long[] a, long[] b) {

    /**
     * Compares two {@code long} arrays lexicographically over the specified
     * ranges.
     *
     * <p>If the two arrays, over the specified ranges, share a common prefix
     * then the lexicographic comparison is the result of comparing two
     * elements, as if by {@link Long#compare(long, long)}, at a relative index
     * within the respective arrays that is the length of the prefix.
     * Otherwise, one array is a proper prefix of the other and, lexicographic
     * comparison is the result of comparing the two range lengths.
     * (See {@link #mismatch(long[], int, int, long[], int, int)} for the
     * definition of a common and proper prefix.)
     *
     * <p>The comparison is consistent with
     * {@link #equals(long[], int, int, long[], int, int) equals}, more
     * specifically the following holds for arrays {@code a} and {@code b} with
     * specified ranges [{@code aFromIndex}, {@code atoIndex}) and
     * [{@code bFromIndex}, {@code btoIndex}) respectively:
     * <pre>{@code
     *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==
     *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)
     * }</pre>
     *
     * @apiNote
     * <p>This method behaves as if:
     * <pre>{@code
     *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,
     *                             b, bFromIndex, bToIndex);
     *     if (i >= 0 && i < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
     *         return Long.compare(a[aFromIndex + i], b[bFromIndex + i]);
     *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);
     * }</pre>
     *
     * @param a the first array to compare
     * @param aFromIndex the index (inclusive) of the first element in the
     *                   first array to be compared
     * @param aToIndex the index (exclusive) of the last element in the
     *                 first array to be compared
     * @param b the second array to compare
     * @param bFromIndex the index (inclusive) of the first element in the
     *                   second array to be compared
     * @param bToIndex the index (exclusive) of the last element in the
     *                 second array to be compared
     * @return the value {@code 0} if, over the specified ranges, the first and
     *         second array are equal and contain the same elements in the same
     *         order;
     *         a value less than {@code 0} if, over the specified ranges, the
     *         first array is lexicographically less than the second array; and
     *         a value greater than {@code 0} if, over the specified ranges, the
     *         first array is lexicographically greater than the second array
     * @throws IllegalArgumentException
     *         if {@code aFromIndex > aToIndex} or
     *         if {@code bFromIndex > bToIndex}
     * @throws ArrayIndexOutOfBoundsException
     *         if {@code aFromIndex < 0 or aToIndex > a.length} or
     *         if {@code bFromIndex < 0 or bToIndex > b.length}
     * @throws NullPointerException
     *         if either array is {@code null}
     * @since 9
     */
    public static int compare(long[] a, int aFromIndex, int aToIndex,
                              long[] b, int bFromIndex, int bToIndex) {

    /**
     * Compares two {@code long} arrays lexicographically, numerically treating
     * elements as unsigned.
     *
     * <p>If the two arrays share a common prefix then the lexicographic
     * comparison is the result of comparing two elements, as if by
     * {@link Long#compareUnsigned(long, long)}, at an index within the
     * respective arrays that is the prefix length.
     * Otherwise, one array is a proper prefix of the other and, lexicographic
     * comparison is the result of comparing the two array lengths.
     * (See {@link #mismatch(long[], long[])} for the definition of a common
     * and proper prefix.)
     *
     * <p>A {@code null} array reference is considered lexicographically less
     * than a non-{@code null} array reference.  Two {@code null} array
     * references are considered equal.
     *
     * @apiNote
     * <p>This method behaves as if (for non-{@code null} array references):
     * <pre>{@code
     *     int i = Arrays.mismatch(a, b);
     *     if (i >= 0 && i < Math.min(a.length, b.length))
     *         return Long.compareUnsigned(a[i], b[i]);
     *     return a.length - b.length;
     * }</pre>
     *
     * @param a the first array to compare
     * @param b the second array to compare
     * @return the value {@code 0} if the first and second array are
     *         equal and contain the same elements in the same order;
     *         a value less than {@code 0} if the first array is
     *         lexicographically less than the second array; and
     *         a value greater than {@code 0} if the first array is
     *         lexicographically greater than the second array
     * @since 9
     */
    public static int compareUnsigned(long[] a, long[] b) {

    /**
     * Compares two {@code long} arrays lexicographically over the specified
     * ranges, numerically treating elements as unsigned.
     *
     * <p>If the two arrays, over the specified ranges, share a common prefix
     * then the lexicographic comparison is the result of comparing two
     * elements, as if by {@link Long#compareUnsigned(long, long)}, at a
     * relative index within the respective arrays that is the length of the
     * prefix.
     * Otherwise, one array is a proper prefix of the other and, lexicographic
     * comparison is the result of comparing the two range lengths.
     * (See {@link #mismatch(long[], int, int, long[], int, int)} for the
     * definition of a common and proper prefix.)
     *
     * @apiNote
     * <p>This method behaves as if:
     * <pre>{@code
     *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,
     *                             b, bFromIndex, bToIndex);
     *     if (i >= 0 && i < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
     *         return Long.compareUnsigned(a[aFromIndex + i], b[bFromIndex + i]);
     *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);
     * }</pre>
     *
     * @param a the first array to compare
     * @param aFromIndex the index (inclusive) of the first element in the
     *                   first array to be compared
     * @param aToIndex the index (exclusive) of the last element in the
     *                 first array to be compared
     * @param b the second array to compare
     * @param bFromIndex the index (inclusive) of the first element in the
     *                   second array to be compared
     * @param bToIndex the index (exclusive) of the last element in the
     *                 second array to be compared
     * @return the value {@code 0} if, over the specified ranges, the first and
     *         second array are equal and contain the same elements in the same
     *         order;
     *         a value less than {@code 0} if, over the specified ranges, the
     *         first array is lexicographically less than the second array; and
     *         a value greater than {@code 0} if, over the specified ranges, the
     *         first array is lexicographically greater than the second array
     * @throws IllegalArgumentException
     *         if {@code aFromIndex > aToIndex} or
     *         if {@code bFromIndex > bToIndex}
     * @throws ArrayIndexOutOfBoundsException
     *         if {@code aFromIndex < 0 or aToIndex > a.length} or
     *         if {@code bFromIndex < 0 or bToIndex > b.length}
     * @throws NullPointerException
     *         if either array is null
     * @since 9
     */
    public static int compareUnsigned(long[] a, int aFromIndex, int aToIndex,
                                      long[] b, int bFromIndex, int bToIndex) {

    /**
     * Compares two {@code float} arrays lexicographically.
     *
     * <p>If the two arrays share a common prefix then the lexicographic
     * comparison is the result of comparing two elements, as if by
     * {@link Float#compare(float, float)}, at an index within the respective
     * arrays that is the prefix length.
     * Otherwise, one array is a proper prefix of the other and, lexicographic
     * comparison is the result of comparing the two array lengths.
     * (See {@link #mismatch(float[], float[])} for the definition of a common
     * and proper prefix.)
     *
     * <p>A {@code null} array reference is considered lexicographically less
     * than a non-{@code null} array reference.  Two {@code null} array
     * references are considered equal.
     *
     * <p>The comparison is consistent with {@link #equals(float[], float[]) equals},
     * more specifically the following holds for arrays {@code a} and {@code b}:
     * <pre>{@code
     *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)
     * }</pre>
     *
     * @apiNote
     * <p>This method behaves as if (for non-{@code null} array references):
     * <pre>{@code
     *     int i = Arrays.mismatch(a, b);
     *     if (i >= 0 && i < Math.min(a.length, b.length))
     *         return Float.compare(a[i], b[i]);
     *     return a.length - b.length;
     * }</pre>
     *
     * @param a the first array to compare
     * @param b the second array to compare
     * @return the value {@code 0} if the first and second array are equal and
     *         contain the same elements in the same order;
     *         a value less than {@code 0} if the first array is
     *         lexicographically less than the second array; and
     *         a value greater than {@code 0} if the first array is
     *         lexicographically greater than the second array
     * @since 9
     */
    public static int compare(float[] a, float[] b) {

    /**
     * Compares two {@code float} arrays lexicographically over the specified
     * ranges.
     *
     * <p>If the two arrays, over the specified ranges, share a common prefix
     * then the lexicographic comparison is the result of comparing two
     * elements, as if by {@link Float#compare(float, float)}, at a relative
     * index within the respective arrays that is the length of the prefix.
     * Otherwise, one array is a proper prefix of the other and, lexicographic
     * comparison is the result of comparing the two range lengths.
     * (See {@link #mismatch(float[], int, int, float[], int, int)} for the
     * definition of a common and proper prefix.)
     *
     * <p>The comparison is consistent with
     * {@link #equals(float[], int, int, float[], int, int) equals}, more
     * specifically the following holds for arrays {@code a} and {@code b} with
     * specified ranges [{@code aFromIndex}, {@code atoIndex}) and
     * [{@code bFromIndex}, {@code btoIndex}) respectively:
     * <pre>{@code
     *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==
     *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)
     * }</pre>
     *
     * @apiNote
     * <p>This method behaves as if:
     * <pre>{@code
     *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,
     *                             b, bFromIndex, bToIndex);
     *     if (i >= 0 && i < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
     *         return Float.compare(a[aFromIndex + i], b[bFromIndex + i]);
     *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);
     * }</pre>
     *
     * @param a the first array to compare
     * @param aFromIndex the index (inclusive) of the first element in the
     *                   first array to be compared
     * @param aToIndex the index (exclusive) of the last element in the
     *                 first array to be compared
     * @param b the second array to compare
     * @param bFromIndex the index (inclusive) of the first element in the
     *                   second array to be compared
     * @param bToIndex the index (exclusive) of the last element in the
     *                 second array to be compared
     * @return the value {@code 0} if, over the specified ranges, the first and
     *         second array are equal and contain the same elements in the same
     *         order;
     *         a value less than {@code 0} if, over the specified ranges, the
     *         first array is lexicographically less than the second array; and
     *         a value greater than {@code 0} if, over the specified ranges, the
     *         first array is lexicographically greater than the second array
     * @throws IllegalArgumentException
     *         if {@code aFromIndex > aToIndex} or
     *         if {@code bFromIndex > bToIndex}
     * @throws ArrayIndexOutOfBoundsException
     *         if {@code aFromIndex < 0 or aToIndex > a.length} or
     *         if {@code bFromIndex < 0 or bToIndex > b.length}
     * @throws NullPointerException
     *         if either array is {@code null}
     * @since 9
     */
    public static int compare(float[] a, int aFromIndex, int aToIndex,
                              float[] b, int bFromIndex, int bToIndex) {

    /**
     * Compares two {@code double} arrays lexicographically.
     *
     * <p>If the two arrays share a common prefix then the lexicographic
     * comparison is the result of comparing two elements, as if by
     * {@link Double#compare(double, double)}, at an index within the respective
     * arrays that is the prefix length.
     * Otherwise, one array is a proper prefix of the other and, lexicographic
     * comparison is the result of comparing the two array lengths.
     * (See {@link #mismatch(double[], double[])} for the definition of a common
     * and proper prefix.)
     *
     * <p>A {@code null} array reference is considered lexicographically less
     * than a non-{@code null} array reference.  Two {@code null} array
     * references are considered equal.
     *
     * <p>The comparison is consistent with {@link #equals(double[], double[]) equals},
     * more specifically the following holds for arrays {@code a} and {@code b}:
     * <pre>{@code
     *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)
     * }</pre>
     *
     * @apiNote
     * <p>This method behaves as if (for non-{@code null} array references):
     * <pre>{@code
     *     int i = Arrays.mismatch(a, b);
     *     if (i >= 0 && i < Math.min(a.length, b.length))
     *         return Double.compare(a[i], b[i]);
     *     return a.length - b.length;
     * }</pre>
     *
     * @param a the first array to compare
     * @param b the second array to compare
     * @return the value {@code 0} if the first and second array are equal and
     *         contain the same elements in the same order;
     *         a value less than {@code 0} if the first array is
     *         lexicographically less than the second array; and
     *         a value greater than {@code 0} if the first array is
     *         lexicographically greater than the second array
     * @since 9
     */
    public static int compare(double[] a, double[] b) {

    /**
     * Compares two {@code double} arrays lexicographically over the specified
     * ranges.
     *
     * <p>If the two arrays, over the specified ranges, share a common prefix
     * then the lexicographic comparison is the result of comparing two
     * elements, as if by {@link Double#compare(double, double)}, at a relative
     * index within the respective arrays that is the length of the prefix.
     * Otherwise, one array is a proper prefix of the other and, lexicographic
     * comparison is the result of comparing the two range lengths.
     * (See {@link #mismatch(double[], int, int, double[], int, int)} for the
     * definition of a common and proper prefix.)
     *
     * <p>The comparison is consistent with
     * {@link #equals(double[], int, int, double[], int, int) equals}, more
     * specifically the following holds for arrays {@code a} and {@code b} with
     * specified ranges [{@code aFromIndex}, {@code atoIndex}) and
     * [{@code bFromIndex}, {@code btoIndex}) respectively:
     * <pre>{@code
     *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==
     *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)
     * }</pre>
     *
     * @apiNote
     * <p>This method behaves as if:
     * <pre>{@code
     *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,
     *                             b, bFromIndex, bToIndex);
     *     if (i >= 0 && i < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
     *         return Double.compare(a[aFromIndex + i], b[bFromIndex + i]);
     *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);
     * }</pre>
     *
     * @param a the first array to compare
     * @param aFromIndex the index (inclusive) of the first element in the
     *                   first array to be compared
     * @param aToIndex the index (exclusive) of the last element in the
     *                 first array to be compared
     * @param b the second array to compare
     * @param bFromIndex the index (inclusive) of the first element in the
     *                   second array to be compared
     * @param bToIndex the index (exclusive) of the last element in the
     *                 second array to be compared
     * @return the value {@code 0} if, over the specified ranges, the first and
     *         second array are equal and contain the same elements in the same
     *         order;
     *         a value less than {@code 0} if, over the specified ranges, the
     *         first array is lexicographically less than the second array; and
     *         a value greater than {@code 0} if, over the specified ranges, the
     *         first array is lexicographically greater than the second array
     * @throws IllegalArgumentException
     *         if {@code aFromIndex > aToIndex} or
     *         if {@code bFromIndex > bToIndex}
     * @throws ArrayIndexOutOfBoundsException
     *         if {@code aFromIndex < 0 or aToIndex > a.length} or
     *         if {@code bFromIndex < 0 or bToIndex > b.length}
     * @throws NullPointerException
     *         if either array is {@code null}
     * @since 9
     */
    public static int compare(double[] a, int aFromIndex, int aToIndex,
                              double[] b, int bFromIndex, int bToIndex) {

    /**
     * Compares two {@code Object} arrays, within comparable elements,
     * lexicographically.
     *
     * <p>If the two arrays share a common prefix then the lexicographic
     * comparison is the result of comparing two elements of type {@code T} at
     * an index {@code i} within the respective arrays that is the prefix
     * length, as if by:
     * <pre>{@code
     *     Comparator.nullsFirst(Comparator.<T>naturalOrder()).
     *         compare(a[i], b[i])
     * }</pre>
     * Otherwise, one array is a proper prefix of the other and, lexicographic
     * comparison is the result of comparing the two array lengths.
     * (See {@link #mismatch(Object[], Object[])} for the definition of a common
     * and proper prefix.)
     *
     * <p>A {@code null} array reference is considered lexicographically less
     * than a non-{@code null} array reference.  Two {@code null} array
     * references are considered equal.
     * A {@code null} array element is considered lexicographically than a
     * non-{@code null} array element.  Two {@code null} array elements are
     * considered equal.
     *
     * <p>The comparison is consistent with {@link #equals(Object[], Object[]) equals},
     * more specifically the following holds for arrays {@code a} and {@code b}:
     * <pre>{@code
     *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)
     * }</pre>
     *
     * @apiNote
     * <p>This method behaves as if (for non-{@code null} array references
     * and elements):
     * <pre>{@code
     *     int i = Arrays.mismatch(a, b);
     *     if (i >= 0 && i < Math.min(a.length, b.length))
     *         return a[i].compareTo(b[i]);
     *     return a.length - b.length;
     * }</pre>
     *
     * @param a the first array to compare
     * @param b the second array to compare
     * @param <T> the type of comparable array elements
     * @return the value {@code 0} if the first and second array are equal and
     *         contain the same elements in the same order;
     *         a value less than {@code 0} if the first array is
     *         lexicographically less than the second array; and
     *         a value greater than {@code 0} if the first array is
     *         lexicographically greater than the second array
     * @since 9
     */
    public static <T extends Comparable<? super T>> int compare(T[] a, T[] b) {

    /**
     * Compares two {@code Object} arrays lexicographically over the specified
     * ranges.
     *
     * <p>If the two arrays, over the specified ranges, share a common prefix
     * then the lexicographic comparison is the result of comparing two
     * elements of type {@code T} at a relative index {@code i} within the
     * respective arrays that is the prefix length, as if by:
     * <pre>{@code
     *     Comparator.nullsFirst(Comparator.<T>naturalOrder()).
     *         compare(a[aFromIndex + i, b[bFromIndex + i])
     * }</pre>
     * Otherwise, one array is a proper prefix of the other and, lexicographic
     * comparison is the result of comparing the two range lengths.
     * (See {@link #mismatch(Object[], int, int, Object[], int, int)} for the
     * definition of a common and proper prefix.)
     *
     * <p>The comparison is consistent with
     * {@link #equals(Object[], int, int, Object[], int, int) equals}, more
     * specifically the following holds for arrays {@code a} and {@code b} with
     * specified ranges [{@code aFromIndex}, {@code atoIndex}) and
     * [{@code bFromIndex}, {@code btoIndex}) respectively:
     * <pre>{@code
     *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==
     *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)
     * }</pre>
     *
     * @apiNote
     * <p>This method behaves as if (for non-{@code null} array elements):
     * <pre>{@code
     *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,
     *                             b, bFromIndex, bToIndex);
     *     if (i >= 0 && i < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
     *         return a[aFromIndex + i].compareTo(b[bFromIndex + i]);
     *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);
     * }</pre>
     *
     * @param a the first array to compare
     * @param aFromIndex the index (inclusive) of the first element in the
     *                   first array to be compared
     * @param aToIndex the index (exclusive) of the last element in the
     *                 first array to be compared
     * @param b the second array to compare
     * @param bFromIndex the index (inclusive) of the first element in the
     *                   second array to be compared
     * @param bToIndex the index (exclusive) of the last element in the
     *                 second array to be compared
     * @param <T> the type of comparable array elements
     * @return the value {@code 0} if, over the specified ranges, the first and
     *         second array are equal and contain the same elements in the same
     *         order;
     *         a value less than {@code 0} if, over the specified ranges, the
     *         first array is lexicographically less than the second array; and
     *         a value greater than {@code 0} if, over the specified ranges, the
     *         first array is lexicographically greater than the second array
     * @throws IllegalArgumentException
     *         if {@code aFromIndex > aToIndex} or
     *         if {@code bFromIndex > bToIndex}
     * @throws ArrayIndexOutOfBoundsException
     *         if {@code aFromIndex < 0 or aToIndex > a.length} or
     *         if {@code bFromIndex < 0 or bToIndex > b.length}
     * @throws NullPointerException
     *         if either array is {@code null}
     * @since 9
     */
    public static <T extends Comparable<? super T>> int compare(
            T[] a, int aFromIndex, int aToIndex,
            T[] b, int bFromIndex, int bToIndex) {

    /**
     * Compares two {@code Object} arrays lexicographically using a specified
     * comparator.
     *
     * <p>If the two arrays share a common prefix then the lexicographic
     * comparison is the result of comparing with the specified comparator two
     * elements at an index within the respective arrays that is the prefix
     * length.
     * Otherwise, one array is a proper prefix of the other and, lexicographic
     * comparison is the result of comparing the two array lengths.
     * (See {@link #mismatch(Object[], Object[])} for the definition of a common
     * and proper prefix.)
     *
     * <p>A {@code null} array reference is considered lexicographically less
     * than a non-{@code null} array reference.  Two {@code null} array
     * references are considered equal.
     *
     * @apiNote
     * <p>This method behaves as if (for non-{@code null} array references):
     * <pre>{@code
     *     int i = Arrays.mismatch(a, b, cmp);
     *     if (i >= 0 && i < Math.min(a.length, b.length))
     *         return cmp.compare(a[i], b[i]);
     *     return a.length - b.length;
     * }</pre>
     *
     * @param a the first array to compare
     * @param b the second array to compare
     * @param cmp the comparator to compare array elements
     * @param <T> the type of array elements
     * @return the value {@code 0} if the first and second array are equal and
     *         contain the same elements in the same order;
     *         a value less than {@code 0} if the first array is
     *         lexicographically less than the second array; and
     *         a value greater than {@code 0} if the first array is
     *         lexicographically greater than the second array
     * @throws NullPointerException if the comparator is {@code null}
     * @since 9
     */
    public static <T> int compare(T[] a, T[] b,
                                  Comparator<? super T> cmp) {

    /**
     * Compares two {@code Object} arrays lexicographically over the specified
     * ranges.
     *
     * <p>If the two arrays, over the specified ranges, share a common prefix
     * then the lexicographic comparison is the result of comparing with the
     * specified comparator two elements at a relative index within the
     * respective arrays that is the prefix length.
     * Otherwise, one array is a proper prefix of the other and, lexicographic
     * comparison is the result of comparing the two range lengths.
     * (See {@link #mismatch(Object[], int, int, Object[], int, int)} for the
     * definition of a common and proper prefix.)
     *
     * @apiNote
     * <p>This method behaves as if (for non-{@code null} array elements):
     * <pre>{@code
     *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,
     *                             b, bFromIndex, bToIndex, cmp);
     *     if (i >= 0 && i < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
     *         return cmp.compare(a[aFromIndex + i], b[bFromIndex + i]);
     *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);
     * }</pre>
     *
     * @param a the first array to compare
     * @param aFromIndex the index (inclusive) of the first element in the
     *                   first array to be compared
     * @param aToIndex the index (exclusive) of the last element in the
     *                 first array to be compared
     * @param b the second array to compare
     * @param bFromIndex the index (inclusive) of the first element in the
     *                   second array to be compared
     * @param bToIndex the index (exclusive) of the last element in the
     *                 second array to be compared
     * @param cmp the comparator to compare array elements
     * @param <T> the type of array elements
     * @return the value {@code 0} if, over the specified ranges, the first and
     *         second array are equal and contain the same elements in the same
     *         order;
     *         a value less than {@code 0} if, over the specified ranges, the
     *         first array is lexicographically less than the second array; and
     *         a value greater than {@code 0} if, over the specified ranges, the
     *         first array is lexicographically greater than the second array
     * @throws IllegalArgumentException
     *         if {@code aFromIndex > aToIndex} or
     *         if {@code bFromIndex > bToIndex}
     * @throws ArrayIndexOutOfBoundsException
     *         if {@code aFromIndex < 0 or aToIndex > a.length} or
     *         if {@code bFromIndex < 0 or bToIndex > b.length}
     * @throws NullPointerException
     *         if either array or the comparator is {@code null}
     * @since 9
     */
    public static <T> int compare(
            T[] a, int aFromIndex, int aToIndex,
            T[] b, int bFromIndex, int bToIndex,
            Comparator<? super T> cmp) {

    /**
     * Finds and returns the index of the first mismatch between two
     * {@code boolean} arrays, otherwise return -1 if no mismatch is found.  The
     * index will be in the range of 0 (inclusive) up to the length (inclusive)
     * of the smaller array.
     *
     * <p>If the two arrays share a common prefix then the returned index is the
     * length of the common prefix and it follows that there is a mismatch
     * between the two elements at that index within the respective arrays.
     * If one array is a proper prefix of the other then the returned index is
     * the length of the smaller array and it follows that the index is only
     * valid for the larger array.
     * Otherwise, there is no mismatch.
     *
     * <p>Two non-{@code null} arrays, {@code a} and {@code b}, share a common
     * prefix of length {@code pl} if the following expression is true:
     * <pre>{@code
     *     pl >= 0 &&
     *     pl < Math.min(a.length, b.length) &&
     *     Arrays.equals(a, 0, pl, b, 0, pl) &&
     *     a[pl] != b[pl]
     * }</pre>
     * Note that a common prefix length of {@code 0} indicates that the first
     * elements from each array mismatch.
     *
     * <p>Two non-{@code null} arrays, {@code a} and {@code b}, share a proper
     * prefix if the following expression is true:
     * <pre>{@code
     *     a.length != b.length &&
     *     Arrays.equals(a, 0, Math.min(a.length, b.length),
     *                   b, 0, Math.min(a.length, b.length))
     * }</pre>
     *
     * @param a the first array to be tested for a mismatch
     * @param b the second array to be tested for a mismatch
     * @return the index of the first mismatch between the two arrays,
     *         otherwise {@code -1}.
     * @throws NullPointerException
     *         if either array is {@code null}
     * @since 9
     */
    public static int mismatch(boolean[] a, boolean[] b) {

    /**
     * Finds and returns the relative index of the first mismatch between two
     * {@code boolean} arrays over the specified ranges, otherwise return -1 if
     * no mismatch is found.  The index will be in the range of 0 (inclusive) up
     * to the length (inclusive) of the smaller range.
     *
     * <p>If the two arrays, over the specified ranges, share a common prefix
     * then the returned relative index is the length of the common prefix and
     * it follows that there is a mismatch between the two elements at that
     * relative index within the respective arrays.
     * If one array is a proper prefix of the other, over the specified ranges,
     * then the returned relative index is the length of the smaller range and
     * it follows that the relative index is only valid for the array with the
     * larger range.
     * Otherwise, there is no mismatch.
     *
     * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified
     * ranges [{@code aFromIndex}, {@code atoIndex}) and
     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
     * prefix of length {@code pl} if the following expression is true:
     * <pre>{@code
     *     pl >= 0 &&
     *     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&
     *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &&
     *     a[aFromIndex + pl] != b[bFromIndex + pl]
     * }</pre>
     * Note that a common prefix length of {@code 0} indicates that the first
     * elements from each array mismatch.
     *
     * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified
     * ranges [{@code aFromIndex}, {@code atoIndex}) and
     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
     * if the following expression is true:
     * <pre>{@code
     *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&
     *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
     *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
     * }</pre>
     *
     * @param a the first array to be tested for a mismatch
     * @param aFromIndex the index (inclusive) of the first element in the
     *                   first array to be tested
     * @param aToIndex the index (exclusive) of the last element in the
     *                 first array to be tested
     * @param b the second array to be tested for a mismatch
     * @param bFromIndex the index (inclusive) of the first element in the
     *                   second array to be tested
     * @param bToIndex the index (exclusive) of the last element in the
     *                 second array to be tested
     * @return the relative index of the first mismatch between the two arrays
     *         over the specified ranges, otherwise {@code -1}.
     * @throws IllegalArgumentException
     *         if {@code aFromIndex > aToIndex} or
     *         if {@code bFromIndex > bToIndex}
     * @throws ArrayIndexOutOfBoundsException
     *         if {@code aFromIndex < 0 or aToIndex > a.length} or
     *         if {@code bFromIndex < 0 or bToIndex > b.length}
     * @throws NullPointerException
     *         if either array is {@code null}
     * @since 9
     */
    public static int mismatch(boolean[] a, int aFromIndex, int aToIndex,
                               boolean[] b, int bFromIndex, int bToIndex) {

    /**
     * Finds and returns the index of the first mismatch between two {@code byte}
     * arrays, otherwise return -1 if no mismatch is found.  The index will be
     * in the range of 0 (inclusive) up to the length (inclusive) of the smaller
     * array.
     *
     * <p>If the two arrays share a common prefix then the returned index is the
     * length of the common prefix and it follows that there is a mismatch
     * between the two elements at that index within the respective arrays.
     * If one array is a proper prefix of the other then the returned index is
     * the length of the smaller array and it follows that the index is only
     * valid for the larger array.
     * Otherwise, there is no mismatch.
     *
     * <p>Two non-{@code null} arrays, {@code a} and {@code b}, share a common
     * prefix of length {@code pl} if the following expression is true:
     * <pre>{@code
     *     pl >= 0 &&
     *     pl < Math.min(a.length, b.length) &&
     *     Arrays.equals(a, 0, pl, b, 0, pl) &&
     *     a[pl] != b[pl]
     * }</pre>
     * Note that a common prefix length of {@code 0} indicates that the first
     * elements from each array mismatch.
     *
     * <p>Two non-{@code null} arrays, {@code a} and {@code b}, share a proper
     * prefix if the following expression is true:
     * <pre>{@code
     *     a.length != b.length &&
     *     Arrays.equals(a, 0, Math.min(a.length, b.length),
     *                   b, 0, Math.min(a.length, b.length))
     * }</pre>
     *
     * @param a the first array to be tested for a mismatch
     * @param b the second array to be tested for a mismatch
     * @return the index of the first mismatch between the two arrays,
     *         otherwise {@code -1}.
     * @throws NullPointerException
     *         if either array is {@code null}
     * @since 9
     */
    public static int mismatch(byte[] a, byte[] b) {

    /**
     * Finds and returns the relative index of the first mismatch between two
     * {@code byte} arrays over the specified ranges, otherwise return -1 if no
     * mismatch is found.  The index will be in the range of 0 (inclusive) up to
     * the length (inclusive) of the smaller range.
     *
     * <p>If the two arrays, over the specified ranges, share a common prefix
     * then the returned relative index is the length of the common prefix and
     * it follows that there is a mismatch between the two elements at that
     * relative index within the respective arrays.
     * If one array is a proper prefix of the other, over the specified ranges,
     * then the returned relative index is the length of the smaller range and
     * it follows that the relative index is only valid for the array with the
     * larger range.
     * Otherwise, there is no mismatch.
     *
     * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified
     * ranges [{@code aFromIndex}, {@code atoIndex}) and
     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
     * prefix of length {@code pl} if the following expression is true:
     * <pre>{@code
     *     pl >= 0 &&
     *     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&
     *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &&
     *     a[aFromIndex + pl] != b[bFromIndex + pl]
     * }</pre>
     * Note that a common prefix length of {@code 0} indicates that the first
     * elements from each array mismatch.
     *
     * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified
     * ranges [{@code aFromIndex}, {@code atoIndex}) and
     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
     * if the following expression is true:
     * <pre>{@code
     *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&
     *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
     *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
     * }</pre>
     *
     * @param a the first array to be tested for a mismatch
     * @param aFromIndex the index (inclusive) of the first element in the
     *                   first array to be tested
     * @param aToIndex the index (exclusive) of the last element in the
     *                 first array to be tested
     * @param b the second array to be tested for a mismatch
     * @param bFromIndex the index (inclusive) of the first element in the
     *                   second array to be tested
     * @param bToIndex the index (exclusive) of the last element in the
     *                 second array to be tested
     * @return the relative index of the first mismatch between the two arrays
     *         over the specified ranges, otherwise {@code -1}.
     * @throws IllegalArgumentException
     *         if {@code aFromIndex > aToIndex} or
     *         if {@code bFromIndex > bToIndex}
     * @throws ArrayIndexOutOfBoundsException
     *         if {@code aFromIndex < 0 or aToIndex > a.length} or
     *         if {@code bFromIndex < 0 or bToIndex > b.length}
     * @throws NullPointerException
     *         if either array is {@code null}
     * @since 9
     */
    public static int mismatch(byte[] a, int aFromIndex, int aToIndex,
                               byte[] b, int bFromIndex, int bToIndex) {

    /**
     * Finds and returns the index of the first mismatch between two {@code char}
     * arrays, otherwise return -1 if no mismatch is found.  The index will be
     * in the range of 0 (inclusive) up to the length (inclusive) of the smaller
     * array.
     *
     * <p>If the two arrays share a common prefix then the returned index is the
     * length of the common prefix and it follows that there is a mismatch
     * between the two elements at that index within the respective arrays.
     * If one array is a proper prefix of the other then the returned index is
     * the length of the smaller array and it follows that the index is only
     * valid for the larger array.
     * Otherwise, there is no mismatch.
     *
     * <p>Two non-{@code null} arrays, {@code a} and {@code b}, share a common
     * prefix of length {@code pl} if the following expression is true:
     * <pre>{@code
     *     pl >= 0 &&
     *     pl < Math.min(a.length, b.length) &&
     *     Arrays.equals(a, 0, pl, b, 0, pl) &&
     *     a[pl] != b[pl]
     * }</pre>
     * Note that a common prefix length of {@code 0} indicates that the first
     * elements from each array mismatch.
     *
     * <p>Two non-{@code null} arrays, {@code a} and {@code b}, share a proper
     * prefix if the following expression is true:
     * <pre>{@code
     *     a.length != b.length &&
     *     Arrays.equals(a, 0, Math.min(a.length, b.length),
     *                   b, 0, Math.min(a.length, b.length))
     * }</pre>
     *
     * @param a the first array to be tested for a mismatch
     * @param b the second array to be tested for a mismatch
     * @return the index of the first mismatch between the two arrays,
     *         otherwise {@code -1}.
     * @throws NullPointerException
     *         if either array is {@code null}
     * @since 9
     */
    public static int mismatch(char[] a, char[] b) {

    /**
     * Finds and returns the relative index of the first mismatch between two
     * {@code char} arrays over the specified ranges, otherwise return -1 if no
     * mismatch is found.  The index will be in the range of 0 (inclusive) up to
     * the length (inclusive) of the smaller range.
     *
     * <p>If the two arrays, over the specified ranges, share a common prefix
     * then the returned relative index is the length of the common prefix and
     * it follows that there is a mismatch between the two elements at that
     * relative index within the respective arrays.
     * If one array is a proper prefix of the other, over the specified ranges,
     * then the returned relative index is the length of the smaller range and
     * it follows that the relative index is only valid for the array with the
     * larger range.
     * Otherwise, there is no mismatch.
     *
     * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified
     * ranges [{@code aFromIndex}, {@code atoIndex}) and
     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
     * prefix of length {@code pl} if the following expression is true:
     * <pre>{@code
     *     pl >= 0 &&
     *     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&
     *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &&
     *     a[aFromIndex + pl] != b[bFromIndex + pl]
     * }</pre>
     * Note that a common prefix length of {@code 0} indicates that the first
     * elements from each array mismatch.
     *
     * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified
     * ranges [{@code aFromIndex}, {@code atoIndex}) and
     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
     * if the following expression is true:
     * <pre>{@code
     *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&
     *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
     *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
     * }</pre>
     *
     * @param a the first array to be tested for a mismatch
     * @param aFromIndex the index (inclusive) of the first element in the
     *                   first array to be tested
     * @param aToIndex the index (exclusive) of the last element in the
     *                 first array to be tested
     * @param b the second array to be tested for a mismatch
     * @param bFromIndex the index (inclusive) of the first element in the
     *                   second array to be tested
     * @param bToIndex the index (exclusive) of the last element in the
     *                 second array to be tested
     * @return the relative index of the first mismatch between the two arrays
     *         over the specified ranges, otherwise {@code -1}.
     * @throws IllegalArgumentException
     *         if {@code aFromIndex > aToIndex} or
     *         if {@code bFromIndex > bToIndex}
     * @throws ArrayIndexOutOfBoundsException
     *         if {@code aFromIndex < 0 or aToIndex > a.length} or
     *         if {@code bFromIndex < 0 or bToIndex > b.length}
     * @throws NullPointerException
     *         if either array is {@code null}
     * @since 9
     */
    public static int mismatch(char[] a, int aFromIndex, int aToIndex,
                               char[] b, int bFromIndex, int bToIndex) {

    /**
     * Finds and returns the index of the first mismatch between two {@code short}
     * arrays, otherwise return -1 if no mismatch is found.  The index will be
     * in the range of 0 (inclusive) up to the length (inclusive) of the smaller
     * array.
     *
     * <p>If the two arrays share a common prefix then the returned index is the
     * length of the common prefix and it follows that there is a mismatch
     * between the two elements at that index within the respective arrays.
     * If one array is a proper prefix of the other then the returned index is
     * the length of the smaller array and it follows that the index is only
     * valid for the larger array.
     * Otherwise, there is no mismatch.
     *
     * <p>Two non-{@code null} arrays, {@code a} and {@code b}, share a common
     * prefix of length {@code pl} if the following expression is true:
     * <pre>{@code
     *     pl >= 0 &&
     *     pl < Math.min(a.length, b.length) &&
     *     Arrays.equals(a, 0, pl, b, 0, pl) &&
     *     a[pl] != b[pl]
     * }</pre>
     * Note that a common prefix length of {@code 0} indicates that the first
     * elements from each array mismatch.
     *
     * <p>Two non-{@code null} arrays, {@code a} and {@code b}, share a proper
     * prefix if the following expression is true:
     * <pre>{@code
     *     a.length != b.length &&
     *     Arrays.equals(a, 0, Math.min(a.length, b.length),
     *                   b, 0, Math.min(a.length, b.length))
     * }</pre>
     *
     * @param a the first array to be tested for a mismatch
     * @param b the second array to be tested for a mismatch
     * @return the index of the first mismatch between the two arrays,
     *         otherwise {@code -1}.
     * @throws NullPointerException
     *         if either array is {@code null}
     * @since 9
     */
    public static int mismatch(short[] a, short[] b) {

    /**
     * Finds and returns the relative index of the first mismatch between two
     * {@code short} arrays over the specified ranges, otherwise return -1 if no
     * mismatch is found.  The index will be in the range of 0 (inclusive) up to
     * the length (inclusive) of the smaller range.
     *
     * <p>If the two arrays, over the specified ranges, share a common prefix
     * then the returned relative index is the length of the common prefix and
     * it follows that there is a mismatch between the two elements at that
     * relative index within the respective arrays.
     * If one array is a proper prefix of the other, over the specified ranges,
     * then the returned relative index is the length of the smaller range and
     * it follows that the relative index is only valid for the array with the
     * larger range.
     * Otherwise, there is no mismatch.
     *
     * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified
     * ranges [{@code aFromIndex}, {@code atoIndex}) and
     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
     * prefix of length {@code pl} if the following expression is true:
     * <pre>{@code
     *     pl >= 0 &&
     *     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&
     *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &&
     *     a[aFromIndex + pl] != b[bFromIndex + pl]
     * }</pre>
     * Note that a common prefix length of {@code 0} indicates that the first
     * elements from each array mismatch.
     *
     * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified
     * ranges [{@code aFromIndex}, {@code atoIndex}) and
     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
     * if the following expression is true:
     * <pre>{@code
     *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&
     *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
     *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
     * }</pre>
     *
     * @param a the first array to be tested for a mismatch
     * @param aFromIndex the index (inclusive) of the first element in the
     *                   first array to be tested
     * @param aToIndex the index (exclusive) of the last element in the
     *                 first array to be tested
     * @param b the second array to be tested for a mismatch
     * @param bFromIndex the index (inclusive) of the first element in the
     *                   second array to be tested
     * @param bToIndex the index (exclusive) of the last element in the
     *                 second array to be tested
     * @return the relative index of the first mismatch between the two arrays
     *         over the specified ranges, otherwise {@code -1}.
     * @throws IllegalArgumentException
     *         if {@code aFromIndex > aToIndex} or
     *         if {@code bFromIndex > bToIndex}
     * @throws ArrayIndexOutOfBoundsException
     *         if {@code aFromIndex < 0 or aToIndex > a.length} or
     *         if {@code bFromIndex < 0 or bToIndex > b.length}
     * @throws NullPointerException
     *         if either array is {@code null}
     * @since 9
     */
    public static int mismatch(short[] a, int aFromIndex, int aToIndex,
                               short[] b, int bFromIndex, int bToIndex) {

    /**
     * Finds and returns the index of the first mismatch between two {@code int}
     * arrays, otherwise return -1 if no mismatch is found.  The index will be
     * in the range of 0 (inclusive) up to the length (inclusive) of the smaller
     * array.
     *
     * <p>If the two arrays share a common prefix then the returned index is the
     * length of the common prefix and it follows that there is a mismatch
     * between the two elements at that index within the respective arrays.
     * If one array is a proper prefix of the other then the returned index is
     * the length of the smaller array and it follows that the index is only
     * valid for the larger array.
     * Otherwise, there is no mismatch.
     *
     * <p>Two non-{@code null} arrays, {@code a} and {@code b}, share a common
     * prefix of length {@code pl} if the following expression is true:
     * <pre>{@code
     *     pl >= 0 &&
     *     pl < Math.min(a.length, b.length) &&
     *     Arrays.equals(a, 0, pl, b, 0, pl) &&
     *     a[pl] != b[pl]
     * }</pre>
     * Note that a common prefix length of {@code 0} indicates that the first
     * elements from each array mismatch.
     *
     * <p>Two non-{@code null} arrays, {@code a} and {@code b}, share a proper
     * prefix if the following expression is true:
     * <pre>{@code
     *     a.length != b.length &&
     *     Arrays.equals(a, 0, Math.min(a.length, b.length),
     *                   b, 0, Math.min(a.length, b.length))
     * }</pre>
     *
     * @param a the first array to be tested for a mismatch
     * @param b the second array to be tested for a mismatch
     * @return the index of the first mismatch between the two arrays,
     *         otherwise {@code -1}.
     * @throws NullPointerException
     *         if either array is {@code null}
     * @since 9
     */
    public static int mismatch(int[] a, int[] b) {

    /**
     * Finds and returns the relative index of the first mismatch between two
     * {@code int} arrays over the specified ranges, otherwise return -1 if no
     * mismatch is found.  The index will be in the range of 0 (inclusive) up to
     * the length (inclusive) of the smaller range.
     *
     * <p>If the two arrays, over the specified ranges, share a common prefix
     * then the returned relative index is the length of the common prefix and
     * it follows that there is a mismatch between the two elements at that
     * relative index within the respective arrays.
     * If one array is a proper prefix of the other, over the specified ranges,
     * then the returned relative index is the length of the smaller range and
     * it follows that the relative index is only valid for the array with the
     * larger range.
     * Otherwise, there is no mismatch.
     *
     * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified
     * ranges [{@code aFromIndex}, {@code atoIndex}) and
     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
     * prefix of length {@code pl} if the following expression is true:
     * <pre>{@code
     *     pl >= 0 &&
     *     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&
     *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &&
     *     a[aFromIndex + pl] != b[bFromIndex + pl]
     * }</pre>
     * Note that a common prefix length of {@code 0} indicates that the first
     * elements from each array mismatch.
     *
     * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified
     * ranges [{@code aFromIndex}, {@code atoIndex}) and
     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
     * if the following expression is true:
     * <pre>{@code
     *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&
     *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
     *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
     * }</pre>
     *
     * @param a the first array to be tested for a mismatch
     * @param aFromIndex the index (inclusive) of the first element in the
     *                   first array to be tested
     * @param aToIndex the index (exclusive) of the last element in the
     *                 first array to be tested
     * @param b the second array to be tested for a mismatch
     * @param bFromIndex the index (inclusive) of the first element in the
     *                   second array to be tested
     * @param bToIndex the index (exclusive) of the last element in the
     *                 second array to be tested
     * @return the relative index of the first mismatch between the two arrays
     *         over the specified ranges, otherwise {@code -1}.
     * @throws IllegalArgumentException
     *         if {@code aFromIndex > aToIndex} or
     *         if {@code bFromIndex > bToIndex}
     * @throws ArrayIndexOutOfBoundsException
     *         if {@code aFromIndex < 0 or aToIndex > a.length} or
     *         if {@code bFromIndex < 0 or bToIndex > b.length}
     * @throws NullPointerException
     *         if either array is {@code null}
     * @since 9
     */
    public static int mismatch(int[] a, int aFromIndex, int aToIndex,
                               int[] b, int bFromIndex, int bToIndex) {

    /**
     * Finds and returns the index of the first mismatch between two {@code long}
     * arrays, otherwise return -1 if no mismatch is found.  The index will be
     * in the range of 0 (inclusive) up to the length (inclusive) of the smaller
     * array.
     *
     * <p>If the two arrays share a common prefix then the returned index is the
     * length of the common prefix and it follows that there is a mismatch
     * between the two elements at that index within the respective arrays.
     * If one array is a proper prefix of the other then the returned index is
     * the length of the smaller array and it follows that the index is only
     * valid for the larger array.
     * Otherwise, there is no mismatch.
     *
     * <p>Two non-{@code null} arrays, {@code a} and {@code b}, share a common
     * prefix of length {@code pl} if the following expression is true:
     * <pre>{@code
     *     pl >= 0 &&
     *     pl < Math.min(a.length, b.length) &&
     *     Arrays.equals(a, 0, pl, b, 0, pl) &&
     *     a[pl] != b[pl]
     * }</pre>
     * Note that a common prefix length of {@code 0} indicates that the first
     * elements from each array mismatch.
     *
     * <p>Two non-{@code null} arrays, {@code a} and {@code b}, share a proper
     * prefix if the following expression is true:
     * <pre>{@code
     *     a.length != b.length &&
     *     Arrays.equals(a, 0, Math.min(a.length, b.length),
     *                   b, 0, Math.min(a.length, b.length))
     * }</pre>
     *
     * @param a the first array to be tested for a mismatch
     * @param b the second array to be tested for a mismatch
     * @return the index of the first mismatch between the two arrays,
     *         otherwise {@code -1}.
     * @throws NullPointerException
     *         if either array is {@code null}
     * @since 9
     */
    public static int mismatch(long[] a, long[] b) {

    /**
     * Finds and returns the relative index of the first mismatch between two
     * {@code long} arrays over the specified ranges, otherwise return -1 if no
     * mismatch is found.  The index will be in the range of 0 (inclusive) up to
     * the length (inclusive) of the smaller range.
     *
     * <p>If the two arrays, over the specified ranges, share a common prefix
     * then the returned relative index is the length of the common prefix and
     * it follows that there is a mismatch between the two elements at that
     * relative index within the respective arrays.
     * If one array is a proper prefix of the other, over the specified ranges,
     * then the returned relative index is the length of the smaller range and
     * it follows that the relative index is only valid for the array with the
     * larger range.
     * Otherwise, there is no mismatch.
     *
     * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified
     * ranges [{@code aFromIndex}, {@code atoIndex}) and
     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
     * prefix of length {@code pl} if the following expression is true:
     * <pre>{@code
     *     pl >= 0 &&
     *     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&
     *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &&
     *     a[aFromIndex + pl] != b[bFromIndex + pl]
     * }</pre>
     * Note that a common prefix length of {@code 0} indicates that the first
     * elements from each array mismatch.
     *
     * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified
     * ranges [{@code aFromIndex}, {@code atoIndex}) and
     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
     * if the following expression is true:
     * <pre>{@code
     *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&
     *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
     *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
     * }</pre>
     *
     * @param a the first array to be tested for a mismatch
     * @param aFromIndex the index (inclusive) of the first element in the
     *                   first array to be tested
     * @param aToIndex the index (exclusive) of the last element in the
     *                 first array to be tested
     * @param b the second array to be tested for a mismatch
     * @param bFromIndex the index (inclusive) of the first element in the
     *                   second array to be tested
     * @param bToIndex the index (exclusive) of the last element in the
     *                 second array to be tested
     * @return the relative index of the first mismatch between the two arrays
     *         over the specified ranges, otherwise {@code -1}.
     * @throws IllegalArgumentException
     *         if {@code aFromIndex > aToIndex} or
     *         if {@code bFromIndex > bToIndex}
     * @throws ArrayIndexOutOfBoundsException
     *         if {@code aFromIndex < 0 or aToIndex > a.length} or
     *         if {@code bFromIndex < 0 or bToIndex > b.length}
     * @throws NullPointerException
     *         if either array is {@code null}
     * @since 9
     */
    public static int mismatch(long[] a, int aFromIndex, int aToIndex,
                               long[] b, int bFromIndex, int bToIndex) {

    /**
     * Finds and returns the index of the first mismatch between two {@code float}
     * arrays, otherwise return -1 if no mismatch is found.  The index will be
     * in the range of 0 (inclusive) up to the length (inclusive) of the smaller
     * array.
     *
     * <p>If the two arrays share a common prefix then the returned index is the
     * length of the common prefix and it follows that there is a mismatch
     * between the two elements at that index within the respective arrays.
     * If one array is a proper prefix of the other then the returned index is
     * the length of the smaller array and it follows that the index is only
     * valid for the larger array.
     * Otherwise, there is no mismatch.
     *
     * <p>Two non-{@code null} arrays, {@code a} and {@code b}, share a common
     * prefix of length {@code pl} if the following expression is true:
     * <pre>{@code
     *     pl >= 0 &&
     *     pl < Math.min(a.length, b.length) &&
     *     Arrays.equals(a, 0, pl, b, 0, pl) &&
     *     Float.compare(a[pl], b[pl]) != 0
     * }</pre>
     * Note that a common prefix length of {@code 0} indicates that the first
     * elements from each array mismatch.
     *
     * <p>Two non-{@code null} arrays, {@code a} and {@code b}, share a proper
     * prefix if the following expression is true:
     * <pre>{@code
     *     a.length != b.length &&
     *     Arrays.equals(a, 0, Math.min(a.length, b.length),
     *                   b, 0, Math.min(a.length, b.length))
     * }</pre>
     *
     * @param a the first array to be tested for a mismatch
     * @param b the second array to be tested for a mismatch
     * @return the index of the first mismatch between the two arrays,
     *         otherwise {@code -1}.
     * @throws NullPointerException
     *         if either array is {@code null}
     * @since 9
     */
    public static int mismatch(float[] a, float[] b) {

    /**
     * Finds and returns the relative index of the first mismatch between two
     * {@code float} arrays over the specified ranges, otherwise return -1 if no
     * mismatch is found.  The index will be in the range of 0 (inclusive) up to
     * the length (inclusive) of the smaller range.
     *
     * <p>If the two arrays, over the specified ranges, share a common prefix
     * then the returned relative index is the length of the common prefix and
     * it follows that there is a mismatch between the two elements at that
     * relative index within the respective arrays.
     * If one array is a proper prefix of the other, over the specified ranges,
     * then the returned relative index is the length of the smaller range and
     * it follows that the relative index is only valid for the array with the
     * larger range.
     * Otherwise, there is no mismatch.
     *
     * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified
     * ranges [{@code aFromIndex}, {@code atoIndex}) and
     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
     * prefix of length {@code pl} if the following expression is true:
     * <pre>{@code
     *     pl >= 0 &&
     *     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&
     *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &&
     *     Float.compare(a[aFromIndex + pl], b[bFromIndex + pl]) != 0
     * }</pre>
     * Note that a common prefix length of {@code 0} indicates that the first
     * elements from each array mismatch.
     *
     * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified
     * ranges [{@code aFromIndex}, {@code atoIndex}) and
     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
     * if the following expression is true:
     * <pre>{@code
     *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&
     *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
     *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
     * }</pre>
     *
     * @param a the first array to be tested for a mismatch
     * @param aFromIndex the index (inclusive) of the first element in the
     *                   first array to be tested
     * @param aToIndex the index (exclusive) of the last element in the
     *                 first array to be tested
     * @param b the second array to be tested for a mismatch
     * @param bFromIndex the index (inclusive) of the first element in the
     *                   second array to be tested
     * @param bToIndex the index (exclusive) of the last element in the
     *                 second array to be tested
     * @return the relative index of the first mismatch between the two arrays
     *         over the specified ranges, otherwise {@code -1}.
     * @throws IllegalArgumentException
     *         if {@code aFromIndex > aToIndex} or
     *         if {@code bFromIndex > bToIndex}
     * @throws ArrayIndexOutOfBoundsException
     *         if {@code aFromIndex < 0 or aToIndex > a.length} or
     *         if {@code bFromIndex < 0 or bToIndex > b.length}
     * @throws NullPointerException
     *         if either array is {@code null}
     * @since 9
     */
    public static int mismatch(float[] a, int aFromIndex, int aToIndex,
                               float[] b, int bFromIndex, int bToIndex) {

    /**
     * Finds and returns the index of the first mismatch between two
     * {@code double} arrays, otherwise return -1 if no mismatch is found.  The
     * index will be in the range of 0 (inclusive) up to the length (inclusive)
     * of the smaller array.
     *
     * <p>If the two arrays share a common prefix then the returned index is the
     * length of the common prefix and it follows that there is a mismatch
     * between the two elements at that index within the respective arrays.
     * If one array is a proper prefix of the other then the returned index is
     * the length of the smaller array and it follows that the index is only
     * valid for the larger array.
     * Otherwise, there is no mismatch.
     *
     * <p>Two non-{@code null} arrays, {@code a} and {@code b}, share a common
     * prefix of length {@code pl} if the following expression is true:
     * <pre>{@code
     *     pl >= 0 &&
     *     pl < Math.min(a.length, b.length) &&
     *     Arrays.equals(a, 0, pl, b, 0, pl) &&
     *     Double.compare(a[pl], b[pl]) != 0
     * }</pre>
     * Note that a common prefix length of {@code 0} indicates that the first
     * elements from each array mismatch.
     *
     * <p>Two non-{@code null} arrays, {@code a} and {@code b}, share a proper
     * prefix if the following expression is true:
     * <pre>{@code
     *     a.length != b.length &&
     *     Arrays.equals(a, 0, Math.min(a.length, b.length),
     *                   b, 0, Math.min(a.length, b.length))
     * }</pre>
     *
     * @param a the first array to be tested for a mismatch
     * @param b the second array to be tested for a mismatch
     * @return the index of the first mismatch between the two arrays,
     *         otherwise {@code -1}.
     * @throws NullPointerException
     *         if either array is {@code null}
     * @since 9
     */
    public static int mismatch(double[] a, double[] b) {

    /**
     * Finds and returns the relative index of the first mismatch between two
     * {@code double} arrays over the specified ranges, otherwise return -1 if
     * no mismatch is found.  The index will be in the range of 0 (inclusive) up
     * to the length (inclusive) of the smaller range.
     *
     * <p>If the two arrays, over the specified ranges, share a common prefix
     * then the returned relative index is the length of the common prefix and
     * it follows that there is a mismatch between the two elements at that
     * relative index within the respective arrays.
     * If one array is a proper prefix of the other, over the specified ranges,
     * then the returned relative index is the length of the smaller range and
     * it follows that the relative index is only valid for the array with the
     * larger range.
     * Otherwise, there is no mismatch.
     *
     * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified
     * ranges [{@code aFromIndex}, {@code atoIndex}) and
     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
     * prefix of length {@code pl} if the following expression is true:
     * <pre>{@code
     *     pl >= 0 &&
     *     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&
     *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &&
     *     Double.compare(a[aFromIndex + pl], b[bFromIndex + pl]) != 0
     * }</pre>
     * Note that a common prefix length of {@code 0} indicates that the first
     * elements from each array mismatch.
     *
     * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified
     * ranges [{@code aFromIndex}, {@code atoIndex}) and
     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
     * if the following expression is true:
     * <pre>{@code
     *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&
     *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
     *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
     * }</pre>
     *
     * @param a the first array to be tested for a mismatch
     * @param aFromIndex the index (inclusive) of the first element in the
     *                   first array to be tested
     * @param aToIndex the index (exclusive) of the last element in the
     *                 first array to be tested
     * @param b the second array to be tested for a mismatch
     * @param bFromIndex the index (inclusive) of the first element in the
     *                   second array to be tested
     * @param bToIndex the index (exclusive) of the last element in the
     *                 second array to be tested
     * @return the relative index of the first mismatch between the two arrays
     *         over the specified ranges, otherwise {@code -1}.
     * @throws IllegalArgumentException
     *         if {@code aFromIndex > aToIndex} or
     *         if {@code bFromIndex > bToIndex}
     * @throws ArrayIndexOutOfBoundsException
     *         if {@code aFromIndex < 0 or aToIndex > a.length} or
     *         if {@code bFromIndex < 0 or bToIndex > b.length}
     * @throws NullPointerException
     *         if either array is {@code null}
     * @since 9
     */
    public static int mismatch(double[] a, int aFromIndex, int aToIndex,
                               double[] b, int bFromIndex, int bToIndex) {

    /**
     * Finds and returns the index of the first mismatch between two
     * {@code Object} arrays, otherwise return -1 if no mismatch is found.  The
     * index will be in the range of 0 (inclusive) up to the length (inclusive)
     * of the smaller array.
     *
     * <p>If the two arrays share a common prefix then the returned index is the
     * length of the common prefix and it follows that there is a mismatch
     * between the two elements at that index within the respective arrays.
     * If one array is a proper prefix of the other then the returned index is
     * the length of the smaller array and it follows that the index is only
     * valid for the larger array.
     * Otherwise, there is no mismatch.
     *
     * <p>Two non-{@code null} arrays, {@code a} and {@code b}, share a common
     * prefix of length {@code pl} if the following expression is true:
     * <pre>{@code
     *     pl >= 0 &&
     *     pl < Math.min(a.length, b.length) &&
     *     Arrays.equals(a, 0, pl, b, 0, pl) &&
     *     !Objects.equals(a[pl], b[pl])
     * }</pre>
     * Note that a common prefix length of {@code 0} indicates that the first
     * elements from each array mismatch.
     *
     * <p>Two non-{@code null} arrays, {@code a} and {@code b}, share a proper
     * prefix if the following expression is true:
     * <pre>{@code
     *     a.length != b.length &&
     *     Arrays.equals(a, 0, Math.min(a.length, b.length),
     *                   b, 0, Math.min(a.length, b.length))
     * }</pre>
     *
     * @param a the first array to be tested for a mismatch
     * @param b the second array to be tested for a mismatch
     * @return the index of the first mismatch between the two arrays,
     *         otherwise {@code -1}.
     * @throws NullPointerException
     *         if either array is {@code null}
     * @since 9
     */
    public static int mismatch(Object[] a, Object[] b) {

    /**
     * Finds and returns the relative index of the first mismatch between two
     * {@code Object} arrays over the specified ranges, otherwise return -1 if
     * no mismatch is found.  The index will be in the range of 0 (inclusive) up
     * to the length (inclusive) of the smaller range.
     *
     * <p>If the two arrays, over the specified ranges, share a common prefix
     * then the returned relative index is the length of the common prefix and
     * it follows that there is a mismatch between the two elements at that
     * relative index within the respective arrays.
     * If one array is a proper prefix of the other, over the specified ranges,
     * then the returned relative index is the length of the smaller range and
     * it follows that the relative index is only valid for the array with the
     * larger range.
     * Otherwise, there is no mismatch.
     *
     * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified
     * ranges [{@code aFromIndex}, {@code atoIndex}) and
     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
     * prefix of length {@code pl} if the following expression is true:
     * <pre>{@code
     *     pl >= 0 &&
     *     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&
     *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &&
     *     !Objects.equals(a[aFromIndex + pl], b[bFromIndex + pl])
     * }</pre>
     * Note that a common prefix length of {@code 0} indicates that the first
     * elements from each array mismatch.
     *
     * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified
     * ranges [{@code aFromIndex}, {@code atoIndex}) and
     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
     * if the following expression is true:
     * <pre>{@code
     *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&
     *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
     *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
     * }</pre>
     *
     * @param a the first array to be tested for a mismatch
     * @param aFromIndex the index (inclusive) of the first element in the
     *                   first array to be tested
     * @param aToIndex the index (exclusive) of the last element in the
     *                 first array to be tested
     * @param b the second array to be tested for a mismatch
     * @param bFromIndex the index (inclusive) of the first element in the
     *                   second array to be tested
     * @param bToIndex the index (exclusive) of the last element in the
     *                 second array to be tested
     * @return the relative index of the first mismatch between the two arrays
     *         over the specified ranges, otherwise {@code -1}.
     * @throws IllegalArgumentException
     *         if {@code aFromIndex > aToIndex} or
     *         if {@code bFromIndex > bToIndex}
     * @throws ArrayIndexOutOfBoundsException
     *         if {@code aFromIndex < 0 or aToIndex > a.length} or
     *         if {@code bFromIndex < 0 or bToIndex > b.length}
     * @throws NullPointerException
     *         if either array is {@code null}
     * @since 9
     */
    public static int mismatch(
            Object[] a, int aFromIndex, int aToIndex,
            Object[] b, int bFromIndex, int bToIndex) {

    /**
     * Finds and returns the index of the first mismatch between two
     * {@code Object} arrays, otherwise return -1 if no mismatch is found.
     * The index will be in the range of 0 (inclusive) up to the length
     * (inclusive) of the smaller array.
     *
     * <p>The specified comparator is used to determine if two array elements
     * from the each array are not equal.
     *
     * <p>If the two arrays share a common prefix then the returned index is the
     * length of the common prefix and it follows that there is a mismatch
     * between the two elements at that index within the respective arrays.
     * If one array is a proper prefix of the other then the returned index is
     * the length of the smaller array and it follows that the index is only
     * valid for the larger array.
     * Otherwise, there is no mismatch.
     *
     * <p>Two non-{@code null} arrays, {@code a} and {@code b}, share a common
     * prefix of length {@code pl} if the following expression is true:
     * <pre>{@code
     *     pl >= 0 &&
     *     pl < Math.min(a.length, b.length) &&
     *     Arrays.equals(a, 0, pl, b, 0, pl, cmp)
     *     cmp.compare(a[pl], b[pl]) != 0
     * }</pre>
     * Note that a common prefix length of {@code 0} indicates that the first
     * elements from each array mismatch.
     *
     * <p>Two non-{@code null} arrays, {@code a} and {@code b}, share a proper
     * prefix if the following expression is true:
     * <pre>{@code
     *     a.length != b.length &&
     *     Arrays.equals(a, 0, Math.min(a.length, b.length),
     *                   b, 0, Math.min(a.length, b.length),
     *                   cmp)
     * }</pre>
     *
     * @param a the first array to be tested for a mismatch
     * @param b the second array to be tested for a mismatch
     * @param cmp the comparator to compare array elements
     * @param <T> the type of array elements
     * @return the index of the first mismatch between the two arrays,
     *         otherwise {@code -1}.
     * @throws NullPointerException
     *         if either array or the comparator is {@code null}
     * @since 9
     */
    public static <T> int mismatch(T[] a, T[] b, Comparator<? super T> cmp) {

    /**
     * Finds and returns the relative index of the first mismatch between two
     * {@code Object} arrays over the specified ranges, otherwise return -1 if
     * no mismatch is found.  The index will be in the range of 0 (inclusive) up
     * to the length (inclusive) of the smaller range.
     *
     * <p>If the two arrays, over the specified ranges, share a common prefix
     * then the returned relative index is the length of the common prefix and
     * it follows that there is a mismatch between the two elements at that
     * relative index within the respective arrays.
     * If one array is a proper prefix of the other, over the specified ranges,
     * then the returned relative index is the length of the smaller range and
     * it follows that the relative index is only valid for the array with the
     * larger range.
     * Otherwise, there is no mismatch.
     *
     * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified
     * ranges [{@code aFromIndex}, {@code atoIndex}) and
     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
     * prefix of length {@code pl} if the following expression is true:
     * <pre>{@code
     *     pl >= 0 &&
     *     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&
     *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl, cmp) &&
     *     cmp.compare(a[aFromIndex + pl], b[bFromIndex + pl]) != 0
     * }</pre>
     * Note that a common prefix length of {@code 0} indicates that the first
     * elements from each array mismatch.
     *
     * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified
     * ranges [{@code aFromIndex}, {@code atoIndex}) and
     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
     * if the following expression is true:
     * <pre>{@code
     *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&
     *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
     *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
     *                   cmp)
     * }</pre>
     *
     * @param a the first array to be tested for a mismatch
     * @param aFromIndex the index (inclusive) of the first element in the
     *                   first array to be tested
     * @param aToIndex the index (exclusive) of the last element in the
     *                 first array to be tested
     * @param b the second array to be tested for a mismatch
     * @param bFromIndex the index (inclusive) of the first element in the
     *                   second array to be tested
     * @param bToIndex the index (exclusive) of the last element in the
     *                 second array to be tested
     * @param cmp the comparator to compare array elements
     * @param <T> the type of array elements
     * @return the relative index of the first mismatch between the two arrays
     *         over the specified ranges, otherwise {@code -1}.
     * @throws IllegalArgumentException
     *         if {@code aFromIndex > aToIndex} or
     *         if {@code bFromIndex > bToIndex}
     * @throws ArrayIndexOutOfBoundsException
     *         if {@code aFromIndex < 0 or aToIndex > a.length} or
     *         if {@code bFromIndex < 0 or bToIndex > b.length}
     * @throws NullPointerException
     *         if either array or the comparator is {@code null}
     * @since 9
     */
    public static <T> int mismatch(
            T[] a, int aFromIndex, int aToIndex,
            T[] b, int bFromIndex, int bToIndex,
            Comparator<? super T> cmp) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\concurrent\atomic\AtomicBoolean.java
    /**
     * Returns the current value, with memory semantics of reading as
     * if the variable was declared non-{@code volatile}.
     *
     * @return the value
     * @since 9
     */
    public final boolean getPlain() {

    /**
     * Sets the value to {@code newValue}, with memory semantics
     * of setting as if the variable was declared non-{@code volatile}
     * and non-{@code final}.
     *
     * @param newValue the new value
     * @since 9
     */
    public final void setPlain(boolean newValue) {

    /**
     * Returns the current value,
     * with memory effects as specified by {@link VarHandle#getOpaque}.
     *
     * @return the value
     * @since 9
     */
    public final boolean getOpaque() {

    /**
     * Sets the value to {@code newValue},
     * with memory effects as specified by {@link VarHandle#setOpaque}.
     *
     * @param newValue the new value
     * @since 9
     */
    public final void setOpaque(boolean newValue) {

    /**
     * Returns the current value,
     * with memory effects as specified by {@link VarHandle#getAcquire}.
     *
     * @return the value
     * @since 9
     */
    public final boolean getAcquire() {

    /**
     * Sets the value to {@code newValue},
     * with memory effects as specified by {@link VarHandle#setRelease}.
     *
     * @param newValue the new value
     * @since 9
     */
    public final void setRelease(boolean newValue) {

    /**
     * Atomically sets the value to {@code newValue} if the current value,
     * referred to as the <em>witness value</em>, {@code == expectedValue},
     * with memory effects as specified by
     * {@link VarHandle#compareAndExchange}.
     *
     * @param expectedValue the expected value
     * @param newValue the new value
     * @return the witness value, which will be the same as the
     * expected value if successful
     * @since 9
     */
    public final boolean compareAndExchange(boolean expectedValue, boolean newValue) {

    /**
     * Atomically sets the value to {@code newValue} if the current value,
     * referred to as the <em>witness value</em>, {@code == expectedValue},
     * with memory effects as specified by
     * {@link VarHandle#compareAndExchangeAcquire}.
     *
     * @param expectedValue the expected value
     * @param newValue the new value
     * @return the witness value, which will be the same as the
     * expected value if successful
     * @since 9
     */
    public final boolean compareAndExchangeAcquire(boolean expectedValue, boolean newValue) {

    /**
     * Atomically sets the value to {@code newValue} if the current value,
     * referred to as the <em>witness value</em>, {@code == expectedValue},
     * with memory effects as specified by
     * {@link VarHandle#compareAndExchangeRelease}.
     *
     * @param expectedValue the expected value
     * @param newValue the new value
     * @return the witness value, which will be the same as the
     * expected value if successful
     * @since 9
     */
    public final boolean compareAndExchangeRelease(boolean expectedValue, boolean newValue) {

    /**
     * Possibly atomically sets the value to {@code newValue} if the current
     * value {@code == expectedValue},
     * with memory effects as specified by
     * {@link VarHandle#weakCompareAndSet}.
     *
     * @param expectedValue the expected value
     * @param newValue the new value
     * @return {@code true} if successful
     * @since 9
     */
    public final boolean weakCompareAndSetVolatile(boolean expectedValue, boolean newValue) {

    /**
     * Possibly atomically sets the value to {@code newValue} if the current
     * value {@code == expectedValue},
     * with memory effects as specified by
     * {@link VarHandle#weakCompareAndSetAcquire}.
     *
     * @param expectedValue the expected value
     * @param newValue the new value
     * @return {@code true} if successful
     * @since 9
     */
    public final boolean weakCompareAndSetAcquire(boolean expectedValue, boolean newValue) {

    /**
     * Possibly atomically sets the value to {@code newValue} if the current
     * value {@code == expectedValue},
     * with memory effects as specified by
     * {@link VarHandle#weakCompareAndSetRelease}.
     *
     * @param expectedValue the expected value
     * @param newValue the new value
     * @return {@code true} if successful
     * @since 9
     */
    public final boolean weakCompareAndSetRelease(boolean expectedValue, boolean newValue) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\concurrent\atomic\AtomicInteger.java
    /**
     * Returns the current value, with memory semantics of reading as
     * if the variable was declared non-{@code volatile}.
     *
     * @return the value
     * @since 9
     */
    public final int getPlain() {

    /**
     * Sets the value to {@code newValue}, with memory semantics
     * of setting as if the variable was declared non-{@code volatile}
     * and non-{@code final}.
     *
     * @param newValue the new value
     * @since 9
     */
    public final void setPlain(int newValue) {

    /**
     * Returns the current value,
     * with memory effects as specified by {@link VarHandle#getOpaque}.
     *
     * @return the value
     * @since 9
     */
    public final int getOpaque() {

    /**
     * Sets the value to {@code newValue},
     * with memory effects as specified by {@link VarHandle#setOpaque}.
     *
     * @param newValue the new value
     * @since 9
     */
    public final void setOpaque(int newValue) {

    /**
     * Returns the current value,
     * with memory effects as specified by {@link VarHandle#getAcquire}.
     *
     * @return the value
     * @since 9
     */
    public final int getAcquire() {

    /**
     * Sets the value to {@code newValue},
     * with memory effects as specified by {@link VarHandle#setRelease}.
     *
     * @param newValue the new value
     * @since 9
     */
    public final void setRelease(int newValue) {

    /**
     * Atomically sets the value to {@code newValue} if the current value,
     * referred to as the <em>witness value</em>, {@code == expectedValue},
     * with memory effects as specified by
     * {@link VarHandle#compareAndExchange}.
     *
     * @param expectedValue the expected value
     * @param newValue the new value
     * @return the witness value, which will be the same as the
     * expected value if successful
     * @since 9
     */
    public final int compareAndExchange(int expectedValue, int newValue) {

    /**
     * Atomically sets the value to {@code newValue} if the current value,
     * referred to as the <em>witness value</em>, {@code == expectedValue},
     * with memory effects as specified by
     * {@link VarHandle#compareAndExchangeAcquire}.
     *
     * @param expectedValue the expected value
     * @param newValue the new value
     * @return the witness value, which will be the same as the
     * expected value if successful
     * @since 9
     */
    public final int compareAndExchangeAcquire(int expectedValue, int newValue) {

    /**
     * Atomically sets the value to {@code newValue} if the current value,
     * referred to as the <em>witness value</em>, {@code == expectedValue},
     * with memory effects as specified by
     * {@link VarHandle#compareAndExchangeRelease}.
     *
     * @param expectedValue the expected value
     * @param newValue the new value
     * @return the witness value, which will be the same as the
     * expected value if successful
     * @since 9
     */
    public final int compareAndExchangeRelease(int expectedValue, int newValue) {

    /**
     * Possibly atomically sets the value to {@code newValue} if
     * the current value {@code == expectedValue},
     * with memory effects as specified by
     * {@link VarHandle#weakCompareAndSet}.
     *
     * @param expectedValue the expected value
     * @param newValue the new value
     * @return {@code true} if successful
     * @since 9
     */
    public final boolean weakCompareAndSetVolatile(int expectedValue, int newValue) {

    /**
     * Possibly atomically sets the value to {@code newValue} if
     * the current value {@code == expectedValue},
     * with memory effects as specified by
     * {@link VarHandle#weakCompareAndSetAcquire}.
     *
     * @param expectedValue the expected value
     * @param newValue the new value
     * @return {@code true} if successful
     * @since 9
     */
    public final boolean weakCompareAndSetAcquire(int expectedValue, int newValue) {

    /**
     * Possibly atomically sets the value to {@code newValue} if
     * the current value {@code == expectedValue},
     * with memory effects as specified by
     * {@link VarHandle#weakCompareAndSetRelease}.
     *
     * @param expectedValue the expected value
     * @param newValue the new value
     * @return {@code true} if successful
     * @since 9
     */
    public final boolean weakCompareAndSetRelease(int expectedValue, int newValue) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\concurrent\atomic\AtomicIntegerArray.java
    /**
     * Returns the current value of the element at index {@code i},
     * with memory semantics of reading as if the variable was declared
     * non-{@code volatile}.
     *
     * @param i the index
     * @return the value
     * @since 9
     */
    public final int getPlain(int i) {

    /**
     * Sets the element at index {@code i} to {@code newValue},
     * with memory semantics of setting as if the variable was
     * declared non-{@code volatile} and non-{@code final}.
     *
     * @param i the index
     * @param newValue the new value
     * @since 9
     */
    public final void setPlain(int i, int newValue) {

    /**
     * Returns the current value of the element at index {@code i},
     * with memory effects as specified by {@link VarHandle#getOpaque}.
     *
     * @param i the index
     * @return the value
     * @since 9
     */
    public final int getOpaque(int i) {

    /**
     * Sets the element at index {@code i} to {@code newValue},
     * with memory effects as specified by {@link VarHandle#setOpaque}.
     *
     * @param i the index
     * @param newValue the new value
     * @since 9
     */
    public final void setOpaque(int i, int newValue) {

    /**
     * Returns the current value of the element at index {@code i},
     * with memory effects as specified by {@link VarHandle#getAcquire}.
     *
     * @param i the index
     * @return the value
     * @since 9
     */
    public final int getAcquire(int i) {

    /**
     * Sets the element at index {@code i} to {@code newValue},
     * with memory effects as specified by {@link VarHandle#setRelease}.
     *
     * @param i the index
     * @param newValue the new value
     * @since 9
     */
    public final void setRelease(int i, int newValue) {

    /**
     * Atomically sets the element at index {@code i} to {@code newValue}
     * if the element's current value, referred to as the <em>witness
     * value</em>, {@code == expectedValue},
     * with memory effects as specified by
     * {@link VarHandle#compareAndExchange}.
     *
     * @param i the index
     * @param expectedValue the expected value
     * @param newValue the new value
     * @return the witness value, which will be the same as the
     * expected value if successful
     * @since 9
     */
    public final int compareAndExchange(int i, int expectedValue, int newValue) {

    /**
     * Atomically sets the element at index {@code i} to {@code newValue}
     * if the element's current value, referred to as the <em>witness
     * value</em>, {@code == expectedValue},
     * with memory effects as specified by
     * {@link VarHandle#compareAndExchangeAcquire}.
     *
     * @param i the index
     * @param expectedValue the expected value
     * @param newValue the new value
     * @return the witness value, which will be the same as the
     * expected value if successful
     * @since 9
     */
    public final int compareAndExchangeAcquire(int i, int expectedValue, int newValue) {

    /**
     * Atomically sets the element at index {@code i} to {@code newValue}
     * if the element's current value, referred to as the <em>witness
     * value</em>, {@code == expectedValue},
     * with memory effects as specified by
     * {@link VarHandle#compareAndExchangeRelease}.
     *
     * @param i the index
     * @param expectedValue the expected value
     * @param newValue the new value
     * @return the witness value, which will be the same as the
     * expected value if successful
     * @since 9
     */
    public final int compareAndExchangeRelease(int i, int expectedValue, int newValue) {

    /**
     * Possibly atomically sets the element at index {@code i} to
     * {@code newValue} if the element's current value {@code == expectedValue},
     * with memory effects as specified by
     * {@link VarHandle#weakCompareAndSet}.
     *
     * @param i the index
     * @param expectedValue the expected value
     * @param newValue the new value
     * @return {@code true} if successful
     * @since 9
     */
    public final boolean weakCompareAndSetVolatile(int i, int expectedValue, int newValue) {

    /**
     * Possibly atomically sets the element at index {@code i} to
     * {@code newValue} if the element's current value {@code == expectedValue},
     * with memory effects as specified by
     * {@link VarHandle#weakCompareAndSetAcquire}.
     *
     * @param i the index
     * @param expectedValue the expected value
     * @param newValue the new value
     * @return {@code true} if successful
     * @since 9
     */
    public final boolean weakCompareAndSetAcquire(int i, int expectedValue, int newValue) {

    /**
     * Possibly atomically sets the element at index {@code i} to
     * {@code newValue} if the element's current value {@code == expectedValue},
     * with memory effects as specified by
     * {@link VarHandle#weakCompareAndSetRelease}.
     *
     * @param i the index
     * @param expectedValue the expected value
     * @param newValue the new value
     * @return {@code true} if successful
     * @since 9
     */
    public final boolean weakCompareAndSetRelease(int i, int expectedValue, int newValue) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\concurrent\atomic\AtomicLong.java
    /**
     * Returns the current value, with memory semantics of reading as if the
     * variable was declared non-{@code volatile}.
     *
     * @return the value
     * @since 9
     */
    public final long getPlain() {

    /**
     * Sets the value to {@code newValue}, with memory semantics
     * of setting as if the variable was declared non-{@code volatile}
     * and non-{@code final}.
     *
     * @param newValue the new value
     * @since 9
     */
    public final void setPlain(long newValue) {

    /**
     * Returns the current value,
     * with memory effects as specified by {@link VarHandle#getOpaque}.
     *
     * @return the value
     * @since 9
     */
    public final long getOpaque() {

    /**
     * Sets the value to {@code newValue},
     * with memory effects as specified by {@link VarHandle#setOpaque}.
     *
     * @param newValue the new value
     * @since 9
     */
    public final void setOpaque(long newValue) {

    /**
     * Returns the current value,
     * with memory effects as specified by {@link VarHandle#getAcquire}.
     *
     * @return the value
     * @since 9
     */
    public final long getAcquire() {

    /**
     * Sets the value to {@code newValue},
     * with memory effects as specified by {@link VarHandle#setRelease}.
     *
     * @param newValue the new value
     * @since 9
     */
    public final void setRelease(long newValue) {

    /**
     * Atomically sets the value to {@code newValue} if the current value,
     * referred to as the <em>witness value</em>, {@code == expectedValue},
     * with memory effects as specified by
     * {@link VarHandle#compareAndExchange}.
     *
     * @param expectedValue the expected value
     * @param newValue the new value
     * @return the witness value, which will be the same as the
     * expected value if successful
     * @since 9
     */
    public final long compareAndExchange(long expectedValue, long newValue) {

    /**
     * Atomically sets the value to {@code newValue} if the current value,
     * referred to as the <em>witness value</em>, {@code == expectedValue},
     * with memory effects as specified by
     * {@link VarHandle#compareAndExchangeAcquire}.
     *
     * @param expectedValue the expected value
     * @param newValue the new value
     * @return the witness value, which will be the same as the
     * expected value if successful
     * @since 9
     */
    public final long compareAndExchangeAcquire(long expectedValue, long newValue) {

    /**
     * Atomically sets the value to {@code newValue} if the current value,
     * referred to as the <em>witness value</em>, {@code == expectedValue},
     * with memory effects as specified by
     * {@link VarHandle#compareAndExchangeRelease}.
     *
     * @param expectedValue the expected value
     * @param newValue the new value
     * @return the witness value, which will be the same as the
     * expected value if successful
     * @since 9
     */
    public final long compareAndExchangeRelease(long expectedValue, long newValue) {

    /**
     * Possibly atomically sets the value to {@code newValue}
     * if the current value {@code == expectedValue},
     * with memory effects as specified by
     * {@link VarHandle#weakCompareAndSet}.
     *
     * @param expectedValue the expected value
     * @param newValue the new value
     * @return {@code true} if successful
     * @since 9
     */
    public final boolean weakCompareAndSetVolatile(long expectedValue, long newValue) {

    /**
     * Possibly atomically sets the value to {@code newValue}
     * if the current value {@code == expectedValue},
     * with memory effects as specified by
     * {@link VarHandle#weakCompareAndSetAcquire}.
     *
     * @param expectedValue the expected value
     * @param newValue the new value
     * @return {@code true} if successful
     * @since 9
     */
    public final boolean weakCompareAndSetAcquire(long expectedValue, long newValue) {

    /**
     * Possibly atomically sets the value to {@code newValue}
     * if the current value {@code == expectedValue},
     * with memory effects as specified by
     * {@link VarHandle#weakCompareAndSetRelease}.
     *
     * @param expectedValue the expected value
     * @param newValue the new value
     * @return {@code true} if successful
     * @since 9
     */
    public final boolean weakCompareAndSetRelease(long expectedValue, long newValue) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\concurrent\atomic\AtomicLongArray.java
    /**
     * Returns the current value of the element at index {@code i},
     * with memory semantics of reading as if the variable was declared
     * non-{@code volatile}.
     *
     * @param i the index
     * @return the value
     * @since 9
     */
    public final long getPlain(int i) {

    /**
     * Sets the element at index {@code i} to {@code newValue},
     * with memory semantics of setting as if the variable was
     * declared non-{@code volatile} and non-{@code final}.
     *
     * @param i the index
     * @param newValue the new value
     * @since 9
     */
    public final void setPlain(int i, long newValue) {

    /**
     * Returns the current value of the element at index {@code i},
     * with memory effects as specified by {@link VarHandle#getOpaque}.
     *
     * @param i the index
     * @return the value
     * @since 9
     */
    public final long getOpaque(int i) {

    /**
     * Sets the element at index {@code i} to {@code newValue},
     * with memory effects as specified by {@link VarHandle#setOpaque}.
     *
     * @param i the index
     * @param newValue the new value
     * @since 9
     */
    public final void setOpaque(int i, long newValue) {

    /**
     * Returns the current value of the element at index {@code i},
     * with memory effects as specified by {@link VarHandle#getAcquire}.
     *
     * @param i the index
     * @return the value
     * @since 9
     */
    public final long getAcquire(int i) {

    /**
     * Sets the element at index {@code i} to {@code newValue},
     * with memory effects as specified by {@link VarHandle#setRelease}.
     *
     * @param i the index
     * @param newValue the new value
     * @since 9
     */
    public final void setRelease(int i, long newValue) {

    /**
     * Atomically sets the element at index {@code i} to {@code newValue}
     * if the element's current value, referred to as the <em>witness
     * value</em>, {@code == expectedValue},
     * with memory effects as specified by
     * {@link VarHandle#compareAndExchange}.
     *
     * @param i the index
     * @param expectedValue the expected value
     * @param newValue the new value
     * @return the witness value, which will be the same as the
     * expected value if successful
     * @since 9
     */
    public final long compareAndExchange(int i, long expectedValue, long newValue) {

    /**
     * Atomically sets the element at index {@code i} to {@code newValue}
     * if the element's current value, referred to as the <em>witness
     * value</em>, {@code == expectedValue},
     * with memory effects as specified by
     * {@link VarHandle#compareAndExchangeAcquire}.
     *
     * @param i the index
     * @param expectedValue the expected value
     * @param newValue the new value
     * @return the witness value, which will be the same as the
     * expected value if successful
     * @since 9
     */
    public final long compareAndExchangeAcquire(int i, long expectedValue, long newValue) {

    /**
     * Atomically sets the element at index {@code i} to {@code newValue}
     * if the element's current value, referred to as the <em>witness
     * value</em>, {@code == expectedValue},
     * with memory effects as specified by
     * {@link VarHandle#compareAndExchangeRelease}.
     *
     * @param i the index
     * @param expectedValue the expected value
     * @param newValue the new value
     * @return the witness value, which will be the same as the
     * expected value if successful
     * @since 9
     */
    public final long compareAndExchangeRelease(int i, long expectedValue, long newValue) {

    /**
     * Possibly atomically sets the element at index {@code i} to
     * {@code newValue} if the element's current value {@code == expectedValue},
     * with memory effects as specified by
     * {@link VarHandle#weakCompareAndSet}.
     *
     * @param i the index
     * @param expectedValue the expected value
     * @param newValue the new value
     * @return {@code true} if successful
     * @since 9
     */
    public final boolean weakCompareAndSetVolatile(int i, long expectedValue, long newValue) {

    /**
     * Possibly atomically sets the element at index {@code i} to
     * {@code newValue} if the element's current value {@code == expectedValue},
     * with memory effects as specified by
     * {@link VarHandle#weakCompareAndSetAcquire}.
     *
     * @param i the index
     * @param expectedValue the expected value
     * @param newValue the new value
     * @return {@code true} if successful
     * @since 9
     */
    public final boolean weakCompareAndSetAcquire(int i, long expectedValue, long newValue) {

    /**
     * Possibly atomically sets the element at index {@code i} to
     * {@code newValue} if the element's current value {@code == expectedValue},
     * with memory effects as specified by
     * {@link VarHandle#weakCompareAndSetRelease}.
     *
     * @param i the index
     * @param expectedValue the expected value
     * @param newValue the new value
     * @return {@code true} if successful
     * @since 9
     */
    public final boolean weakCompareAndSetRelease(int i, long expectedValue, long newValue) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\concurrent\atomic\AtomicReference.java
    /**
     * Returns the current value, with memory semantics of reading as
     * if the variable was declared non-{@code volatile}.
     *
     * @return the value
     * @since 9
     */
    public final V getPlain() {

    /**
     * Sets the value to {@code newValue}, with memory semantics
     * of setting as if the variable was declared non-{@code volatile}
     * and non-{@code final}.
     *
     * @param newValue the new value
     * @since 9
     */
    public final void setPlain(V newValue) {

    /**
     * Returns the current value,
     * with memory effects as specified by {@link VarHandle#getOpaque}.
     *
     * @return the value
     * @since 9
     */
    public final V getOpaque() {

    /**
     * Sets the value to {@code newValue},
     * with memory effects as specified by {@link VarHandle#setOpaque}.
     *
     * @param newValue the new value
     * @since 9
     */
    public final void setOpaque(V newValue) {

    /**
     * Returns the current value,
     * with memory effects as specified by {@link VarHandle#getAcquire}.
     *
     * @return the value
     * @since 9
     */
    public final V getAcquire() {

    /**
     * Sets the value to {@code newValue},
     * with memory effects as specified by {@link VarHandle#setRelease}.
     *
     * @param newValue the new value
     * @since 9
     */
    public final void setRelease(V newValue) {

    /**
     * Atomically sets the value to {@code newValue} if the current value,
     * referred to as the <em>witness value</em>, {@code == expectedValue},
     * with memory effects as specified by
     * {@link VarHandle#compareAndExchange}.
     *
     * @param expectedValue the expected value
     * @param newValue the new value
     * @return the witness value, which will be the same as the
     * expected value if successful
     * @since 9
     */
    public final V compareAndExchange(V expectedValue, V newValue) {

    /**
     * Atomically sets the value to {@code newValue} if the current value,
     * referred to as the <em>witness value</em>, {@code == expectedValue},
     * with memory effects as specified by
     * {@link VarHandle#compareAndExchangeAcquire}.
     *
     * @param expectedValue the expected value
     * @param newValue the new value
     * @return the witness value, which will be the same as the
     * expected value if successful
     * @since 9
     */
    public final V compareAndExchangeAcquire(V expectedValue, V newValue) {

    /**
     * Atomically sets the value to {@code newValue} if the current value,
     * referred to as the <em>witness value</em>, {@code == expectedValue},
     * with memory effects as specified by
     * {@link VarHandle#compareAndExchangeRelease}.
     *
     * @param expectedValue the expected value
     * @param newValue the new value
     * @return the witness value, which will be the same as the
     * expected value if successful
     * @since 9
     */
    public final V compareAndExchangeRelease(V expectedValue, V newValue) {

    /**
     * Possibly atomically sets the value to {@code newValue}
     * if the current value {@code == expectedValue},
     * with memory effects as specified by
     * {@link VarHandle#weakCompareAndSet}.
     *
     * @param expectedValue the expected value
     * @param newValue the new value
     * @return {@code true} if successful
     * @since 9
     */
    public final boolean weakCompareAndSetVolatile(V expectedValue, V newValue) {

    /**
     * Possibly atomically sets the value to {@code newValue}
     * if the current value {@code == expectedValue},
     * with memory effects as specified by
     * {@link VarHandle#weakCompareAndSetAcquire}.
     *
     * @param expectedValue the expected value
     * @param newValue the new value
     * @return {@code true} if successful
     * @since 9
     */
    public final boolean weakCompareAndSetAcquire(V expectedValue, V newValue) {

    /**
     * Possibly atomically sets the value to {@code newValue}
     * if the current value {@code == expectedValue},
     * with memory effects as specified by
     * {@link VarHandle#weakCompareAndSetRelease}.
     *
     * @param expectedValue the expected value
     * @param newValue the new value
     * @return {@code true} if successful
     * @since 9
     */
    public final boolean weakCompareAndSetRelease(V expectedValue, V newValue) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\concurrent\atomic\AtomicReferenceArray.java
    /**
     * Returns the current value of the element at index {@code i},
     * with memory semantics of reading as if the variable was declared
     * non-{@code volatile}.
     *
     * @param i the index
     * @return the value
     * @since 9
     */
    public final E getPlain(int i) {

    /**
     * Sets the element at index {@code i} to {@code newValue},
     * with memory semantics of setting as if the variable was
     * declared non-{@code volatile} and non-{@code final}.
     *
     * @param i the index
     * @param newValue the new value
     * @since 9
     */
    public final void setPlain(int i, E newValue) {

    /**
     * Returns the current value of the element at index {@code i},
     * with memory effects as specified by {@link VarHandle#getOpaque}.
     *
     * @param i the index
     * @return the value
     * @since 9
     */
    public final E getOpaque(int i) {

    /**
     * Sets the element at index {@code i} to {@code newValue},
     * with memory effects as specified by {@link VarHandle#setOpaque}.
     *
     * @param i the index
     * @param newValue the new value
     * @since 9
     */
    public final void setOpaque(int i, E newValue) {

    /**
     * Returns the current value of the element at index {@code i},
     * with memory effects as specified by {@link VarHandle#getAcquire}.
     *
     * @param i the index
     * @return the value
     * @since 9
     */
    public final E getAcquire(int i) {

    /**
     * Sets the element at index {@code i} to {@code newValue},
     * with memory effects as specified by {@link VarHandle#setRelease}.
     *
     * @param i the index
     * @param newValue the new value
     * @since 9
     */
    public final void setRelease(int i, E newValue) {

    /**
     * Atomically sets the element at index {@code i} to {@code newValue}
     * if the element's current value, referred to as the <em>witness
     * value</em>, {@code == expectedValue},
     * with memory effects as specified by
     * {@link VarHandle#compareAndExchange}.
     *
     * @param i the index
     * @param expectedValue the expected value
     * @param newValue the new value
     * @return the witness value, which will be the same as the
     * expected value if successful
     * @since 9
     */
    public final E compareAndExchange(int i, E expectedValue, E newValue) {

    /**
     * Atomically sets the element at index {@code i} to {@code newValue}
     * if the element's current value, referred to as the <em>witness
     * value</em>, {@code == expectedValue},
     * with memory effects as specified by
     * {@link VarHandle#compareAndExchangeAcquire}.
     *
     * @param i the index
     * @param expectedValue the expected value
     * @param newValue the new value
     * @return the witness value, which will be the same as the
     * expected value if successful
     * @since 9
     */
    public final E compareAndExchangeAcquire(int i, E expectedValue, E newValue) {

    /**
     * Atomically sets the element at index {@code i} to {@code newValue}
     * if the element's current value, referred to as the <em>witness
     * value</em>, {@code == expectedValue},
     * with memory effects as specified by
     * {@link VarHandle#compareAndExchangeRelease}.
     *
     * @param i the index
     * @param expectedValue the expected value
     * @param newValue the new value
     * @return the witness value, which will be the same as the
     * expected value if successful
     * @since 9
     */
    public final E compareAndExchangeRelease(int i, E expectedValue, E newValue) {

    /**
     * Possibly atomically sets the element at index {@code i} to
     * {@code newValue} if the element's current value {@code == expectedValue},
     * with memory effects as specified by
     * {@link VarHandle#weakCompareAndSet}.
     *
     * @param i the index
     * @param expectedValue the expected value
     * @param newValue the new value
     * @return {@code true} if successful
     * @since 9
     */
    public final boolean weakCompareAndSetVolatile(int i, E expectedValue, E newValue) {

    /**
     * Possibly atomically sets the element at index {@code i} to
     * {@code newValue} if the element's current value {@code == expectedValue},
     * with memory effects as specified by
     * {@link VarHandle#weakCompareAndSetAcquire}.
     *
     * @param i the index
     * @param expectedValue the expected value
     * @param newValue the new value
     * @return {@code true} if successful
     * @since 9
     */
    public final boolean weakCompareAndSetAcquire(int i, E expectedValue, E newValue) {

    /**
     * Possibly atomically sets the element at index {@code i} to
     * {@code newValue} if the element's current value {@code == expectedValue},
     * with memory effects as specified by
     * {@link VarHandle#weakCompareAndSetRelease}.
     *
     * @param i the index
     * @param expectedValue the expected value
     * @param newValue the new value
     * @return {@code true} if successful
     * @since 9
     */
    public final boolean weakCompareAndSetRelease(int i, E expectedValue, E newValue) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\concurrent\CompletableFuture.java
    /**
     * Returns a new incomplete CompletableFuture of the type to be
     * returned by a CompletionStage method. Subclasses should
     * normally override this method to return an instance of the same
     * class as this CompletableFuture. The default implementation
     * returns an instance of class CompletableFuture.
     *
     * @param <U> the type of the value
     * @return a new CompletableFuture
     * @since 9
     */
    public <U> CompletableFuture<U> newIncompleteFuture() {

    /**
     * Returns the default Executor used for async methods that do not
     * specify an Executor. This class uses the {@link
     * ForkJoinPool#commonPool()} if it supports more than one
     * parallel thread, or else an Executor using one thread per async
     * task.  This method may be overridden in subclasses to return
     * an Executor that provides at least one independent thread.
     *
     * @return the executor
     * @since 9
     */
    public Executor defaultExecutor() {

    /**
     * Returns a new CompletableFuture that is completed normally with
     * the same value as this CompletableFuture when it completes
     * normally. If this CompletableFuture completes exceptionally,
     * then the returned CompletableFuture completes exceptionally
     * with a CompletionException with this exception as cause. The
     * behavior is equivalent to {@code thenApply(x -> x)}. This
     * method may be useful as a form of "defensive copying", to
     * prevent clients from completing, while still being able to
     * arrange dependent actions.
     *
     * @return the new CompletableFuture
     * @since 9
     */
    public CompletableFuture<T> copy() {

    /**
     * Returns a new CompletionStage that is completed normally with
     * the same value as this CompletableFuture when it completes
     * normally, and cannot be independently completed or otherwise
     * used in ways not defined by the methods of interface {@link
     * CompletionStage}.  If this CompletableFuture completes
     * exceptionally, then the returned CompletionStage completes
     * exceptionally with a CompletionException with this exception as
     * cause.
     *
     * @return the new CompletionStage
     * @since 9
     */
    public CompletionStage<T> minimalCompletionStage() {

    /**
     * Completes this CompletableFuture with the result of
     * the given Supplier function invoked from an asynchronous
     * task using the given executor.
     *
     * @param supplier a function returning the value to be used
     * to complete this CompletableFuture
     * @param executor the executor to use for asynchronous execution
     * @return this CompletableFuture
     * @since 9
     */
    public CompletableFuture<T> completeAsync(Supplier<? extends T> supplier,
                                              Executor executor) {

    /**
     * Completes this CompletableFuture with the result of the given
     * Supplier function invoked from an asynchronous task using the
     * default executor.
     *
     * @param supplier a function returning the value to be used
     * to complete this CompletableFuture
     * @return this CompletableFuture
     * @since 9
     */
    public CompletableFuture<T> completeAsync(Supplier<? extends T> supplier) {

    /**
     * Exceptionally completes this CompletableFuture with
     * a {@link TimeoutException} if not otherwise completed
     * before the given timeout.
     *
     * @param timeout how long to wait before completing exceptionally
     *        with a TimeoutException, in units of {@code unit}
     * @param unit a {@code TimeUnit} determining how to interpret the
     *        {@code timeout} parameter
     * @return this CompletableFuture
     * @since 9
     */
    public CompletableFuture<T> orTimeout(long timeout, TimeUnit unit) {

    /**
     * Completes this CompletableFuture with the given value if not
     * otherwise completed before the given timeout.
     *
     * @param value the value to use upon timeout
     * @param timeout how long to wait before completing normally
     *        with the given value, in units of {@code unit}
     * @param unit a {@code TimeUnit} determining how to interpret the
     *        {@code timeout} parameter
     * @return this CompletableFuture
     * @since 9
     */
    public CompletableFuture<T> completeOnTimeout(T value, long timeout,
                                                  TimeUnit unit) {

    /**
     * Returns a new Executor that submits a task to the given base
     * executor after the given delay (or no delay if non-positive).
     * Each delay commences upon invocation of the returned executor's
     * {@code execute} method.
     *
     * @param delay how long to delay, in units of {@code unit}
     * @param unit a {@code TimeUnit} determining how to interpret the
     *        {@code delay} parameter
     * @param executor the base executor
     * @return the new delayed executor
     * @since 9
     */
    public static Executor delayedExecutor(long delay, TimeUnit unit,
                                           Executor executor) {

    /**
     * Returns a new Executor that submits a task to the default
     * executor after the given delay (or no delay if non-positive).
     * Each delay commences upon invocation of the returned executor's
     * {@code execute} method.
     *
     * @param delay how long to delay, in units of {@code unit}
     * @param unit a {@code TimeUnit} determining how to interpret the
     *        {@code delay} parameter
     * @return the new delayed executor
     * @since 9
     */
    public static Executor delayedExecutor(long delay, TimeUnit unit) {

    /**
     * Returns a new CompletionStage that is already completed with
     * the given value and supports only those methods in
     * interface {@link CompletionStage}.
     *
     * @param value the value
     * @param <U> the type of the value
     * @return the completed CompletionStage
     * @since 9
     */
    public static <U> CompletionStage<U> completedStage(U value) {

    /**
     * Returns a new CompletableFuture that is already completed
     * exceptionally with the given exception.
     *
     * @param ex the exception
     * @param <U> the type of the value
     * @return the exceptionally completed CompletableFuture
     * @since 9
     */
    public static <U> CompletableFuture<U> failedFuture(Throwable ex) {

    /**
     * Returns a new CompletionStage that is already completed
     * exceptionally with the given exception and supports only those
     * methods in interface {@link CompletionStage}.
     *
     * @param ex the exception
     * @param <U> the type of the value
     * @return the exceptionally completed CompletionStage
     * @since 9
     */
    public static <U> CompletionStage<U> failedStage(Throwable ex) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\concurrent\Flow.java
/**
 * Interrelated interfaces and static methods for establishing
 * flow-controlled components in which {@link Publisher Publishers}
 * produce items consumed by one or more {@link Subscriber
 * Subscribers}, each managed by a {@link Subscription
 * Subscription}.
 *
 * <p>These interfaces correspond to the <a
 * href="http://www.reactive-streams.org/"> reactive-streams</a>
 * specification.  They apply in both concurrent and distributed
 * asynchronous settings: All (seven) methods are defined in {@code
 * void} "one-way" message style. Communication relies on a simple form
 * of flow control (method {@link Subscription#request}) that can be
 * used to avoid resource management problems that may otherwise occur
 * in "push" based systems.
 *
 * <p><b>Examples.</b> A {@link Publisher} usually defines its own
 * {@link Subscription} implementation; constructing one in method
 * {@code subscribe} and issuing it to the calling {@link
 * Subscriber}. It publishes items to the subscriber asynchronously,
 * normally using an {@link Executor}.  For example, here is a very
 * simple publisher that only issues (when requested) a single {@code
 * TRUE} item to a single subscriber.  Because the subscriber receives
 * only a single item, this class does not use buffering and ordering
 * control required in most implementations (for example {@link
 * SubmissionPublisher}).
 *
 * <pre> {@code
 * class OneShotPublisher implements Publisher<Boolean> {
 *   private final ExecutorService executor = ForkJoinPool.commonPool(); // daemon-based
 *   private boolean subscribed; // true after first subscribe
 *   public synchronized void subscribe(Subscriber<? super Boolean> subscriber) {
 *     if (subscribed)
 *       subscriber.onError(new IllegalStateException()); // only one allowed
 *     else {
 *       subscribed = true;
 *       subscriber.onSubscribe(new OneShotSubscription(subscriber, executor));
 *     }
 *   }
 *   static class OneShotSubscription implements Subscription {
 *     private final Subscriber<? super Boolean> subscriber;
 *     private final ExecutorService executor;
 *     private Future<?> future; // to allow cancellation
 *     private boolean completed;
 *     OneShotSubscription(Subscriber<? super Boolean> subscriber,
 *                         ExecutorService executor) {
 *       this.subscriber = subscriber;
 *       this.executor = executor;
 *     }
 *     public synchronized void request(long n) {
 *       if (n != 0 && !completed) {
 *         completed = true;
 *         if (n < 0) {
 *           IllegalArgumentException ex = new IllegalArgumentException();
 *           executor.execute(() -> subscriber.onError(ex));
 *         } else {
 *           future = executor.submit(() -> {
 *             subscriber.onNext(Boolean.TRUE);
 *             subscriber.onComplete();
 *           });
 *         }
 *       }
 *     }
 *     public synchronized void cancel() {
 *       completed = true;
 *       if (future != null) future.cancel(false);
 *     }
 *   }
 * }}</pre>
 *
 * <p>A {@link Subscriber} arranges that items be requested and
 * processed.  Items (invocations of {@link Subscriber#onNext}) are
 * not issued unless requested, but multiple items may be requested.
 * Many Subscriber implementations can arrange this in the style of
 * the following example, where a buffer size of 1 single-steps, and
 * larger sizes usually allow for more efficient overlapped processing
 * with less communication; for example with a value of 64, this keeps
 * total outstanding requests between 32 and 64.
 * Because Subscriber method invocations for a given {@link
 * Subscription} are strictly ordered, there is no need for these
 * methods to use locks or volatiles unless a Subscriber maintains
 * multiple Subscriptions (in which case it is better to instead
 * define multiple Subscribers, each with its own Subscription).
 *
 * <pre> {@code
 * class SampleSubscriber<T> implements Subscriber<T> {
 *   final Consumer<? super T> consumer;
 *   Subscription subscription;
 *   final long bufferSize;
 *   long count;
 *   SampleSubscriber(long bufferSize, Consumer<? super T> consumer) {
 *     this.bufferSize = bufferSize;
 *     this.consumer = consumer;
 *   }
 *   public void onSubscribe(Subscription subscription) {
 *     long initialRequestSize = bufferSize;
 *     count = bufferSize - bufferSize / 2; // re-request when half consumed
 *     (this.subscription = subscription).request(initialRequestSize);
 *   }
 *   public void onNext(T item) {
 *     if (--count <= 0)
 *       subscription.request(count = bufferSize - bufferSize / 2);
 *     consumer.accept(item);
 *   }
 *   public void onError(Throwable ex) { ex.printStackTrace(); }
 *   public void onComplete() {}
 * }}</pre>
 *
 * <p>The default value of {@link #defaultBufferSize} may provide a
 * useful starting point for choosing request sizes and capacities in
 * Flow components based on expected rates, resources, and usages.
 * Or, when flow control is never needed, a subscriber may initially
 * request an effectively unbounded number of items, as in:
 *
 * <pre> {@code
 * class UnboundedSubscriber<T> implements Subscriber<T> {
 *   public void onSubscribe(Subscription subscription) {
 *     subscription.request(Long.MAX_VALUE); // effectively unbounded
 *   }
 *   public void onNext(T item) { use(item); }
 *   public void onError(Throwable ex) { ex.printStackTrace(); }
 *   public void onComplete() {}
 *   void use(T item) { ... }
 * }}</pre>
 *
 * @author Doug Lea
 * @since 9
 */
public final class Flow {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\concurrent\ForkJoinPool.java
    /**
     * Creates a {@code ForkJoinPool} with the given parameters.
     *
     * @param parallelism the parallelism level. For default value,
     * use {@link java.lang.Runtime#availableProcessors}.
     *
     * @param factory the factory for creating new threads. For
     * default value, use {@link #defaultForkJoinWorkerThreadFactory}.
     *
     * @param handler the handler for internal worker threads that
     * terminate due to unrecoverable errors encountered while
     * executing tasks. For default value, use {@code null}.
     *
     * @param asyncMode if true, establishes local first-in-first-out
     * scheduling mode for forked tasks that are never joined. This
     * mode may be more appropriate than default locally stack-based
     * mode in applications in which worker threads only process
     * event-style asynchronous tasks.  For default value, use {@code
     * false}.
     *
     * @param corePoolSize the number of threads to keep in the pool
     * (unless timed out after an elapsed keep-alive). Normally (and
     * by default) this is the same value as the parallelism level,
     * but may be set to a larger value to reduce dynamic overhead if
     * tasks regularly block. Using a smaller value (for example
     * {@code 0}) has the same effect as the default.
     *
     * @param maximumPoolSize the maximum number of threads allowed.
     * When the maximum is reached, attempts to replace blocked
     * threads fail.  (However, because creation and termination of
     * different threads may overlap, and may be managed by the given
     * thread factory, this value may be transiently exceeded.)  To
     * arrange the same value as is used by default for the common
     * pool, use {@code 256} plus the {@code parallelism} level. (By
     * default, the common pool allows a maximum of 256 spare
     * threads.)  Using a value (for example {@code
     * Integer.MAX_VALUE}) larger than the implementation's total
     * thread limit has the same effect as using this limit (which is
     * the default).
     *
     * @param minimumRunnable the minimum allowed number of core
     * threads not blocked by a join or {@link ManagedBlocker}.  To
     * ensure progress, when too few unblocked threads exist and
     * unexecuted tasks may exist, new threads are constructed, up to
     * the given maximumPoolSize.  For the default value, use {@code
     * 1}, that ensures liveness.  A larger value might improve
     * throughput in the presence of blocked activities, but might
     * not, due to increased overhead.  A value of zero may be
     * acceptable when submitted tasks cannot have dependencies
     * requiring additional threads.
     *
     * @param saturate if non-null, a predicate invoked upon attempts
     * to create more than the maximum total allowed threads.  By
     * default, when a thread is about to block on a join or {@link
     * ManagedBlocker}, but cannot be replaced because the
     * maximumPoolSize would be exceeded, a {@link
     * RejectedExecutionException} is thrown.  But if this predicate
     * returns {@code true}, then no exception is thrown, so the pool
     * continues to operate with fewer than the target number of
     * runnable threads, which might not ensure progress.
     *
     * @param keepAliveTime the elapsed time since last use before
     * a thread is terminated (and then later replaced if needed).
     * For the default value, use {@code 60, TimeUnit.SECONDS}.
     *
     * @param unit the time unit for the {@code keepAliveTime} argument
     *
     * @throws IllegalArgumentException if parallelism is less than or
     *         equal to zero, or is greater than implementation limit,
     *         or if maximumPoolSize is less than parallelism,
     *         of if the keepAliveTime is less than or equal to zero.
     * @throws NullPointerException if the factory is null
     * @throws SecurityException if a security manager exists and
     *         the caller is not permitted to modify threads
     *         because it does not hold {@link
     *         java.lang.RuntimePermission}{@code ("modifyThread")}
     * @since 9
     */
    public ForkJoinPool(int parallelism,
                        ForkJoinWorkerThreadFactory factory,
                        UncaughtExceptionHandler handler,
                        boolean asyncMode,
                        int corePoolSize,
                        int maximumPoolSize,
                        int minimumRunnable,
                        Predicate<? super ForkJoinPool> saturate,
                        long keepAliveTime,
                        TimeUnit unit) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\concurrent\ForkJoinTask.java
    /**
     * If the current thread is operating in a ForkJoinPool,
     * unschedules and returns, without executing, a task externally
     * submitted to the pool, if one is available. Availability may be
     * transient, so a {@code null} result does not necessarily imply
     * quiescence of the pool.  This method is designed primarily to
     * support extensions, and is unlikely to be useful otherwise.
     *
     * @return a task, or {@code null} if none are available
     * @since 9
     */
    protected static ForkJoinTask<?> pollSubmission() {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\concurrent\SubmissionPublisher.java
/**
 * A {@link Flow.Publisher} that asynchronously issues submitted
 * (non-null) items to current subscribers until it is closed.  Each
 * current subscriber receives newly submitted items in the same order
 * unless drops or exceptions are encountered.  Using a
 * SubmissionPublisher allows item generators to act as compliant <a
 * href="http://www.reactive-streams.org/"> reactive-streams</a>
 * Publishers relying on drop handling and/or blocking for flow
 * control.
 *
 * <p>A SubmissionPublisher uses the {@link Executor} supplied in its
 * constructor for delivery to subscribers. The best choice of
 * Executor depends on expected usage. If the generator(s) of
 * submitted items run in separate threads, and the number of
 * subscribers can be estimated, consider using a {@link
 * Executors#newFixedThreadPool}. Otherwise consider using the
 * default, normally the {@link ForkJoinPool#commonPool}.
 *
 * <p>Buffering allows producers and consumers to transiently operate
 * at different rates.  Each subscriber uses an independent buffer.
 * Buffers are created upon first use and expanded as needed up to the
 * given maximum. (The enforced capacity may be rounded up to the
 * nearest power of two and/or bounded by the largest value supported
 * by this implementation.)  Invocations of {@link
 * Flow.Subscription#request(long) request} do not directly result in
 * buffer expansion, but risk saturation if unfilled requests exceed
 * the maximum capacity.  The default value of {@link
 * Flow#defaultBufferSize()} may provide a useful starting point for
 * choosing a capacity based on expected rates, resources, and usages.
 *
 * <p>Publication methods support different policies about what to do
 * when buffers are saturated. Method {@link #submit(Object) submit}
 * blocks until resources are available. This is simplest, but least
 * responsive.  The {@code offer} methods may drop items (either
 * immediately or with bounded timeout), but provide an opportunity to
 * interpose a handler and then retry.
 *
 * <p>If any Subscriber method throws an exception, its subscription
 * is cancelled.  If a handler is supplied as a constructor argument,
 * it is invoked before cancellation upon an exception in method
 * {@link Flow.Subscriber#onNext onNext}, but exceptions in methods
 * {@link Flow.Subscriber#onSubscribe onSubscribe},
 * {@link Flow.Subscriber#onError(Throwable) onError} and
 * {@link Flow.Subscriber#onComplete() onComplete} are not recorded or
 * handled before cancellation.  If the supplied Executor throws
 * {@link RejectedExecutionException} (or any other RuntimeException
 * or Error) when attempting to execute a task, or a drop handler
 * throws an exception when processing a dropped item, then the
 * exception is rethrown. In these cases, not all subscribers will
 * have been issued the published item. It is usually good practice to
 * {@link #closeExceptionally closeExceptionally} in these cases.
 *
 * <p>Method {@link #consume(Consumer)} simplifies support for a
 * common case in which the only action of a subscriber is to request
 * and process all items using a supplied function.
 *
 * <p>This class may also serve as a convenient base for subclasses
 * that generate items, and use the methods in this class to publish
 * them.  For example here is a class that periodically publishes the
 * items generated from a supplier. (In practice you might add methods
 * to independently start and stop generation, to share Executors
 * among publishers, and so on, or use a SubmissionPublisher as a
 * component rather than a superclass.)
 *
 * <pre> {@code
 * class PeriodicPublisher<T> extends SubmissionPublisher<T> {
 *   final ScheduledFuture<?> periodicTask;
 *   final ScheduledExecutorService scheduler;
 *   PeriodicPublisher(Executor executor, int maxBufferCapacity,
 *                     Supplier<? extends T> supplier,
 *                     long period, TimeUnit unit) {
 *     super(executor, maxBufferCapacity);
 *     scheduler = new ScheduledThreadPoolExecutor(1);
 *     periodicTask = scheduler.scheduleAtFixedRate(
 *       () -> submit(supplier.get()), 0, period, unit);
 *   }
 *   public void close() {
 *     periodicTask.cancel(false);
 *     scheduler.shutdown();
 *     super.close();
 *   }
 * }}</pre>
 *
 * <p>Here is an example of a {@link Flow.Processor} implementation.
 * It uses single-step requests to its publisher for simplicity of
 * illustration. A more adaptive version could monitor flow using the
 * lag estimate returned from {@code submit}, along with other utility
 * methods.
 *
 * <pre> {@code
 * class TransformProcessor<S,T> extends SubmissionPublisher<T>
 *   implements Flow.Processor<S,T> {
 *   final Function<? super S, ? extends T> function;
 *   Flow.Subscription subscription;
 *   TransformProcessor(Executor executor, int maxBufferCapacity,
 *                      Function<? super S, ? extends T> function) {
 *     super(executor, maxBufferCapacity);
 *     this.function = function;
 *   }
 *   public void onSubscribe(Flow.Subscription subscription) {
 *     (this.subscription = subscription).request(1);
 *   }
 *   public void onNext(S item) {
 *     subscription.request(1);
 *     submit(function.apply(item));
 *   }
 *   public void onError(Throwable ex) { closeExceptionally(ex); }
 *   public void onComplete() { close(); }
 * }}</pre>
 *
 * @param <T> the published item type
 * @author Doug Lea
 * @since 9
 */
public class SubmissionPublisher<T> implements Flow.Publisher<T>,
                                               AutoCloseable {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\concurrent\TimeUnit.java
    /**
     * Converts this {@code TimeUnit} to the equivalent {@code ChronoUnit}.
     *
     * @return the converted equivalent ChronoUnit
     * @since 9
     */
    public ChronoUnit toChronoUnit() {

    /**
     * Converts a {@code ChronoUnit} to the equivalent {@code TimeUnit}.
     *
     * @param chronoUnit the ChronoUnit to convert
     * @return the converted equivalent TimeUnit
     * @throws IllegalArgumentException if {@code chronoUnit} has no
     *         equivalent TimeUnit
     * @throws NullPointerException if {@code chronoUnit} is null
     * @since 9
     */
    public static TimeUnit of(ChronoUnit chronoUnit) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\Currency.java
    /**
     * Returns the 3 digit ISO 4217 numeric code of this currency as a {@code String}.
     * Unlike {@link getNumericCode()}, which returns the numeric code as {@code int},
     * this method always returns the numeric code as a 3 digit string.
     * e.g. a numeric value of 32 would be returned as "032",
     * and a numeric value of 6 would be returned as "006".
     *
     * @return the 3 digit ISO 4217 numeric code of this currency as a {@code String}
     * @since 9
     */
    public String getNumericCodeAsString() {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\Enumeration.java
    /**
     * Returns an {@link Iterator} that traverses the remaining elements
     * covered by this enumeration. Traversal is undefined if any methods
     * are called on this enumeration after the call to {@code asIterator}.
     *
     * @apiNote
     * This method is intended to help adapt code that produces
     * {@code Enumeration} instances to code that consumes {@code Iterator}
     * instances. For example, the {@link java.util.jar.JarFile#entries
     * JarFile.entries()} method returns an {@code Enumeration<JarEntry>}.
     * This can be turned into an {@code Iterator}, and then the
     * {@code forEachRemaining()} method can be used:
     *
     * <pre>{@code
     *     JarFile jarFile = ... ;
     *     jarFile.entries().asIterator().forEachRemaining(entry -> { ... });
     * }</pre>
     *
     * (Note that there is also a {@link java.util.jar.JarFile#stream
     * JarFile.stream()} method that returns a {@code Stream} of entries,
     * which may be more convenient in some cases.)
     *
     * @implSpec
     * The default implementation returns an {@code Iterator} whose
     * {@link Iterator#hasNext hasNext} method calls this Enumeration's
     * {@code hasMoreElements} method, whose {@link Iterator#next next}
     * method calls this Enumeration's {@code nextElement} method, and
     * whose {@link Iterator#remove remove} method throws
     * {@code UnsupportedOperationException}.
     *
     * @return an Iterator representing the remaining elements of this Enumeration
     *
     * @since 9
     */
    default Iterator<E> asIterator() {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\ImmutableCollections.java
/**
 * A unified serialization proxy class for the immutable collections.
 *
 * @serial
 * @since 9
 */
final class CollSer implements Serializable {

    /**
     * Indicates the type of collection that is serialized.
     * The low order 8 bits have the value 1 for an immutable
     * {@code List}, 2 for an immutable {@code Set}, and 3 for
     * an immutable {@code Map}. Any other value causes an
     * {@link InvalidObjectException} to be thrown. The high
     * order 24 bits are zero when an instance is serialized,
     * and they are ignored when an instance is deserialized.
     * They can thus be used by future implementations without
     * causing compatibility issues.
     *
     * <p>The tag value also determines the interpretation of the
     * transient {@code Object[] array} field.
     * For {@code List} and {@code Set}, the array's length is the size
     * of the collection, and the array contains the elements of the collection.
     * Null elements are not allowed. For {@code Set}, duplicate elements
     * are not allowed.
     *
     * <p>For {@code Map}, the array's length is twice the number of mappings
     * present in the map. The array length is necessarily even.
     * The array contains a succession of key and value pairs:
     * {@code k1, v1, k2, v2, ..., kN, vN.} Nulls are not allowed,
     * and duplicate keys are not allowed.
     *
     * @serial
     * @since 9
     */
    private final int tag;

    /**
     * @serial
     * @since 9
     */
    private transient Object[] array;

    /**
     * Reads objects from the stream and stores them
     * in the transient {@code Object[] array} field.
     *
     * @serialData
     * A nonnegative int, indicating the count of objects,
     * followed by that many objects.
     *
     * @param ois the ObjectInputStream from which data is read
     * @throws IOException if an I/O error occurs
     * @throws ClassNotFoundException if a serialized class cannot be loaded
     * @throws InvalidObjectException if the count is negative
     * @since 9
     */
    private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {

    /**
     * Writes objects to the stream from
     * the transient {@code Object[] array} field.
     *
     * @serialData
     * A nonnegative int, indicating the count of objects,
     * followed by that many objects.
     *
     * @param oos the ObjectOutputStream to which data is written
     * @throws IOException if an I/O error occurs
     * @since 9
     */
    private void writeObject(ObjectOutputStream oos) throws IOException {

    /**
     * Creates and returns an immutable collection from this proxy class.
     * The instance returned is created as if by calling one of the
     * static factory methods for
     * <a href="List.html#immutable">List</a>,
     * <a href="Map.html#immutable">Map</a>, or
     * <a href="Set.html#immutable">Set</a>.
     * This proxy class is the serial form for all immutable collection instances,
     * regardless of implementation type. This is necessary to ensure that the
     * existence of any particular implementation type is kept out of the
     * serialized form.
     *
     * @return a collection created from this proxy object
     * @throws InvalidObjectException if the tag value is illegal or if an exception
     *         is thrown during creation of the collection
     * @throws ObjectStreamException if another serialization error has occurred
     * @since 9
     */
    private Object readResolve() throws ObjectStreamException {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\jar\JarFile.java
    /**
     * The version that represents the unversioned configuration of a multi-release jar file.
     *
     * @return Runtime.Version that represents the unversioned configuration
     *
     * @since 9
     */
    public static Runtime.Version baseVersion() {

    /**
     * The version that represents the effective runtime versioned configuration of a
     * multi-release jar file.  In most cases, {@code runtimeVersion()} is equal to
     * {@code Runtime.version()}.  However, if the {@code jdk.util.jar.version} property is set,
     * {@code runtimeVersion()} is derived from that property and may not be equal to
     * {@code Runtime.version()}.
     *
     * @return Runtime.Version that represents the runtime versioned configuration
     *
     * @since 9
     */
    public static Runtime.Version runtimeVersion() {

    /**
     * Creates a new {@code JarFile} to read from the specified
     * {@code File} object in the specified mode.  The mode argument
     * must be either {@code OPEN_READ} or {@code OPEN_READ | OPEN_DELETE}.
     * The version argument, after being converted to a canonical form, is
     * used to configure the {@code JarFile} for processing
     * multi-release jar files.
     * <p>
     * The canonical form derived from the version parameter is
     * {@code Runtime.Version.parse(Integer.toString(n))} where {@code n} is
     * {@code Math.max(version.major(), JarFile.baseVersion().major())}.
     *
     * @param file the jar file to be opened for reading
     * @param verify whether or not to verify the jar file if
     * it is signed.
     * @param mode the mode in which the file is to be opened
     * @param version specifies the release version for a multi-release jar file
     * @throws IOException if an I/O error has occurred
     * @throws IllegalArgumentException
     *         if the {@code mode} argument is invalid
     * @throws SecurityException if access to the file is denied
     *         by the SecurityManager
     * @throws NullPointerException if {@code version} is {@code null}
     * @since 9
     */
    public JarFile(File file, boolean verify, int mode, Runtime.Version version) throws IOException {

    /**
     * Returns the maximum version used when searching for versioned entries.
     *
     * @return the maximum version
     * @since 9
     */
    public final Runtime.Version getVersion() {

    /**
     * Indicates whether or not this jar file is a multi-release jar file.
     *
     * @return true if this JarFile is a multi-release jar file
     * @since 9
     */
    public final boolean isMultiRelease() {

    /**
     * Returns the real name of a {@code JarEntry}.  If this {@code JarFile} is
     * a multi-release jar file and is configured to be processed as such, the
     * name returned by this method is the path name of the versioned entry
     * that the {@code JarEntry} represents, rather than the path name of the
     * base entry that {@link JarEntry#getName()} returns.  If the
     * {@code JarEntry} does not represent a versioned entry, or the
     * jar file is not a multi-release jar file or {@code JarFile} is not
     * configured for processing a multi-release jar file, this method returns
     * the same name that {@link JarEntry#getName()} returns.
     *
     * @param entry the JarEntry
     * @return the real name of the JarEntry
     * @since 9
     */
    String getRealName(JarEntry entry) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\KeyValueHolder.java
/**
 * An immutable container for a key and a value, suitable for use
 * in creating and populating {@code Map} instances.
 *
 * <p>This is a <a href="../lang/doc-files/ValueBased.html">value-based</a>
 * class; use of identity-sensitive operations (including reference equality
 * ({@code ==}), identity hash code, or synchronization) on instances of
 * {@code KeyValueHolder} may have unpredictable results and should be avoided.
 *
 * @apiNote
 * This class is not public. Instances can be created using the
 * {@link Map#entry Map.entry(k, v)} factory method, which is public.
 *
 * <p>This class differs from AbstractMap.SimpleImmutableEntry in the following ways:
 * it is not serializable, it is final, and its key and value must be non-null.
 *
 * @param <K> the key type
 * @param <V> the value type
 *
 * @see Map#ofEntries Map.ofEntries()
 * @since 9
 */
final class KeyValueHolder<K,V> implements Map.Entry<K,V> {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\List.java
    /**
     * Returns an immutable list containing zero elements.
     *
     * See <a href="#immutable">Immutable List Static Factory Methods</a> for details.
     *
     * @param <E> the {@code List}'s element type
     * @return an empty {@code List}
     *
     * @since 9
     */
    static <E> List<E> of() {

    /**
     * Returns an immutable list containing one element.
     *
     * See <a href="#immutable">Immutable List Static Factory Methods</a> for details.
     *
     * @param <E> the {@code List}'s element type
     * @param e1 the single element
     * @return a {@code List} containing the specified element
     * @throws NullPointerException if the element is {@code null}
     *
     * @since 9
     */
    static <E> List<E> of(E e1) {

    /**
     * Returns an immutable list containing two elements.
     *
     * See <a href="#immutable">Immutable List Static Factory Methods</a> for details.
     *
     * @param <E> the {@code List}'s element type
     * @param e1 the first element
     * @param e2 the second element
     * @return a {@code List} containing the specified elements
     * @throws NullPointerException if an element is {@code null}
     *
     * @since 9
     */
    static <E> List<E> of(E e1, E e2) {

    /**
     * Returns an immutable list containing three elements.
     *
     * See <a href="#immutable">Immutable List Static Factory Methods</a> for details.
     *
     * @param <E> the {@code List}'s element type
     * @param e1 the first element
     * @param e2 the second element
     * @param e3 the third element
     * @return a {@code List} containing the specified elements
     * @throws NullPointerException if an element is {@code null}
     *
     * @since 9
     */
    static <E> List<E> of(E e1, E e2, E e3) {

    /**
     * Returns an immutable list containing four elements.
     *
     * See <a href="#immutable">Immutable List Static Factory Methods</a> for details.
     *
     * @param <E> the {@code List}'s element type
     * @param e1 the first element
     * @param e2 the second element
     * @param e3 the third element
     * @param e4 the fourth element
     * @return a {@code List} containing the specified elements
     * @throws NullPointerException if an element is {@code null}
     *
     * @since 9
     */
    static <E> List<E> of(E e1, E e2, E e3, E e4) {

    /**
     * Returns an immutable list containing five elements.
     *
     * See <a href="#immutable">Immutable List Static Factory Methods</a> for details.
     *
     * @param <E> the {@code List}'s element type
     * @param e1 the first element
     * @param e2 the second element
     * @param e3 the third element
     * @param e4 the fourth element
     * @param e5 the fifth element
     * @return a {@code List} containing the specified elements
     * @throws NullPointerException if an element is {@code null}
     *
     * @since 9
     */
    static <E> List<E> of(E e1, E e2, E e3, E e4, E e5) {

    /**
     * Returns an immutable list containing six elements.
     *
     * See <a href="#immutable">Immutable List Static Factory Methods</a> for details.
     *
     * @param <E> the {@code List}'s element type
     * @param e1 the first element
     * @param e2 the second element
     * @param e3 the third element
     * @param e4 the fourth element
     * @param e5 the fifth element
     * @param e6 the sixth element
     * @return a {@code List} containing the specified elements
     * @throws NullPointerException if an element is {@code null}
     *
     * @since 9
     */
    static <E> List<E> of(E e1, E e2, E e3, E e4, E e5, E e6) {

    /**
     * Returns an immutable list containing seven elements.
     *
     * See <a href="#immutable">Immutable List Static Factory Methods</a> for details.
     *
     * @param <E> the {@code List}'s element type
     * @param e1 the first element
     * @param e2 the second element
     * @param e3 the third element
     * @param e4 the fourth element
     * @param e5 the fifth element
     * @param e6 the sixth element
     * @param e7 the seventh element
     * @return a {@code List} containing the specified elements
     * @throws NullPointerException if an element is {@code null}
     *
     * @since 9
     */
    static <E> List<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7) {

    /**
     * Returns an immutable list containing eight elements.
     *
     * See <a href="#immutable">Immutable List Static Factory Methods</a> for details.
     *
     * @param <E> the {@code List}'s element type
     * @param e1 the first element
     * @param e2 the second element
     * @param e3 the third element
     * @param e4 the fourth element
     * @param e5 the fifth element
     * @param e6 the sixth element
     * @param e7 the seventh element
     * @param e8 the eighth element
     * @return a {@code List} containing the specified elements
     * @throws NullPointerException if an element is {@code null}
     *
     * @since 9
     */
    static <E> List<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8) {

    /**
     * Returns an immutable list containing nine elements.
     *
     * See <a href="#immutable">Immutable List Static Factory Methods</a> for details.
     *
     * @param <E> the {@code List}'s element type
     * @param e1 the first element
     * @param e2 the second element
     * @param e3 the third element
     * @param e4 the fourth element
     * @param e5 the fifth element
     * @param e6 the sixth element
     * @param e7 the seventh element
     * @param e8 the eighth element
     * @param e9 the ninth element
     * @return a {@code List} containing the specified elements
     * @throws NullPointerException if an element is {@code null}
     *
     * @since 9
     */
    static <E> List<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9) {

    /**
     * Returns an immutable list containing ten elements.
     *
     * See <a href="#immutable">Immutable List Static Factory Methods</a> for details.
     *
     * @param <E> the {@code List}'s element type
     * @param e1 the first element
     * @param e2 the second element
     * @param e3 the third element
     * @param e4 the fourth element
     * @param e5 the fifth element
     * @param e6 the sixth element
     * @param e7 the seventh element
     * @param e8 the eighth element
     * @param e9 the ninth element
     * @param e10 the tenth element
     * @return a {@code List} containing the specified elements
     * @throws NullPointerException if an element is {@code null}
     *
     * @since 9
     */
    static <E> List<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10) {

    /**
     * Returns an immutable list containing an arbitrary number of elements.
     * See <a href="#immutable">Immutable List Static Factory Methods</a> for details.
     *
     * @apiNote
     * This method also accepts a single array as an argument. The element type of
     * the resulting list will be the component type of the array, and the size of
     * the list will be equal to the length of the array. To create a list with
     * a single element that is an array, do the following:
     *
     * <pre>{@code
     *     String[] array = ... ;
     *     List<String[]> list = List.<String[]>of(array);
     * }</pre>
     *
     * This will cause the {@link List#of(Object) List.of(E)} method
     * to be invoked instead.
     *
     * @param <E> the {@code List}'s element type
     * @param elements the elements to be contained in the list
     * @return a {@code List} containing the specified elements
     * @throws NullPointerException if an element is {@code null} or if the array is {@code null}
     *
     * @since 9
     */
    @SafeVarargs
    @SuppressWarnings("varargs")
    static <E> List<E> of(E... elements) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\logging\FileHandler.java
    /**
     * Initialize a {@code FileHandler} to write to a set of files
     * with optional append.  When (approximately) the given limit has
     * been written to one file, another file will be opened.  The
     * output will cycle through a set of count files.
     * <p>
     * The {@code FileHandler} is configured based on {@code LogManager}
     * properties (or their default values) except that the given pattern
     * argument is used as the filename pattern, the file limit is
     * set to the limit argument, and the file count is set to the
     * given count argument, and the append mode is set to the given
     * {@code append} argument.
     * <p>
     * The count must be at least 1.
     *
     * @param pattern  the pattern for naming the output file
     * @param limit  the maximum number of bytes to write to any one file
     * @param count  the number of files to use
     * @param append  specifies append mode
     * @exception  IOException if there are IO problems opening the files.
     * @exception  SecurityException  if a security manager exists and if
     *             the caller does not have {@code LoggingPermission("control")}.
     * @exception  IllegalArgumentException if {@code limit < 0}, or {@code count < 1}.
     * @exception  IllegalArgumentException if pattern is an empty string
     *
     * @since 9
     *
     */
    public FileHandler(String pattern, long limit, int count, boolean append)
                                        throws IOException {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\logging\Logger.java
    /**
     * Log a message, specifying source class, method, and resource bundle,
     * with an optional list of message parameters.
     * <p>
     * If the logger is currently enabled for the given message
     * {@code level} then a corresponding {@code LogRecord} is created
     * and forwarded to all the registered output {@code Handler} objects.
     * <p>
     * The {@code msg} string is localized using the given resource bundle.
     * If the resource bundle is {@code null}, then the {@code msg} string is not
     * localized.
     * <p>
     * @param   level   One of the message level identifiers, e.g., {@code SEVERE}
     * @param   bundle  Resource bundle to localize {@code msg};
     *                  can be {@code null}.
     * @param   msg     The string message (or a key in the message catalog)
     * @param   params  Parameters to the message (optional, may be none).
     * @since 9
     */
    public void logrb(Level level, ResourceBundle bundle, String msg, Object... params) {

    /**
     * Log a message, specifying source class, method, and resource bundle,
     * with associated Throwable information.
     * <p>
     * If the logger is currently enabled for the given message
     * {@code level} then the given arguments are stored in a {@code LogRecord}
     * which is forwarded to all registered output handlers.
     * <p>
     * The {@code msg} string is localized using the given resource bundle.
     * If the resource bundle is {@code null}, then the {@code msg} string is not
     * localized.
     * <p>
     * Note that the {@code thrown} argument is stored in the {@code LogRecord}
     * {@code thrown} property, rather than the {@code LogRecord}
     * {@code parameters} property.  Thus it is
     * processed specially by output {@code Formatter} objects and is not treated
     * as a formatting parameter to the {@code LogRecord} {@code message}
     * property.
     * <p>
     * @param   level   One of the message level identifiers, e.g., {@code SEVERE}
     * @param   bundle  Resource bundle to localize {@code msg};
     *                  can be {@code null}.
     * @param   msg     The string message (or a key in the message catalog)
     * @param   thrown  Throwable associated with the log message.
     * @since 9
     */
    public void logrb(Level level, ResourceBundle bundle, String msg,
            Throwable thrown) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\logging\LogManager.java
    /**
     * Adds a configuration listener to be invoked each time the logging
     * configuration is read.
     * If the listener is already registered the method does nothing.
     * <p>
     * The listener is invoked with privileges that are restricted by the
     * calling context of this method.
     * The order in which the listeners are invoked is unspecified.
     * <p>
     * It is recommended that listeners do not throw errors or exceptions.
     *
     * If a listener terminates with an uncaught error or exception then
     * the first exception will be propagated to the caller of
     * {@link #readConfiguration()} (or {@link #readConfiguration(java.io.InputStream)})
     * after all listeners have been invoked.
     *
     * @implNote If more than one listener terminates with an uncaught error or
     * exception, an implementation may record the additional errors or
     * exceptions as {@linkplain Throwable#addSuppressed(java.lang.Throwable)
     * suppressed exceptions}.
     *
     * @param listener A configuration listener that will be invoked after the
     *        configuration changed.
     * @return This LogManager.
     * @throws SecurityException if a security manager exists and if the
     * caller does not have LoggingPermission("control").
     * @throws NullPointerException if the listener is null.
     *
     * @since 9
     */
    public LogManager addConfigurationListener(Runnable listener) {

    /**
     * Removes a previously registered configuration listener.
     *
     * Returns silently if the listener is not found.
     *
     * @param listener the configuration listener to remove.
     * @throws NullPointerException if the listener is null.
     * @throws SecurityException if a security manager exists and if the
     * caller does not have LoggingPermission("control").
     *
     * @since 9
     */
    public void removeConfigurationListener(Runnable listener) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\logging\LogRecord.java
    /**
     * Event time.
     * @since 9
     */
    private Instant instant;

    /**
     * Gets the instant that the event occurred.
     *
     * @return the instant that the event occurred.
     *
     * @since 9
     */
    public Instant getInstant() {

    /**
     * Sets the instant that the event occurred.
     * <p>
     * If the given {@code instant} represents a point on the time-line too
     * far in the future or past to fit in a {@code long} milliseconds and
     * nanoseconds adjustment, then an {@code ArithmeticException} will be
     * thrown.
     *
     * @param instant the instant that the event occurred.
     *
     * @throws NullPointerException if {@code instant} is null.
     * @throws ArithmeticException if numeric overflow would occur while
     *         calling {@link Instant#toEpochMilli() instant.toEpochMilli()}.
     *
     * @since 9
     */
    public void setInstant(Instant instant) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\Map.java
    /**
     * Returns an immutable map containing zero mappings.
     * See <a href="#immutable">Immutable Map Static Factory Methods</a> for details.
     *
     * @param <K> the {@code Map}'s key type
     * @param <V> the {@code Map}'s value type
     * @return an empty {@code Map}
     *
     * @since 9
     */
    static <K, V> Map<K, V> of() {

    /**
     * Returns an immutable map containing a single mapping.
     * See <a href="#immutable">Immutable Map Static Factory Methods</a> for details.
     *
     * @param <K> the {@code Map}'s key type
     * @param <V> the {@code Map}'s value type
     * @param k1 the mapping's key
     * @param v1 the mapping's value
     * @return a {@code Map} containing the specified mapping
     * @throws NullPointerException if the key or the value is {@code null}
     *
     * @since 9
     */
    static <K, V> Map<K, V> of(K k1, V v1) {

    /**
     * Returns an immutable map containing two mappings.
     * See <a href="#immutable">Immutable Map Static Factory Methods</a> for details.
     *
     * @param <K> the {@code Map}'s key type
     * @param <V> the {@code Map}'s value type
     * @param k1 the first mapping's key
     * @param v1 the first mapping's value
     * @param k2 the second mapping's key
     * @param v2 the second mapping's value
     * @return a {@code Map} containing the specified mappings
     * @throws IllegalArgumentException if the keys are duplicates
     * @throws NullPointerException if any key or value is {@code null}
     *
     * @since 9
     */
    static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2) {

    /**
     * Returns an immutable map containing three mappings.
     * See <a href="#immutable">Immutable Map Static Factory Methods</a> for details.
     *
     * @param <K> the {@code Map}'s key type
     * @param <V> the {@code Map}'s value type
     * @param k1 the first mapping's key
     * @param v1 the first mapping's value
     * @param k2 the second mapping's key
     * @param v2 the second mapping's value
     * @param k3 the third mapping's key
     * @param v3 the third mapping's value
     * @return a {@code Map} containing the specified mappings
     * @throws IllegalArgumentException if there are any duplicate keys
     * @throws NullPointerException if any key or value is {@code null}
     *
     * @since 9
     */
    static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3) {

    /**
     * Returns an immutable map containing four mappings.
     * See <a href="#immutable">Immutable Map Static Factory Methods</a> for details.
     *
     * @param <K> the {@code Map}'s key type
     * @param <V> the {@code Map}'s value type
     * @param k1 the first mapping's key
     * @param v1 the first mapping's value
     * @param k2 the second mapping's key
     * @param v2 the second mapping's value
     * @param k3 the third mapping's key
     * @param v3 the third mapping's value
     * @param k4 the fourth mapping's key
     * @param v4 the fourth mapping's value
     * @return a {@code Map} containing the specified mappings
     * @throws IllegalArgumentException if there are any duplicate keys
     * @throws NullPointerException if any key or value is {@code null}
     *
     * @since 9
     */
    static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4) {

    /**
     * Returns an immutable map containing five mappings.
     * See <a href="#immutable">Immutable Map Static Factory Methods</a> for details.
     *
     * @param <K> the {@code Map}'s key type
     * @param <V> the {@code Map}'s value type
     * @param k1 the first mapping's key
     * @param v1 the first mapping's value
     * @param k2 the second mapping's key
     * @param v2 the second mapping's value
     * @param k3 the third mapping's key
     * @param v3 the third mapping's value
     * @param k4 the fourth mapping's key
     * @param v4 the fourth mapping's value
     * @param k5 the fifth mapping's key
     * @param v5 the fifth mapping's value
     * @return a {@code Map} containing the specified mappings
     * @throws IllegalArgumentException if there are any duplicate keys
     * @throws NullPointerException if any key or value is {@code null}
     *
     * @since 9
     */
    static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5) {

    /**
     * Returns an immutable map containing six mappings.
     * See <a href="#immutable">Immutable Map Static Factory Methods</a> for details.
     *
     * @param <K> the {@code Map}'s key type
     * @param <V> the {@code Map}'s value type
     * @param k1 the first mapping's key
     * @param v1 the first mapping's value
     * @param k2 the second mapping's key
     * @param v2 the second mapping's value
     * @param k3 the third mapping's key
     * @param v3 the third mapping's value
     * @param k4 the fourth mapping's key
     * @param v4 the fourth mapping's value
     * @param k5 the fifth mapping's key
     * @param v5 the fifth mapping's value
     * @param k6 the sixth mapping's key
     * @param v6 the sixth mapping's value
     * @return a {@code Map} containing the specified mappings
     * @throws IllegalArgumentException if there are any duplicate keys
     * @throws NullPointerException if any key or value is {@code null}
     *
     * @since 9
     */
    static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5,
                               K k6, V v6) {

    /**
     * Returns an immutable map containing seven mappings.
     * See <a href="#immutable">Immutable Map Static Factory Methods</a> for details.
     *
     * @param <K> the {@code Map}'s key type
     * @param <V> the {@code Map}'s value type
     * @param k1 the first mapping's key
     * @param v1 the first mapping's value
     * @param k2 the second mapping's key
     * @param v2 the second mapping's value
     * @param k3 the third mapping's key
     * @param v3 the third mapping's value
     * @param k4 the fourth mapping's key
     * @param v4 the fourth mapping's value
     * @param k5 the fifth mapping's key
     * @param v5 the fifth mapping's value
     * @param k6 the sixth mapping's key
     * @param v6 the sixth mapping's value
     * @param k7 the seventh mapping's key
     * @param v7 the seventh mapping's value
     * @return a {@code Map} containing the specified mappings
     * @throws IllegalArgumentException if there are any duplicate keys
     * @throws NullPointerException if any key or value is {@code null}
     *
     * @since 9
     */
    static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5,
                               K k6, V v6, K k7, V v7) {

    /**
     * Returns an immutable map containing eight mappings.
     * See <a href="#immutable">Immutable Map Static Factory Methods</a> for details.
     *
     * @param <K> the {@code Map}'s key type
     * @param <V> the {@code Map}'s value type
     * @param k1 the first mapping's key
     * @param v1 the first mapping's value
     * @param k2 the second mapping's key
     * @param v2 the second mapping's value
     * @param k3 the third mapping's key
     * @param v3 the third mapping's value
     * @param k4 the fourth mapping's key
     * @param v4 the fourth mapping's value
     * @param k5 the fifth mapping's key
     * @param v5 the fifth mapping's value
     * @param k6 the sixth mapping's key
     * @param v6 the sixth mapping's value
     * @param k7 the seventh mapping's key
     * @param v7 the seventh mapping's value
     * @param k8 the eighth mapping's key
     * @param v8 the eighth mapping's value
     * @return a {@code Map} containing the specified mappings
     * @throws IllegalArgumentException if there are any duplicate keys
     * @throws NullPointerException if any key or value is {@code null}
     *
     * @since 9
     */
    static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5,
                               K k6, V v6, K k7, V v7, K k8, V v8) {

    /**
     * Returns an immutable map containing nine mappings.
     * See <a href="#immutable">Immutable Map Static Factory Methods</a> for details.
     *
     * @param <K> the {@code Map}'s key type
     * @param <V> the {@code Map}'s value type
     * @param k1 the first mapping's key
     * @param v1 the first mapping's value
     * @param k2 the second mapping's key
     * @param v2 the second mapping's value
     * @param k3 the third mapping's key
     * @param v3 the third mapping's value
     * @param k4 the fourth mapping's key
     * @param v4 the fourth mapping's value
     * @param k5 the fifth mapping's key
     * @param v5 the fifth mapping's value
     * @param k6 the sixth mapping's key
     * @param v6 the sixth mapping's value
     * @param k7 the seventh mapping's key
     * @param v7 the seventh mapping's value
     * @param k8 the eighth mapping's key
     * @param v8 the eighth mapping's value
     * @param k9 the ninth mapping's key
     * @param v9 the ninth mapping's value
     * @return a {@code Map} containing the specified mappings
     * @throws IllegalArgumentException if there are any duplicate keys
     * @throws NullPointerException if any key or value is {@code null}
     *
     * @since 9
     */
    static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5,
                               K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9) {

    /**
     * Returns an immutable map containing ten mappings.
     * See <a href="#immutable">Immutable Map Static Factory Methods</a> for details.
     *
     * @param <K> the {@code Map}'s key type
     * @param <V> the {@code Map}'s value type
     * @param k1 the first mapping's key
     * @param v1 the first mapping's value
     * @param k2 the second mapping's key
     * @param v2 the second mapping's value
     * @param k3 the third mapping's key
     * @param v3 the third mapping's value
     * @param k4 the fourth mapping's key
     * @param v4 the fourth mapping's value
     * @param k5 the fifth mapping's key
     * @param v5 the fifth mapping's value
     * @param k6 the sixth mapping's key
     * @param v6 the sixth mapping's value
     * @param k7 the seventh mapping's key
     * @param v7 the seventh mapping's value
     * @param k8 the eighth mapping's key
     * @param v8 the eighth mapping's value
     * @param k9 the ninth mapping's key
     * @param v9 the ninth mapping's value
     * @param k10 the tenth mapping's key
     * @param v10 the tenth mapping's value
     * @return a {@code Map} containing the specified mappings
     * @throws IllegalArgumentException if there are any duplicate keys
     * @throws NullPointerException if any key or value is {@code null}
     *
     * @since 9
     */
    static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5,
                               K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10) {

    /**
     * Returns an immutable map containing keys and values extracted from the given entries.
     * The entries themselves are not stored in the map.
     * See <a href="#immutable">Immutable Map Static Factory Methods</a> for details.
     *
     * @apiNote
     * It is convenient to create the map entries using the {@link Map#entry Map.entry()} method.
     * For example,
     *
     * <pre>{@code
     *     import static java.util.Map.entry;
     *
     *     Map<Integer,String> map = Map.ofEntries(
     *         entry(1, "a"),
     *         entry(2, "b"),
     *         entry(3, "c"),
     *         ...
     *         entry(26, "z"));
     * }</pre>
     *
     * @param <K> the {@code Map}'s key type
     * @param <V> the {@code Map}'s value type
     * @param entries {@code Map.Entry}s containing the keys and values from which the map is populated
     * @return a {@code Map} containing the specified mappings
     * @throws IllegalArgumentException if there are any duplicate keys
     * @throws NullPointerException if any entry, key, or value is {@code null}, or if
     *         the {@code entries} array is {@code null}
     *
     * @see Map#entry Map.entry()
     * @since 9
     */
    @SafeVarargs
    @SuppressWarnings("varargs")
    static <K, V> Map<K, V> ofEntries(Entry<? extends K, ? extends V>... entries) {

    /**
     * Returns an immutable {@link Entry} containing the given key and value.
     * These entries are suitable for populating {@code Map} instances using the
     * {@link Map#ofEntries Map.ofEntries()} method.
     * The {@code Entry} instances created by this method have the following characteristics:
     *
     * <ul>
     * <li>They disallow {@code null} keys and values. Attempts to create them using a {@code null}
     * key or value result in {@code NullPointerException}.
     * <li>They are immutable. Calls to {@link Entry#setValue Entry.setValue()}
     * on a returned {@code Entry} result in {@code UnsupportedOperationException}.
     * <li>They are not serializable.
     * <li>They are <a href="../lang/doc-files/ValueBased.html">value-based</a>.
     * Callers should make no assumptions about the identity of the returned instances.
     * This method is free to create new instances or reuse existing ones. Therefore,
     * identity-sensitive operations on these instances (reference equality ({@code ==}),
     * identity hash code, and synchronization) are unreliable and should be avoided.
     * </ul>
     *
     * @apiNote
     * For a serializable {@code Entry}, see {@link AbstractMap.SimpleEntry} or
     * {@link AbstractMap.SimpleImmutableEntry}.
     *
     * @param <K> the key's type
     * @param <V> the value's type
     * @param k the key
     * @param v the value
     * @return an {@code Entry} containing the specified key and value
     * @throws NullPointerException if the key or value is {@code null}
     *
     * @see Map#ofEntries Map.ofEntries()
     * @since 9
     */
    static <K, V> Entry<K, V> entry(K k, V v) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\Objects.java
    /**
     * Returns the first argument if it is non-{@code null} and
     * otherwise returns the non-{@code null} second argument.
     *
     * @param obj an object
     * @param defaultObj a non-{@code null} object to return if the first argument
     *                   is {@code null}
     * @param <T> the type of the reference
     * @return the first argument if it is non-{@code null} and
     *        otherwise the second argument if it is non-{@code null}
     * @throws NullPointerException if both {@code obj} is null and
     *        {@code defaultObj} is {@code null}
     * @since 9
     */
    public static <T> T requireNonNullElse(T obj, T defaultObj) {

    /**
     * Returns the first argument if it is non-{@code null} and otherwise
     * returns the non-{@code null} value of {@code supplier.get()}.
     *
     * @param obj an object
     * @param supplier of a non-{@code null} object to return if the first argument
     *                 is {@code null}
     * @param <T> the type of the first argument and return type
     * @return the first argument if it is non-{@code null} and otherwise
     *         the value from {@code supplier.get()} if it is non-{@code null}
     * @throws NullPointerException if both {@code obj} is null and
     *        either the {@code supplier} is {@code null} or
     *        the {@code supplier.get()} value is {@code null}
     * @since 9
     */
    public static <T> T requireNonNullElseGet(T obj, Supplier<? extends T> supplier) {

    /**
     * Checks if the {@code index} is within the bounds of the range from
     * {@code 0} (inclusive) to {@code length} (exclusive).
     *
     * <p>The {@code index} is defined to be out-of-bounds if any of the
     * following inequalities is true:
     * <ul>
     *  <li>{@code index < 0}</li>
     *  <li>{@code index >= length}</li>
     *  <li>{@code length < 0}, which is implied from the former inequalities</li>
     * </ul>
     *
     * @param index the index
     * @param length the upper-bound (exclusive) of the range
     * @return {@code index} if it is within bounds of the range
     * @throws IndexOutOfBoundsException if the {@code index} is out-of-bounds
     * @since 9
     */
    @ForceInline
    public static
    int checkIndex(int index, int length) {

    /**
     * Checks if the sub-range from {@code fromIndex} (inclusive) to
     * {@code toIndex} (exclusive) is within the bounds of range from {@code 0}
     * (inclusive) to {@code length} (exclusive).
     *
     * <p>The sub-range is defined to be out-of-bounds if any of the following
     * inequalities is true:
     * <ul>
     *  <li>{@code fromIndex < 0}</li>
     *  <li>{@code fromIndex > toIndex}</li>
     *  <li>{@code toIndex > length}</li>
     *  <li>{@code length < 0}, which is implied from the former inequalities</li>
     * </ul>
     *
     * @param fromIndex the lower-bound (inclusive) of the sub-range
     * @param toIndex the upper-bound (exclusive) of the sub-range
     * @param length the upper-bound (exclusive) the range
     * @return {@code fromIndex} if the sub-range within bounds of the range
     * @throws IndexOutOfBoundsException if the sub-range is out-of-bounds
     * @since 9
     */
    public static
    int checkFromToIndex(int fromIndex, int toIndex, int length) {

    /**
     * Checks if the sub-range from {@code fromIndex} (inclusive) to
     * {@code fromIndex + size} (exclusive) is within the bounds of range from
     * {@code 0} (inclusive) to {@code length} (exclusive).
     *
     * <p>The sub-range is defined to be out-of-bounds if any of the following
     * inequalities is true:
     * <ul>
     *  <li>{@code fromIndex < 0}</li>
     *  <li>{@code size < 0}</li>
     *  <li>{@code fromIndex + size > length}, taking into account integer overflow</li>
     *  <li>{@code length < 0}, which is implied from the former inequalities</li>
     * </ul>
     *
     * @param fromIndex the lower-bound (inclusive) of the sub-interval
     * @param size the size of the sub-range
     * @param length the upper-bound (exclusive) of the range
     * @return {@code fromIndex} if the sub-range within bounds of the range
     * @throws IndexOutOfBoundsException if the sub-range is out-of-bounds
     * @since 9
     */
    public static
    int checkFromIndexSize(int fromIndex, int size, int length) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\Optional.java
    /**
     * If a value is present, performs the given action with the value,
     * otherwise performs the given empty-based action.
     *
     * @param action the action to be performed, if a value is present
     * @param emptyAction the empty-based action to be performed, if no value is
     *        present
     * @throws NullPointerException if a value is present and the given action
     *         is {@code null}, or no value is present and the given empty-based
     *         action is {@code null}.
     * @since 9
     */
    public void ifPresentOrElse(Consumer<? super T> action, Runnable emptyAction) {

    /**
     * If a value is present, returns an {@code Optional} describing the value,
     * otherwise returns an {@code Optional} produced by the supplying function.
     *
     * @param supplier the supplying function that produces an {@code Optional}
     *        to be returned
     * @return returns an {@code Optional} describing the value of this
     *         {@code Optional}, if a value is present, otherwise an
     *         {@code Optional} produced by the supplying function.
     * @throws NullPointerException if the supplying function is {@code null} or
     *         produces a {@code null} result
     * @since 9
     */
    public Optional<T> or(Supplier<Optional<T>> supplier) {

    /**
     * If a value is present, returns a sequential {@link Stream} containing
     * only that value, otherwise returns an empty {@code Stream}.
     *
     * @apiNote
     * This method can be used to transform a {@code Stream} of optional
     * elements to a {@code Stream} of present value elements:
     * <pre>{@code
     *     Stream<Optional<T>> os = ..
     *     Stream<T> s = os.flatMap(Optional::stream)
     * }</pre>
     *
     * @return the optional value as a {@code Stream}
     * @since 9
     */
    public Stream<T> stream() {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\OptionalDouble.java
    /**
     * If a value is present, performs the given action with the value,
     * otherwise performs the given empty-based action.
     *
     * @param action the action to be performed, if a value is present
     * @param emptyAction the empty-based action to be performed, if no value is
     * present
     * @throws NullPointerException if a value is present and the given action
     *         is {@code null}, or no value is present and the given empty-based
     *         action is {@code null}.
     * @since 9
     */
    public void ifPresentOrElse(DoubleConsumer action, Runnable emptyAction) {

    /**
     * If a value is present, returns a sequential {@link DoubleStream}
     * containing only that value, otherwise returns an empty
     * {@code DoubleStream}.
     *
     * @apiNote
     * This method can be used to transform a {@code Stream} of optional doubles
     * to a {@code DoubleStream} of present doubles:
     * <pre>{@code
     *     Stream<OptionalDouble> os = ..
     *     DoubleStream s = os.flatMapToDouble(OptionalDouble::stream)
     * }</pre>
     *
     * @return the optional value as a {@code DoubleStream}
     * @since 9
     */
    public DoubleStream stream() {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\OptionalInt.java
    /**
     * If a value is present, performs the given action with the value,
     * otherwise performs the given empty-based action.
     *
     * @param action the action to be performed, if a value is present
     * @param emptyAction the empty-based action to be performed, if no value is
     *        present
     * @throws NullPointerException if a value is present and the given action
     *         is {@code null}, or no value is present and the given empty-based
     *         action is {@code null}.
     * @since 9
     */
    public void ifPresentOrElse(IntConsumer action, Runnable emptyAction) {

    /**
     * If a value is present, returns a sequential {@link IntStream} containing
     * only that value, otherwise returns an empty {@code IntStream}.
     *
     * @apiNote
     * This method can be used to transform a {@code Stream} of optional
     * integers to an {@code IntStream} of present integers:
     * <pre>{@code
     *     Stream<OptionalInt> os = ..
     *     IntStream s = os.flatMapToInt(OptionalInt::stream)
     * }</pre>
     *
     * @return the optional value as an {@code IntStream}
     * @since 9
     */
    public IntStream stream() {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\OptionalLong.java
    /**
     * If a value is present, performs the given action with the value,
     * otherwise performs the given empty-based action.
     *
     * @param action the action to be performed, if a value is present
     * @param emptyAction the empty-based action to be performed, if no value is
     *        present
     * @throws NullPointerException if a value is present and the given action
     *         is {@code null}, or no value is present and the given empty-based
     *         action is {@code null}.
     * @since 9
     */
    public void ifPresentOrElse(LongConsumer action, Runnable emptyAction) {

    /**
     * If a value is present, returns a sequential {@link LongStream} containing
     * only that value, otherwise returns an empty {@code LongStream}.
     *
     * @apiNote
     * This method can be used to transform a {@code Stream} of optional longs
     * to an {@code LongStream} of present longs:
     * <pre>{@code
     *     Stream<OptionalLong> os = ..
     *     LongStream s = os.flatMapToLong(OptionalLong::stream)
     * }</pre>
     *
     * @return the optional value as an {@code LongStream}
     * @since 9
     */
    public LongStream stream() {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\regex\Matcher.java
    /**
     * Implements a non-terminal append-and-replace step.
     *
     * <p> This method performs the following actions: </p>
     *
     * <ol>
     *
     *   <li><p> It reads characters from the input sequence, starting at the
     *   append position, and appends them to the given string builder.  It
     *   stops after reading the last character preceding the previous match,
     *   that is, the character at index {@link
     *   #start()}&nbsp;{@code -}&nbsp;{@code 1}.  </p></li>
     *
     *   <li><p> It appends the given replacement string to the string builder.
     *   </p></li>
     *
     *   <li><p> It sets the append position of this matcher to the index of
     *   the last character matched, plus one, that is, to {@link #end()}.
     *   </p></li>
     *
     * </ol>
     *
     * <p> The replacement string may contain references to subsequences
     * captured during the previous match: Each occurrence of
     * {@code $}<i>g</i> will be replaced by the result of
     * evaluating {@link #group(int) group}{@code (}<i>g</i>{@code )}.
     * The first number after the {@code $} is always treated as part of
     * the group reference. Subsequent numbers are incorporated into g if
     * they would form a legal group reference. Only the numerals '0'
     * through '9' are considered as potential components of the group
     * reference. If the second group matched the string {@code "foo"}, for
     * example, then passing the replacement string {@code "$2bar"} would
     * cause {@code "foobar"} to be appended to the string builder. A dollar
     * sign ({@code $}) may be included as a literal in the replacement
     * string by preceding it with a backslash ({@code \$}).
     *
     * <p> Note that backslashes ({@code \}) and dollar signs ({@code $}) in
     * the replacement string may cause the results to be different than if it
     * were being treated as a literal replacement string. Dollar signs may be
     * treated as references to captured subsequences as described above, and
     * backslashes are used to escape literal characters in the replacement
     * string.
     *
     * <p> This method is intended to be used in a loop together with the
     * {@link #appendTail appendTail} and {@link #find find} methods.  The
     * following code, for example, writes {@code one dog two dogs in the
     * yard} to the standard-output stream: </p>
     *
     * <blockquote><pre>
     * Pattern p = Pattern.compile("cat");
     * Matcher m = p.matcher("one cat two cats in the yard");
     * StringBuilder sb = new StringBuilder();
     * while (m.find()) {
     *     m.appendReplacement(sb, "dog");
     * }
     * m.appendTail(sb);
     * System.out.println(sb.toString());</pre></blockquote>
     *
     * @param  sb
     *         The target string builder
     * @param  replacement
     *         The replacement string
     * @return  This matcher
     *
     * @throws  IllegalStateException
     *          If no match has yet been attempted,
     *          or if the previous match operation failed
     * @throws  IllegalArgumentException
     *          If the replacement string refers to a named-capturing
     *          group that does not exist in the pattern
     * @throws  IndexOutOfBoundsException
     *          If the replacement string refers to a capturing group
     *          that does not exist in the pattern
     * @since 9
     */
    public Matcher appendReplacement(StringBuilder sb, String replacement) {

    /**
     * Implements a terminal append-and-replace step.
     *
     * <p> This method reads characters from the input sequence, starting at
     * the append position, and appends them to the given string builder.  It is
     * intended to be invoked after one or more invocations of the {@link
     * #appendReplacement appendReplacement} method in order to copy the
     * remainder of the input sequence.  </p>
     *
     * @param  sb
     *         The target string builder
     *
     * @return  The target string builder
     *
     * @since 9
     */
    public StringBuilder appendTail(StringBuilder sb) {

    /**
     * Replaces every subsequence of the input sequence that matches the
     * pattern with the result of applying the given replacer function to the
     * match result of this matcher corresponding to that subsequence.
     * Exceptions thrown by the function are relayed to the caller.
     *
     * <p> This method first resets this matcher.  It then scans the input
     * sequence looking for matches of the pattern.  Characters that are not
     * part of any match are appended directly to the result string; each match
     * is replaced in the result by the applying the replacer function that
     * returns a replacement string.  Each replacement string may contain
     * references to captured subsequences as in the {@link #appendReplacement
     * appendReplacement} method.
     *
     * <p> Note that backslashes ({@code \}) and dollar signs ({@code $}) in
     * a replacement string may cause the results to be different than if it
     * were being treated as a literal replacement string. Dollar signs may be
     * treated as references to captured subsequences as described above, and
     * backslashes are used to escape literal characters in the replacement
     * string.
     *
     * <p> Given the regular expression {@code dog}, the input
     * {@code "zzzdogzzzdogzzz"}, and the function
     * {@code mr -> mr.group().toUpperCase()}, an invocation of this method on
     * a matcher for that expression would yield the string
     * {@code "zzzDOGzzzDOGzzz"}.
     *
     * <p> Invoking this method changes this matcher's state.  If the matcher
     * is to be used in further matching operations then it should first be
     * reset.  </p>
     *
     * <p> The replacer function should not modify this matcher's state during
     * replacement.  This method will, on a best-effort basis, throw a
     * {@link java.util.ConcurrentModificationException} if such modification is
     * detected.
     *
     * <p> The state of each match result passed to the replacer function is
     * guaranteed to be constant only for the duration of the replacer function
     * call and only if the replacer function does not modify this matcher's
     * state.
     *
     * @implNote
     * This implementation applies the replacer function to this matcher, which
     * is an instance of {@code MatchResult}.
     *
     * @param  replacer
     *         The function to be applied to the match result of this matcher
     *         that returns a replacement string.
     * @return  The string constructed by replacing each matching subsequence
     *          with the result of applying the replacer function to that
     *          matched subsequence, substituting captured subsequences as
     *          needed.
     * @throws NullPointerException if the replacer function is null
     * @throws ConcurrentModificationException if it is detected, on a
     *         best-effort basis, that the replacer function modified this
     *         matcher's state
     * @since 9
     */
    public String replaceAll(Function<MatchResult, String> replacer) {

    /**
     * Returns a stream of match results for each subsequence of the input
     * sequence that matches the pattern.  The match results occur in the
     * same order as the matching subsequences in the input sequence.
     *
     * <p> Each match result is produced as if by {@link #toMatchResult()}.
     *
     * <p> This method does not reset this matcher.  Matching starts on
     * initiation of the terminal stream operation either at the beginning of
     * this matcher's region, or, if the matcher has not since been reset, at
     * the first character not matched by a previous match.
     *
     * <p> If the matcher is to be used for further matching operations after
     * the terminal stream operation completes then it should be first reset.
     *
     * <p> This matcher's state should not be modified during execution of the
     * returned stream's pipeline.  The returned stream's source
     * {@code Spliterator} is <em>fail-fast</em> and will, on a best-effort
     * basis, throw a {@link java.util.ConcurrentModificationException} if such
     * modification is detected.
     *
     * @return a sequential stream of match results.
     * @since 9
     */
    public Stream<MatchResult> results() {

    /**
     * Replaces the first subsequence of the input sequence that matches the
     * pattern with the result of applying the given replacer function to the
     * match result of this matcher corresponding to that subsequence.
     * Exceptions thrown by the replace function are relayed to the caller.
     *
     * <p> This method first resets this matcher.  It then scans the input
     * sequence looking for a match of the pattern.  Characters that are not
     * part of the match are appended directly to the result string; the match
     * is replaced in the result by the applying the replacer function that
     * returns a replacement string.  The replacement string may contain
     * references to captured subsequences as in the {@link #appendReplacement
     * appendReplacement} method.
     *
     * <p>Note that backslashes ({@code \}) and dollar signs ({@code $}) in
     * the replacement string may cause the results to be different than if it
     * were being treated as a literal replacement string. Dollar signs may be
     * treated as references to captured subsequences as described above, and
     * backslashes are used to escape literal characters in the replacement
     * string.
     *
     * <p> Given the regular expression {@code dog}, the input
     * {@code "zzzdogzzzdogzzz"}, and the function
     * {@code mr -> mr.group().toUpperCase()}, an invocation of this method on
     * a matcher for that expression would yield the string
     * {@code "zzzDOGzzzdogzzz"}.
     *
     * <p> Invoking this method changes this matcher's state.  If the matcher
     * is to be used in further matching operations then it should first be
     * reset.
     *
     * <p> The replacer function should not modify this matcher's state during
     * replacement.  This method will, on a best-effort basis, throw a
     * {@link java.util.ConcurrentModificationException} if such modification is
     * detected.
     *
     * <p> The state of the match result passed to the replacer function is
     * guaranteed to be constant only for the duration of the replacer function
     * call and only if the replacer function does not modify this matcher's
     * state.
     *
     * @implNote
     * This implementation applies the replacer function to this matcher, which
     * is an instance of {@code MatchResult}.
     *
     * @param  replacer
     *         The function to be applied to the match result of this matcher
     *         that returns a replacement string.
     * @return  The string constructed by replacing the first matching
     *          subsequence with the result of applying the replacer function to
     *          the matched subsequence, substituting captured subsequences as
     *          needed.
     * @throws NullPointerException if the replacer function is null
     * @throws ConcurrentModificationException if it is detected, on a
     *         best-effort basis, that the replacer function modified this
     *         matcher's state
     * @since 9
     */
    public String replaceFirst(Function<MatchResult, String> replacer) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\ResourceBundle.java
    /**
     * Gets a resource bundle using the specified base name and the default locale
     * on behalf of the specified module. This method is equivalent to calling
     * <blockquote>
     * <code>getBundle(baseName, Locale.getDefault(), module)</code>
     * </blockquote>
     *
     * @param baseName the base name of the resource bundle,
     *                 a fully qualified class name
     * @param module   the module for which the resource bundle is searched
     * @throws NullPointerException
     *         if {@code baseName} or {@code module} is {@code null}
     * @throws SecurityException
     *         if a security manager exists and the caller is not the specified
     *         module and doesn't have {@code RuntimePermission("getClassLoader")}
     * @throws MissingResourceException
     *         if no resource bundle for the specified base name can be found in the
     *         specified module
     * @return a resource bundle for the given base name and the default locale
     * @since 9
     * @see ResourceBundleProvider
     */
    @CallerSensitive
    public static ResourceBundle getBundle(String baseName, Module module) {

    /**
     * Gets a resource bundle using the specified base name and locale
     * on behalf of the specified module.
     *
     * <p>
     * If the given {@code module} is a named module, this method will
     * load the service providers for {@link java.util.spi.ResourceBundleProvider}
     * and also resource bundles local in the given module (refer to the
     * <a href="#bundleprovider">Resource Bundles in Named Modules</a> section
     * for details).
     *
     * <p>
     * If the given {@code module} is an unnamed module, then this method is
     * equivalent to calling {@link #getBundle(String, Locale, ClassLoader)
     * getBundle(baseName, targetLocale, module.getClassLoader()} to load
     * resource bundles that are in unnamed modules visible to the
     * class loader of the given unnamed module.  It will not find resource
     * bundles from named modules.
     *
     * @param baseName the base name of the resource bundle,
     *                 a fully qualified class name
     * @param targetLocale the locale for which a resource bundle is desired
     * @param module   the module for which the resource bundle is searched
     * @throws NullPointerException
     *         if {@code baseName}, {@code targetLocale}, or {@code module} is
     *         {@code null}
     * @throws SecurityException
     *         if a security manager exists and the caller is not the specified
     *         module and doesn't have {@code RuntimePermission("getClassLoader")}
     * @throws MissingResourceException
     *         if no resource bundle for the specified base name and locale can
     *         be found in the specified {@code module}
     * @return a resource bundle for the given base name and locale in the module
     * @since 9
     */
    @CallerSensitive
    public static ResourceBundle getBundle(String baseName, Locale targetLocale, Module module) {

    /**
     * Removes all resource bundles from the cache that have been loaded by the
     * given {@code module}.
     *
     * @param module the module
     * @throws NullPointerException
     *         if {@code module} is {@code null}
     * @throws SecurityException
     *         if the caller doesn't have the permission to
     *         {@linkplain Module#getClassLoader() get the class loader}
     *         of the given {@code module}
     * @since 9
     * @see ResourceBundle.Control#getTimeToLive(String,Locale)
     */
    public static final void clearCache(Module module) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\Scanner.java
    /**
     * Returns a stream of delimiter-separated tokens from this scanner. The
     * stream contains the same tokens that would be returned, starting from
     * this scanner's current state, by calling the {@link #next} method
     * repeatedly until the {@link #hasNext} method returns false.
     *
     * <p>The resulting stream is sequential and ordered. All stream elements are
     * non-null.
     *
     * <p>Scanning starts upon initiation of the terminal stream operation, using the
     * current state of this scanner. Subsequent calls to any methods on this scanner
     * other than {@link #close} and {@link #ioException} may return undefined results
     * or may cause undefined effects on the returned stream. The returned stream's source
     * {@code Spliterator} is <em>fail-fast</em> and will, on a best-effort basis, throw a
     * {@link java.util.ConcurrentModificationException} if any such calls are detected
     * during stream pipeline execution.
     *
     * <p>After stream pipeline execution completes, this scanner is left in an indeterminate
     * state and cannot be reused.
     *
     * <p>If this scanner contains a resource that must be released, this scanner
     * should be closed, either by calling its {@link #close} method, or by
     * closing the returned stream. Closing the stream will close the underlying scanner.
     * {@code IllegalStateException} is thrown if the scanner has been closed when this
     * method is called, or if this scanner is closed during stream pipeline execution.
     *
     * <p>This method might block waiting for more input.
     *
     * @apiNote
     * For example, the following code will create a list of
     * comma-delimited tokens from a string:
     *
     * <pre>{@code
     * List<String> result = new Scanner("abc,def,,ghi")
     *     .useDelimiter(",")
     *     .tokens()
     *     .collect(Collectors.toList());
     * }</pre>
     *
     * <p>The resulting list would contain {@code "abc"}, {@code "def"},
     * the empty string, and {@code "ghi"}.
     *
     * @return a sequential stream of token strings
     * @throws IllegalStateException if this scanner is closed
     * @since 9
     */
    public Stream<String> tokens() {

    /**
     * Returns a stream of match results from this scanner. The stream
     * contains the same results in the same order that would be returned by
     * calling {@code findWithinHorizon(pattern, 0)} and then {@link #match}
     * successively as long as {@link #findWithinHorizon findWithinHorizon()}
     * finds matches.
     *
     * <p>The resulting stream is sequential and ordered. All stream elements are
     * non-null.
     *
     * <p>Scanning starts upon initiation of the terminal stream operation, using the
     * current state of this scanner. Subsequent calls to any methods on this scanner
     * other than {@link #close} and {@link #ioException} may return undefined results
     * or may cause undefined effects on the returned stream. The returned stream's source
     * {@code Spliterator} is <em>fail-fast</em> and will, on a best-effort basis, throw a
     * {@link java.util.ConcurrentModificationException} if any such calls are detected
     * during stream pipeline execution.
     *
     * <p>After stream pipeline execution completes, this scanner is left in an indeterminate
     * state and cannot be reused.
     *
     * <p>If this scanner contains a resource that must be released, this scanner
     * should be closed, either by calling its {@link #close} method, or by
     * closing the returned stream. Closing the stream will close the underlying scanner.
     * {@code IllegalStateException} is thrown if the scanner has been closed when this
     * method is called, or if this scanner is closed during stream pipeline execution.
     *
     * <p>As with the {@link #findWithinHorizon findWithinHorizon()} methods, this method
     * might block waiting for additional input, and it might buffer an unbounded amount of
     * input searching for a match.
     *
     * @apiNote
     * For example, the following code will read a file and return a list
     * of all sequences of characters consisting of seven or more Latin capital
     * letters:
     *
     * <pre>{@code
     * try (Scanner sc = new Scanner(Paths.get("input.txt"))) {
     *     Pattern pat = Pattern.compile("[A-Z]{7,}");
     *     List<String> capWords = sc.findAll(pat)
     *                               .map(MatchResult::group)
     *                               .collect(Collectors.toList());
     * }
     * }</pre>
     *
     * @param pattern the pattern to be matched
     * @return a sequential stream of match results
     * @throws NullPointerException if pattern is null
     * @throws IllegalStateException if this scanner is closed
     * @since 9
     */
    public Stream<MatchResult> findAll(Pattern pattern) {

    /**
     * Returns a stream of match results that match the provided pattern string.
     * The effect is equivalent to the following code:
     *
     * <pre>{@code
     *     scanner.findAll(Pattern.compile(patString))
     * }</pre>
     *
     * @param patString the pattern string
     * @return a sequential stream of match results
     * @throws NullPointerException if patString is null
     * @throws IllegalStateException if this scanner is closed
     * @throws PatternSyntaxException if the regular expression's syntax is invalid
     * @since 9
     * @see java.util.regex.Pattern
     */
    public Stream<MatchResult> findAll(String patString) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\ServiceLoader.java
    /**
     * Creates a new service loader for the given service type that loads
     * service providers from modules in the given {@code Layer} and its
     * ancestors.
     *
     * @apiNote Unlike the other load methods defined here, the service type
     * is the second parameter. The reason for this is to avoid source
     * compatibility issues for code that uses {@code load(S, null)}.
     *
     * @param  <S> the class of the service type
     *
     * @param  layer
     *         The module Layer
     *
     * @param  service
     *         The interface or abstract class representing the service
     *
     * @return A new service loader
     *
     * @throws ServiceConfigurationError
     *         if the service type is not accessible to the caller or the
     *         caller is in a named module and its module descriptor does
     *         not declare that it uses {@code service}
     *
     * @since 9
     */
    @CallerSensitive
    public static <S> ServiceLoader<S> load(Layer layer, Class<S> service) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\Set.java
    /**
     * Returns an immutable set containing zero elements.
     * See <a href="#immutable">Immutable Set Static Factory Methods</a> for details.
     *
     * @param <E> the {@code Set}'s element type
     * @return an empty {@code Set}
     *
     * @since 9
     */
    static <E> Set<E> of() {

    /**
     * Returns an immutable set containing one element.
     * See <a href="#immutable">Immutable Set Static Factory Methods</a> for details.
     *
     * @param <E> the {@code Set}'s element type
     * @param e1 the single element
     * @return a {@code Set} containing the specified element
     * @throws NullPointerException if the element is {@code null}
     *
     * @since 9
     */
    static <E> Set<E> of(E e1) {

    /**
     * Returns an immutable set containing two elements.
     * See <a href="#immutable">Immutable Set Static Factory Methods</a> for details.
     *
     * @param <E> the {@code Set}'s element type
     * @param e1 the first element
     * @param e2 the second element
     * @return a {@code Set} containing the specified elements
     * @throws IllegalArgumentException if the elements are duplicates
     * @throws NullPointerException if an element is {@code null}
     *
     * @since 9
     */
    static <E> Set<E> of(E e1, E e2) {

    /**
     * Returns an immutable set containing three elements.
     * See <a href="#immutable">Immutable Set Static Factory Methods</a> for details.
     *
     * @param <E> the {@code Set}'s element type
     * @param e1 the first element
     * @param e2 the second element
     * @param e3 the third element
     * @return a {@code Set} containing the specified elements
     * @throws IllegalArgumentException if there are any duplicate elements
     * @throws NullPointerException if an element is {@code null}
     *
     * @since 9
     */
    static <E> Set<E> of(E e1, E e2, E e3) {

    /**
     * Returns an immutable set containing four elements.
     * See <a href="#immutable">Immutable Set Static Factory Methods</a> for details.
     *
     * @param <E> the {@code Set}'s element type
     * @param e1 the first element
     * @param e2 the second element
     * @param e3 the third element
     * @param e4 the fourth element
     * @return a {@code Set} containing the specified elements
     * @throws IllegalArgumentException if there are any duplicate elements
     * @throws NullPointerException if an element is {@code null}
     *
     * @since 9
     */
    static <E> Set<E> of(E e1, E e2, E e3, E e4) {

    /**
     * Returns an immutable set containing five elements.
     * See <a href="#immutable">Immutable Set Static Factory Methods</a> for details.
     *
     * @param <E> the {@code Set}'s element type
     * @param e1 the first element
     * @param e2 the second element
     * @param e3 the third element
     * @param e4 the fourth element
     * @param e5 the fifth element
     * @return a {@code Set} containing the specified elements
     * @throws IllegalArgumentException if there are any duplicate elements
     * @throws NullPointerException if an element is {@code null}
     *
     * @since 9
     */
    static <E> Set<E> of(E e1, E e2, E e3, E e4, E e5) {

    /**
     * Returns an immutable set containing six elements.
     * See <a href="#immutable">Immutable Set Static Factory Methods</a> for details.
     *
     * @param <E> the {@code Set}'s element type
     * @param e1 the first element
     * @param e2 the second element
     * @param e3 the third element
     * @param e4 the fourth element
     * @param e5 the fifth element
     * @param e6 the sixth element
     * @return a {@code Set} containing the specified elements
     * @throws IllegalArgumentException if there are any duplicate elements
     * @throws NullPointerException if an element is {@code null}
     *
     * @since 9
     */
    static <E> Set<E> of(E e1, E e2, E e3, E e4, E e5, E e6) {

    /**
     * Returns an immutable set containing seven elements.
     * See <a href="#immutable">Immutable Set Static Factory Methods</a> for details.
     *
     * @param <E> the {@code Set}'s element type
     * @param e1 the first element
     * @param e2 the second element
     * @param e3 the third element
     * @param e4 the fourth element
     * @param e5 the fifth element
     * @param e6 the sixth element
     * @param e7 the seventh element
     * @return a {@code Set} containing the specified elements
     * @throws IllegalArgumentException if there are any duplicate elements
     * @throws NullPointerException if an element is {@code null}
     *
     * @since 9
     */
    static <E> Set<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7) {

    /**
     * Returns an immutable set containing eight elements.
     * See <a href="#immutable">Immutable Set Static Factory Methods</a> for details.
     *
     * @param <E> the {@code Set}'s element type
     * @param e1 the first element
     * @param e2 the second element
     * @param e3 the third element
     * @param e4 the fourth element
     * @param e5 the fifth element
     * @param e6 the sixth element
     * @param e7 the seventh element
     * @param e8 the eighth element
     * @return a {@code Set} containing the specified elements
     * @throws IllegalArgumentException if there are any duplicate elements
     * @throws NullPointerException if an element is {@code null}
     *
     * @since 9
     */
    static <E> Set<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8) {

    /**
     * Returns an immutable set containing nine elements.
     * See <a href="#immutable">Immutable Set Static Factory Methods</a> for details.
     *
     * @param <E> the {@code Set}'s element type
     * @param e1 the first element
     * @param e2 the second element
     * @param e3 the third element
     * @param e4 the fourth element
     * @param e5 the fifth element
     * @param e6 the sixth element
     * @param e7 the seventh element
     * @param e8 the eighth element
     * @param e9 the ninth element
     * @return a {@code Set} containing the specified elements
     * @throws IllegalArgumentException if there are any duplicate elements
     * @throws NullPointerException if an element is {@code null}
     *
     * @since 9
     */
    static <E> Set<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9) {

    /**
     * Returns an immutable set containing ten elements.
     * See <a href="#immutable">Immutable Set Static Factory Methods</a> for details.
     *
     * @param <E> the {@code Set}'s element type
     * @param e1 the first element
     * @param e2 the second element
     * @param e3 the third element
     * @param e4 the fourth element
     * @param e5 the fifth element
     * @param e6 the sixth element
     * @param e7 the seventh element
     * @param e8 the eighth element
     * @param e9 the ninth element
     * @param e10 the tenth element
     * @return a {@code Set} containing the specified elements
     * @throws IllegalArgumentException if there are any duplicate elements
     * @throws NullPointerException if an element is {@code null}
     *
     * @since 9
     */
    static <E> Set<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10) {

    /**
     * Returns an immutable set containing an arbitrary number of elements.
     * See <a href="#immutable">Immutable Set Static Factory Methods</a> for details.
     *
     * @apiNote
     * This method also accepts a single array as an argument. The element type of
     * the resulting set will be the component type of the array, and the size of
     * the set will be equal to the length of the array. To create a set with
     * a single element that is an array, do the following:
     *
     * <pre>{@code
     *     String[] array = ... ;
     *     Set<String[]> list = Set.<String[]>of(array);
     * }</pre>
     *
     * This will cause the {@link Set#of(Object) Set.of(E)} method
     * to be invoked instead.
     *
     * @param <E> the {@code Set}'s element type
     * @param elements the elements to be contained in the set
     * @return a {@code Set} containing the specified elements
     * @throws IllegalArgumentException if there are any duplicate elements
     * @throws NullPointerException if an element is {@code null} or if the array is {@code null}
     *
     * @since 9
     */
    @SafeVarargs
    @SuppressWarnings("varargs")
    static <E> Set<E> of(E... elements) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\spi\AbstractResourceBundleProvider.java
/**
 * {@code AbstractResourceBundleProvider} is an abstract class for helping
 * implement the {@link ResourceBundleProvider} interface.
 *
 * <p>
 * Resource bundles can be packaged in a named module separated from
 * the <em>caller module</em> loading the resource bundle, i.e. the module
 * calling {@link ResourceBundle#getBundle(String)}.  For the caller module
 * to load a resource bundle "{@code com.example.app.MyResources}"
 * from another module and a service interface named
 * "{@code com.example.app.MyResourcesProvider}",
 * the <em>bundle provider module</em> can provide the implementation class
 * as follows:
 *
 * <pre><code>
 * import com.example.app.MyResourcesProvider;
 * class MyResourcesProviderImpl extends AbstractResourceBundleProvider
 *     implements MyResourcesProvider
 * {</code>
 *     {@code @Override
 *     public ResourceBundle getBundle(String baseName, Locale locale) {
 *         // this module only provides bundles in french
 *         if (locale.equals(Locale.FRENCH)) {
 *              return super.getBundle(baseName, locale);
 *         }
 *         return null;
 *     }
 * }}</pre>
 *
 * @see <a href="../ResourceBundle.html#bundleprovider">
 *     Resource Bundles in Named Modules</a>
 * @see <a href="../ResourceBundle.html#RBP_support">
 *     ResourceBundleProvider Service Providers</a>
 *
 * @since 9
 */
public abstract class AbstractResourceBundleProvider implements ResourceBundleProvider {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\spi\ResourceBundleProvider.java
/**
 * {@code ResourceBundleProvider} is a provider interface that is used for
 * loading resource bundles for named modules. Implementation classes of
 * this interface are loaded with {@link java.util.ServiceLoader ServiceLoader}
 * during a call to the
 * {@link ResourceBundle#getBundle(String, Locale, ClassLoader)
 * ResourceBundle.getBundle} method. The provider service type is determined by
 * {@code basename+"Provider"}.
 *
 * <p>
 * For example, if the base name is "com.example.app.MyResources",
 * {@code com.example.app.MyResourcesProvider} will be the provider service type:
 * <pre>{@code
 * public interface MyResourcesProvider extends ResourceBundleProvider {
 * }
 * }</pre>
 *
 * <p>
 * This providers's {@link #getBundle(String, Locale) getBundle} method is called
 * through the resource bundle loading process instead of {@link
 * java.util.ResourceBundle.Control#newBundle(String, Locale, String, ClassLoader, boolean)
 * ResourceBundle.Control.newBundle()}. Refer to {@link ResourceBundle} for
 * details.
 *
 * @see <a href="../ResourceBundle.html#bundleprovider">
 *     Resource Bundles in Named Modules</a>
 * @see <a href="../ResourceBundle.html#RBP_support">
 *     ResourceBundleProvider Service Providers</a>
 * @since 9
 */
public interface ResourceBundleProvider {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\stream\Collectors.java
    /**
     * Adapts a {@code Collector} accepting elements of type {@code U} to one
     * accepting elements of type {@code T} by applying a flat mapping function
     * to each input element before accumulation.  The flat mapping function
     * maps an input element to a {@link Stream stream} covering zero or more
     * output elements that are then accumulated downstream.  Each mapped stream
     * is {@link java.util.stream.BaseStream#close() closed} after its contents
     * have been placed downstream.  (If a mapped stream is {@code null}
     * an empty stream is used, instead.)
     *
     * @apiNote
     * The {@code flatMapping()} collectors are most useful when used in a
     * multi-level reduction, such as downstream of a {@code groupingBy} or
     * {@code partitioningBy}.  For example, given a stream of
     * {@code Order}, to accumulate the set of line items for each customer:
     * <pre>{@code
     *     Map<String, Set<LineItem>> itemsByCustomerName
     *         = orders.stream().collect(groupingBy(Order::getCustomerName,
     *                                              flatMapping(order -> order.getLineItems().stream(), toSet())));
     * }</pre>
     *
     * @param <T> the type of the input elements
     * @param <U> type of elements accepted by downstream collector
     * @param <A> intermediate accumulation type of the downstream collector
     * @param <R> result type of collector
     * @param mapper a function to be applied to the input elements, which
     * returns a stream of results
     * @param downstream a collector which will receive the elements of the
     * stream returned by mapper
     * @return a collector which applies the mapping function to the input
     * elements and provides the flat mapped results to the downstream collector
     * @since 9
     */
    public static <T, U, A, R>
    Collector<T, ?, R> flatMapping(Function<? super T, ? extends Stream<? extends U>> mapper,
                                   Collector<? super U, A, R> downstream) {

    /**
     * Adapts a {@code Collector} to one accepting elements of the same type
     * {@code T} by applying the predicate to each input element and only
     * accumulating if the predicate returns {@code true}.
     *
     * @apiNote
     * The {@code filtering()} collectors are most useful when used in a
     * multi-level reduction, such as downstream of a {@code groupingBy} or
     * {@code partitioningBy}.  For example, given a stream of
     * {@code Employee}, to accumulate the employees in each department that have a
     * salary above a certain threshold:
     * <pre>{@code
     *     Map<Department, Set<Employee>> wellPaidEmployeesByDepartment
     *         = employees.stream().collect(groupingBy(Employee::getDepartment,
     *                                              filtering(e -> e.getSalary() > 2000, toSet())));
     * }</pre>
     * A filtering collector differs from a stream's {@code filter()} operation.
     * In this example, suppose there are no employees whose salary is above the
     * threshold in some department.  Using a filtering collector as shown above
     * would result in a mapping from that department to an empty {@code Set}.
     * If a stream {@code filter()} operation were done instead, there would be
     * no mapping for that department at all.
     *
     * @param <T> the type of the input elements
     * @param <A> intermediate accumulation type of the downstream collector
     * @param <R> result type of collector
     * @param predicate a predicate to be applied to the input elements
     * @param downstream a collector which will accept values that match the
     * predicate
     * @return a collector which applies the predicate to the input elements
     * and provides matching elements to the downstream collector
     * @since 9
     */
    public static <T, A, R>
    Collector<T, ?, R> filtering(Predicate<? super T> predicate,
                               Collector<? super T, A, R> downstream) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\stream\DoubleStream.java
    /**
     * Returns, if this stream is ordered, a stream consisting of the longest
     * prefix of elements taken from this stream that match the given predicate.
     * Otherwise returns, if this stream is unordered, a stream consisting of a
     * subset of elements taken from this stream that match the given predicate.
     *
     * <p>If this stream is ordered then the longest prefix is a contiguous
     * sequence of elements of this stream that match the given predicate.  The
     * first element of the sequence is the first element of this stream, and
     * the element immediately following the last element of the sequence does
     * not match the given predicate.
     *
     * <p>If this stream is unordered, and some (but not all) elements of this
     * stream match the given predicate, then the behavior of this operation is
     * nondeterministic; it is free to take any subset of matching elements
     * (which includes the empty set).
     *
     * <p>Independent of whether this stream is ordered or unordered if all
     * elements of this stream match the given predicate then this operation
     * takes all elements (the result is the same as the input), or if no
     * elements of the stream match the given predicate then no elements are
     * taken (the result is an empty stream).
     *
     * <p>This is a <a href="package-summary.html#StreamOps">short-circuiting
     * stateful intermediate operation</a>.
     *
     * @implSpec
     * The default implementation obtains the {@link #spliterator() spliterator}
     * of this stream, wraps that spliterator so as to support the semantics
     * of this operation on traversal, and returns a new stream associated with
     * the wrapped spliterator.  The returned stream preserves the execution
     * characteristics of this stream (namely parallel or sequential execution
     * as per {@link #isParallel()}) but the wrapped spliterator may choose to
     * not support splitting.  When the returned stream is closed, the close
     * handlers for both the returned and this stream are invoked.
     *
     * @apiNote
     * While {@code takeWhile()} is generally a cheap operation on sequential
     * stream pipelines, it can be quite expensive on ordered parallel
     * pipelines, since the operation is constrained to return not just any
     * valid prefix, but the longest prefix of elements in the encounter order.
     * Using an unordered stream source (such as
     * {@link #generate(DoubleSupplier)}) or removing the ordering constraint
     * with {@link #unordered()} may result in significant speedups of
     * {@code takeWhile()} in parallel pipelines, if the semantics of your
     * situation permit.  If consistency with encounter order is required, and
     * you are experiencing poor performance or memory utilization with
     * {@code takeWhile()} in parallel pipelines, switching to sequential
     * execution with {@link #sequential()} may improve performance.
     *
     * @param predicate a <a href="package-summary.html#NonInterference">non-interfering</a>,
     *                  <a href="package-summary.html#Statelessness">stateless</a>
     *                  predicate to apply to elements to determine the longest
     *                  prefix of elements.
     * @return the new stream
     * @since 9
     */
    default DoubleStream takeWhile(DoublePredicate predicate) {

    /**
     * Returns, if this stream is ordered, a stream consisting of the remaining
     * elements of this stream after dropping the longest prefix of elements
     * that match the given predicate.  Otherwise returns, if this stream is
     * unordered, a stream consisting of the remaining elements of this stream
     * after dropping a subset of elements that match the given predicate.
     *
     * <p>If this stream is ordered then the longest prefix is a contiguous
     * sequence of elements of this stream that match the given predicate.  The
     * first element of the sequence is the first element of this stream, and
     * the element immediately following the last element of the sequence does
     * not match the given predicate.
     *
     * <p>If this stream is unordered, and some (but not all) elements of this
     * stream match the given predicate, then the behavior of this operation is
     * nondeterministic; it is free to drop any subset of matching elements
     * (which includes the empty set).
     *
     * <p>Independent of whether this stream is ordered or unordered if all
     * elements of this stream match the given predicate then this operation
     * drops all elements (the result is an empty stream), or if no elements of
     * the stream match the given predicate then no elements are dropped (the
     * result is the same as the input).
     *
     * <p>This is a <a href="package-summary.html#StreamOps">stateful
     * intermediate operation</a>.
     *
     * @implSpec
     * The default implementation obtains the {@link #spliterator() spliterator}
     * of this stream, wraps that spliterator so as to support the semantics
     * of this operation on traversal, and returns a new stream associated with
     * the wrapped spliterator.  The returned stream preserves the execution
     * characteristics of this stream (namely parallel or sequential execution
     * as per {@link #isParallel()}) but the wrapped spliterator may choose to
     * not support splitting.  When the returned stream is closed, the close
     * handlers for both the returned and this stream are invoked.
     *
     * @apiNote
     * While {@code dropWhile()} is generally a cheap operation on sequential
     * stream pipelines, it can be quite expensive on ordered parallel
     * pipelines, since the operation is constrained to return not just any
     * valid prefix, but the longest prefix of elements in the encounter order.
     * Using an unordered stream source (such as
     * {@link #generate(DoubleSupplier)}) or removing the ordering constraint
     * with {@link #unordered()} may result in significant speedups of
     * {@code dropWhile()} in parallel pipelines, if the semantics of your
     * situation permit.  If consistency with encounter order is required, and
     * you are experiencing poor performance or memory utilization with
     * {@code dropWhile()} in parallel pipelines, switching to sequential
     * execution with {@link #sequential()} may improve performance.
     *
     * @param predicate a <a href="package-summary.html#NonInterference">non-interfering</a>,
     *                  <a href="package-summary.html#Statelessness">stateless</a>
     *                  predicate to apply to elements to determine the longest
     *                  prefix of elements.
     * @return the new stream
     * @since 9
     */
    default DoubleStream dropWhile(DoublePredicate predicate) {

    /**
     * Returns a sequential ordered {@code DoubleStream} produced by iterative
     * application of the given {@code next} function to an initial element,
     * conditioned on satisfying the given {@code hasNext} predicate.  The
     * stream terminates as soon as the {@code hasNext} predicate returns false.
     *
     * <p>{@code DoubleStream.iterate} should produce the same sequence of elements as
     * produced by the corresponding for-loop:
     * <pre>{@code
     *     for (double index=seed; hasNext.test(index); index = next.applyAsDouble(index)) {
     *         ...
     *     }
     * }</pre>
     *
     * <p>The resulting sequence may be empty if the {@code hasNext} predicate
     * does not hold on the seed value.  Otherwise the first element will be the
     * supplied {@code seed} value, the next element (if present) will be the
     * result of applying the {@code next} function to the {@code seed} value,
     * and so on iteratively until the {@code hasNext} predicate indicates that
     * the stream should terminate.
     *
     * <p>The action of applying the {@code hasNext} predicate to an element
     * <a href="../concurrent/package-summary.html#MemoryVisibility"><i>happens-before</i></a>
     * the action of applying the {@code next} function to that element.  The
     * action of applying the {@code next} function for one element
     * <i>happens-before</i> the action of applying the {@code hasNext}
     * predicate for subsequent elements.  For any given element an action may
     * be performed in whatever thread the library chooses.
     *
     * @param seed the initial element
     * @param hasNext a predicate to apply to elements to determine when the
     *                stream must terminate.
     * @param next a function to be applied to the previous element to produce
     *             a new element
     * @return a new sequential {@code DoubleStream}
     * @since 9
     */
    public static DoubleStream iterate(double seed, DoublePredicate hasNext, DoubleUnaryOperator next) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\stream\IntStream.java
    /**
     * Returns, if this stream is ordered, a stream consisting of the longest
     * prefix of elements taken from this stream that match the given predicate.
     * Otherwise returns, if this stream is unordered, a stream consisting of a
     * subset of elements taken from this stream that match the given predicate.
     *
     * <p>If this stream is ordered then the longest prefix is a contiguous
     * sequence of elements of this stream that match the given predicate.  The
     * first element of the sequence is the first element of this stream, and
     * the element immediately following the last element of the sequence does
     * not match the given predicate.
     *
     * <p>If this stream is unordered, and some (but not all) elements of this
     * stream match the given predicate, then the behavior of this operation is
     * nondeterministic; it is free to take any subset of matching elements
     * (which includes the empty set).
     *
     * <p>Independent of whether this stream is ordered or unordered if all
     * elements of this stream match the given predicate then this operation
     * takes all elements (the result is the same as the input), or if no
     * elements of the stream match the given predicate then no elements are
     * taken (the result is an empty stream).
     *
     * <p>This is a <a href="package-summary.html#StreamOps">short-circuiting
     * stateful intermediate operation</a>.
     *
     * @implSpec
     * The default implementation obtains the {@link #spliterator() spliterator}
     * of this stream, wraps that spliterator so as to support the semantics
     * of this operation on traversal, and returns a new stream associated with
     * the wrapped spliterator.  The returned stream preserves the execution
     * characteristics of this stream (namely parallel or sequential execution
     * as per {@link #isParallel()}) but the wrapped spliterator may choose to
     * not support splitting.  When the returned stream is closed, the close
     * handlers for both the returned and this stream are invoked.
     *
     * @apiNote
     * While {@code takeWhile()} is generally a cheap operation on sequential
     * stream pipelines, it can be quite expensive on ordered parallel
     * pipelines, since the operation is constrained to return not just any
     * valid prefix, but the longest prefix of elements in the encounter order.
     * Using an unordered stream source (such as {@link #generate(IntSupplier)})
     * or removing the ordering constraint with {@link #unordered()} may result
     * in significant speedups of {@code takeWhile()} in parallel pipelines, if
     * the semantics of your situation permit.  If consistency with encounter
     * order is required, and you are experiencing poor performance or memory
     * utilization with {@code takeWhile()} in parallel pipelines, switching to
     * sequential execution with {@link #sequential()} may improve performance.
     *
     * @param predicate a <a href="package-summary.html#NonInterference">non-interfering</a>,
     *                  <a href="package-summary.html#Statelessness">stateless</a>
     *                  predicate to apply to elements to determine the longest
     *                  prefix of elements.
     * @return the new stream
     * @since 9
     */
    default IntStream takeWhile(IntPredicate predicate) {

    /**
     * Returns, if this stream is ordered, a stream consisting of the remaining
     * elements of this stream after dropping the longest prefix of elements
     * that match the given predicate.  Otherwise returns, if this stream is
     * unordered, a stream consisting of the remaining elements of this stream
     * after dropping a subset of elements that match the given predicate.
     *
     * <p>If this stream is ordered then the longest prefix is a contiguous
     * sequence of elements of this stream that match the given predicate.  The
     * first element of the sequence is the first element of this stream, and
     * the element immediately following the last element of the sequence does
     * not match the given predicate.
     *
     * <p>If this stream is unordered, and some (but not all) elements of this
     * stream match the given predicate, then the behavior of this operation is
     * nondeterministic; it is free to drop any subset of matching elements
     * (which includes the empty set).
     *
     * <p>Independent of whether this stream is ordered or unordered if all
     * elements of this stream match the given predicate then this operation
     * drops all elements (the result is an empty stream), or if no elements of
     * the stream match the given predicate then no elements are dropped (the
     * result is the same as the input).
     *
     * <p>This is a <a href="package-summary.html#StreamOps">stateful
     * intermediate operation</a>.
     *
     * @implSpec
     * The default implementation obtains the {@link #spliterator() spliterator}
     * of this stream, wraps that spliterator so as to support the semantics
     * of this operation on traversal, and returns a new stream associated with
     * the wrapped spliterator.  The returned stream preserves the execution
     * characteristics of this stream (namely parallel or sequential execution
     * as per {@link #isParallel()}) but the wrapped spliterator may choose to
     * not support splitting.  When the returned stream is closed, the close
     * handlers for both the returned and this stream are invoked.
     *
     * @apiNote
     * While {@code dropWhile()} is generally a cheap operation on sequential
     * stream pipelines, it can be quite expensive on ordered parallel
     * pipelines, since the operation is constrained to return not just any
     * valid prefix, but the longest prefix of elements in the encounter order.
     * Using an unordered stream source (such as {@link #generate(IntSupplier)})
     * or removing the ordering constraint with {@link #unordered()} may result
     * in significant speedups of {@code dropWhile()} in parallel pipelines, if
     * the semantics of your situation permit.  If consistency with encounter
     * order is required, and you are experiencing poor performance or memory
     * utilization with {@code dropWhile()} in parallel pipelines, switching to
     * sequential execution with {@link #sequential()} may improve performance.
     *
     * @param predicate a <a href="package-summary.html#NonInterference">non-interfering</a>,
     *                  <a href="package-summary.html#Statelessness">stateless</a>
     *                  predicate to apply to elements to determine the longest
     *                  prefix of elements.
     * @return the new stream
     * @since 9
     */
    default IntStream dropWhile(IntPredicate predicate) {

    /**
     * Returns a sequential ordered {@code IntStream} produced by iterative
     * application of the given {@code next} function to an initial element,
     * conditioned on satisfying the given {@code hasNext} predicate.  The
     * stream terminates as soon as the {@code hasNext} predicate returns false.
     *
     * <p>{@code IntStream.iterate} should produce the same sequence of elements as
     * produced by the corresponding for-loop:
     * <pre>{@code
     *     for (int index=seed; hasNext.test(index); index = next.applyAsInt(index)) {
     *         ...
     *     }
     * }</pre>
     *
     * <p>The resulting sequence may be empty if the {@code hasNext} predicate
     * does not hold on the seed value.  Otherwise the first element will be the
     * supplied {@code seed} value, the next element (if present) will be the
     * result of applying the {@code next} function to the {@code seed} value,
     * and so on iteratively until the {@code hasNext} predicate indicates that
     * the stream should terminate.
     *
     * <p>The action of applying the {@code hasNext} predicate to an element
     * <a href="../concurrent/package-summary.html#MemoryVisibility"><i>happens-before</i></a>
     * the action of applying the {@code next} function to that element.  The
     * action of applying the {@code next} function for one element
     * <i>happens-before</i> the action of applying the {@code hasNext}
     * predicate for subsequent elements.  For any given element an action may
     * be performed in whatever thread the library chooses.
     *
     * @param seed the initial element
     * @param hasNext a predicate to apply to elements to determine when the
     *                stream must terminate.
     * @param next a function to be applied to the previous element to produce
     *             a new element
     * @return a new sequential {@code IntStream}
     * @since 9
     */
    public static IntStream iterate(int seed, IntPredicate hasNext, IntUnaryOperator next) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\stream\LongStream.java
    /**
     * Returns, if this stream is ordered, a stream consisting of the longest
     * prefix of elements taken from this stream that match the given predicate.
     * Otherwise returns, if this stream is unordered, a stream consisting of a
     * subset of elements taken from this stream that match the given predicate.
     *
     * <p>If this stream is ordered then the longest prefix is a contiguous
     * sequence of elements of this stream that match the given predicate.  The
     * first element of the sequence is the first element of this stream, and
     * the element immediately following the last element of the sequence does
     * not match the given predicate.
     *
     * <p>If this stream is unordered, and some (but not all) elements of this
     * stream match the given predicate, then the behavior of this operation is
     * nondeterministic; it is free to take any subset of matching elements
     * (which includes the empty set).
     *
     * <p>Independent of whether this stream is ordered or unordered if all
     * elements of this stream match the given predicate then this operation
     * takes all elements (the result is the same as the input), or if no
     * elements of the stream match the given predicate then no elements are
     * taken (the result is an empty stream).
     *
     * <p>This is a <a href="package-summary.html#StreamOps">short-circuiting
     * stateful intermediate operation</a>.
     *
     * @implSpec
     * The default implementation obtains the {@link #spliterator() spliterator}
     * of this stream, wraps that spliterator so as to support the semantics
     * of this operation on traversal, and returns a new stream associated with
     * the wrapped spliterator.  The returned stream preserves the execution
     * characteristics of this stream (namely parallel or sequential execution
     * as per {@link #isParallel()}) but the wrapped spliterator may choose to
     * not support splitting.  When the returned stream is closed, the close
     * handlers for both the returned and this stream are invoked.
     *
     * @apiNote
     * While {@code takeWhile()} is generally a cheap operation on sequential
     * stream pipelines, it can be quite expensive on ordered parallel
     * pipelines, since the operation is constrained to return not just any
     * valid prefix, but the longest prefix of elements in the encounter order.
     * Using an unordered stream source (such as
     * {@link #generate(LongSupplier)}) or removing the ordering constraint with
     * {@link #unordered()} may result in significant speedups of
     * {@code takeWhile()} in parallel pipelines, if the semantics of your
     * situation permit.  If consistency with encounter order is required, and
     * you are experiencing poor performance or memory utilization with
     * {@code takeWhile()} in parallel pipelines, switching to sequential
     * execution with {@link #sequential()} may improve performance.
     *
     * @param predicate a <a href="package-summary.html#NonInterference">non-interfering</a>,
     *                  <a href="package-summary.html#Statelessness">stateless</a>
     *                  predicate to apply to elements to determine the longest
     *                  prefix of elements.
     * @return the new stream
     * @since 9
     */
    default LongStream takeWhile(LongPredicate predicate) {

    /**
     * Returns, if this stream is ordered, a stream consisting of the remaining
     * elements of this stream after dropping the longest prefix of elements
     * that match the given predicate.  Otherwise returns, if this stream is
     * unordered, a stream consisting of the remaining elements of this stream
     * after dropping a subset of elements that match the given predicate.
     *
     * <p>If this stream is ordered then the longest prefix is a contiguous
     * sequence of elements of this stream that match the given predicate.  The
     * first element of the sequence is the first element of this stream, and
     * the element immediately following the last element of the sequence does
     * not match the given predicate.
     *
     * <p>If this stream is unordered, and some (but not all) elements of this
     * stream match the given predicate, then the behavior of this operation is
     * nondeterministic; it is free to drop any subset of matching elements
     * (which includes the empty set).
     *
     * <p>Independent of whether this stream is ordered or unordered if all
     * elements of this stream match the given predicate then this operation
     * drops all elements (the result is an empty stream), or if no elements of
     * the stream match the given predicate then no elements are dropped (the
     * result is the same as the input).
     *
     * <p>This is a <a href="package-summary.html#StreamOps">stateful
     * intermediate operation</a>.
     *
     * @implSpec
     * The default implementation obtains the {@link #spliterator() spliterator}
     * of this stream, wraps that spliterator so as to support the semantics
     * of this operation on traversal, and returns a new stream associated with
     * the wrapped spliterator.  The returned stream preserves the execution
     * characteristics of this stream (namely parallel or sequential execution
     * as per {@link #isParallel()}) but the wrapped spliterator may choose to
     * not support splitting.  When the returned stream is closed, the close
     * handlers for both the returned and this stream are invoked.
     *
     * @apiNote
     * While {@code dropWhile()} is generally a cheap operation on sequential
     * stream pipelines, it can be quite expensive on ordered parallel
     * pipelines, since the operation is constrained to return not just any
     * valid prefix, but the longest prefix of elements in the encounter order.
     * Using an unordered stream source (such as
     * {@link #generate(LongSupplier)}) or removing the ordering constraint with
     * {@link #unordered()} may result in significant speedups of
     * {@code dropWhile()} in parallel pipelines, if the semantics of your
     * situation permit.  If consistency with encounter order is required, and
     * you are experiencing poor performance or memory utilization with
     * {@code dropWhile()} in parallel pipelines, switching to sequential
     * execution with {@link #sequential()} may improve performance.
     *
     * @param predicate a <a href="package-summary.html#NonInterference">non-interfering</a>,
     *                  <a href="package-summary.html#Statelessness">stateless</a>
     *                  predicate to apply to elements to determine the longest
     *                  prefix of elements.
     * @return the new stream
     * @since 9
     */
    default LongStream dropWhile(LongPredicate predicate) {

    /**
     * Returns a sequential ordered {@code LongStream} produced by iterative
     * application of the given {@code next} function to an initial element,
     * conditioned on satisfying the given {@code hasNext} predicate.  The
     * stream terminates as soon as the {@code hasNext} predicate returns false.
     *
     * <p>{@code LongStream.iterate} should produce the same sequence of elements as
     * produced by the corresponding for-loop:
     * <pre>{@code
     *     for (long index=seed; hasNext.test(index); index = next.applyAsLong(index)) {
     *         ...
     *     }
     * }</pre>
     *
     * <p>The resulting sequence may be empty if the {@code hasNext} predicate
     * does not hold on the seed value.  Otherwise the first element will be the
     * supplied {@code seed} value, the next element (if present) will be the
     * result of applying the {@code next} function to the {@code seed} value,
     * and so on iteratively until the {@code hasNext} predicate indicates that
     * the stream should terminate.
     *
     * <p>The action of applying the {@code hasNext} predicate to an element
     * <a href="../concurrent/package-summary.html#MemoryVisibility"><i>happens-before</i></a>
     * the action of applying the {@code next} function to that element.  The
     * action of applying the {@code next} function for one element
     * <i>happens-before</i> the action of applying the {@code hasNext}
     * predicate for subsequent elements.  For any given element an action may
     * be performed in whatever thread the library chooses.
     *
     * @param seed the initial element
     * @param hasNext a predicate to apply to elements to determine when the
     *                stream must terminate.
     * @param next a function to be applied to the previous element to produce
     *             a new element
     * @return a new sequential {@code LongStream}
     * @since 9
     */
    public static LongStream iterate(long seed, LongPredicate hasNext, LongUnaryOperator next) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\stream\Stream.java
    /**
     * Returns, if this stream is ordered, a stream consisting of the longest
     * prefix of elements taken from this stream that match the given predicate.
     * Otherwise returns, if this stream is unordered, a stream consisting of a
     * subset of elements taken from this stream that match the given predicate.
     *
     * <p>If this stream is ordered then the longest prefix is a contiguous
     * sequence of elements of this stream that match the given predicate.  The
     * first element of the sequence is the first element of this stream, and
     * the element immediately following the last element of the sequence does
     * not match the given predicate.
     *
     * <p>If this stream is unordered, and some (but not all) elements of this
     * stream match the given predicate, then the behavior of this operation is
     * nondeterministic; it is free to take any subset of matching elements
     * (which includes the empty set).
     *
     * <p>Independent of whether this stream is ordered or unordered if all
     * elements of this stream match the given predicate then this operation
     * takes all elements (the result is the same as the input), or if no
     * elements of the stream match the given predicate then no elements are
     * taken (the result is an empty stream).
     *
     * <p>This is a <a href="package-summary.html#StreamOps">short-circuiting
     * stateful intermediate operation</a>.
     *
     * @implSpec
     * The default implementation obtains the {@link #spliterator() spliterator}
     * of this stream, wraps that spliterator so as to support the semantics
     * of this operation on traversal, and returns a new stream associated with
     * the wrapped spliterator.  The returned stream preserves the execution
     * characteristics of this stream (namely parallel or sequential execution
     * as per {@link #isParallel()}) but the wrapped spliterator may choose to
     * not support splitting.  When the returned stream is closed, the close
     * handlers for both the returned and this stream are invoked.
     *
     * @apiNote
     * While {@code takeWhile()} is generally a cheap operation on sequential
     * stream pipelines, it can be quite expensive on ordered parallel
     * pipelines, since the operation is constrained to return not just any
     * valid prefix, but the longest prefix of elements in the encounter order.
     * Using an unordered stream source (such as {@link #generate(Supplier)}) or
     * removing the ordering constraint with {@link #unordered()} may result in
     * significant speedups of {@code takeWhile()} in parallel pipelines, if the
     * semantics of your situation permit.  If consistency with encounter order
     * is required, and you are experiencing poor performance or memory
     * utilization with {@code takeWhile()} in parallel pipelines, switching to
     * sequential execution with {@link #sequential()} may improve performance.
     *
     * @param predicate a <a href="package-summary.html#NonInterference">non-interfering</a>,
     *                  <a href="package-summary.html#Statelessness">stateless</a>
     *                  predicate to apply to elements to determine the longest
     *                  prefix of elements.
     * @return the new stream
     * @since 9
     */
    default Stream<T> takeWhile(Predicate<? super T> predicate) {

    /**
     * Returns, if this stream is ordered, a stream consisting of the remaining
     * elements of this stream after dropping the longest prefix of elements
     * that match the given predicate.  Otherwise returns, if this stream is
     * unordered, a stream consisting of the remaining elements of this stream
     * after dropping a subset of elements that match the given predicate.
     *
     * <p>If this stream is ordered then the longest prefix is a contiguous
     * sequence of elements of this stream that match the given predicate.  The
     * first element of the sequence is the first element of this stream, and
     * the element immediately following the last element of the sequence does
     * not match the given predicate.
     *
     * <p>If this stream is unordered, and some (but not all) elements of this
     * stream match the given predicate, then the behavior of this operation is
     * nondeterministic; it is free to drop any subset of matching elements
     * (which includes the empty set).
     *
     * <p>Independent of whether this stream is ordered or unordered if all
     * elements of this stream match the given predicate then this operation
     * drops all elements (the result is an empty stream), or if no elements of
     * the stream match the given predicate then no elements are dropped (the
     * result is the same as the input).
     *
     * <p>This is a <a href="package-summary.html#StreamOps">stateful
     * intermediate operation</a>.
     *
     * @implSpec
     * The default implementation obtains the {@link #spliterator() spliterator}
     * of this stream, wraps that spliterator so as to support the semantics
     * of this operation on traversal, and returns a new stream associated with
     * the wrapped spliterator.  The returned stream preserves the execution
     * characteristics of this stream (namely parallel or sequential execution
     * as per {@link #isParallel()}) but the wrapped spliterator may choose to
     * not support splitting.  When the returned stream is closed, the close
     * handlers for both the returned and this stream are invoked.
     *
     * @apiNote
     * While {@code dropWhile()} is generally a cheap operation on sequential
     * stream pipelines, it can be quite expensive on ordered parallel
     * pipelines, since the operation is constrained to return not just any
     * valid prefix, but the longest prefix of elements in the encounter order.
     * Using an unordered stream source (such as {@link #generate(Supplier)}) or
     * removing the ordering constraint with {@link #unordered()} may result in
     * significant speedups of {@code dropWhile()} in parallel pipelines, if the
     * semantics of your situation permit.  If consistency with encounter order
     * is required, and you are experiencing poor performance or memory
     * utilization with {@code dropWhile()} in parallel pipelines, switching to
     * sequential execution with {@link #sequential()} may improve performance.
     *
     * @param predicate a <a href="package-summary.html#NonInterference">non-interfering</a>,
     *                  <a href="package-summary.html#Statelessness">stateless</a>
     *                  predicate to apply to elements to determine the longest
     *                  prefix of elements.
     * @return the new stream
     * @since 9
     */
    default Stream<T> dropWhile(Predicate<? super T> predicate) {

    /**
     * Returns a sequential {@code Stream} containing a single element, if
     * non-null, otherwise returns an empty {@code Stream}.
     *
     * @param t the single element
     * @param <T> the type of stream elements
     * @return a stream with a single element if the specified element
     *         is non-null, otherwise an empty stream
     * @since 9
     */
    public static<T> Stream<T> ofNullable(T t) {

    /**
     * Returns a sequential ordered {@code Stream} produced by iterative
     * application of the given {@code next} function to an initial element,
     * conditioned on satisfying the given {@code hasNext} predicate.  The
     * stream terminates as soon as the {@code hasNext} predicate returns false.
     *
     * <p>{@code Stream.iterate} should produce the same sequence of elements as
     * produced by the corresponding for-loop:
     * <pre>{@code
     *     for (T index=seed; hasNext.test(index); index = next.apply(index)) {
     *         ...
     *     }
     * }</pre>
     *
     * <p>The resulting sequence may be empty if the {@code hasNext} predicate
     * does not hold on the seed value.  Otherwise the first element will be the
     * supplied {@code seed} value, the next element (if present) will be the
     * result of applying the {@code next} function to the {@code seed} value,
     * and so on iteratively until the {@code hasNext} predicate indicates that
     * the stream should terminate.
     *
     * <p>The action of applying the {@code hasNext} predicate to an element
     * <a href="../concurrent/package-summary.html#MemoryVisibility"><i>happens-before</i></a>
     * the action of applying the {@code next} function to that element.  The
     * action of applying the {@code next} function for one element
     * <i>happens-before</i> the action of applying the {@code hasNext}
     * predicate for subsequent elements.  For any given element an action may
     * be performed in whatever thread the library chooses.
     *
     * @param <T> the type of stream elements
     * @param seed the initial element
     * @param hasNext a predicate to apply to elements to determine when the
     *                stream must terminate.
     * @param next a function to be applied to the previous element to produce
     *             a new element
     * @return a new sequential {@code Stream}
     * @since 9
     */
    public static<T> Stream<T> iterate(T seed, Predicate<? super T> hasNext, UnaryOperator<T> next) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\stream\WhileOps.java
/**
 * Factory for instances of a takeWhile and dropWhile operations
 * that produce subsequences of their input stream.
 *
 * @since 9
 */
final class WhileOps {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\zip\Checksum.java
    /**
     * Updates the current checksum with the specified array of bytes.
     *
     * @implSpec This default implementation is equal to calling
     * {@code update(b, 0, b.length)}.
     *
     * @param b the array of bytes to update the checksum with
     *
     * @throws NullPointerException
     *         if {@code b} is {@code null}
     *
     * @since 9
     */
    default public void update(byte[] b) {

    /**
     * Updates the current checksum with the bytes from the specified buffer.
     *
     * The checksum is updated with the remaining bytes in the buffer, starting
     * at the buffer's position. Upon return, the buffer's position will be
     * updated to its limit; its limit will not have been changed.
     *
     * @apiNote For best performance with DirectByteBuffer and other ByteBuffer
     * implementations without a backing array implementers of this interface
     * should override this method.
     *
     * @implSpec The default implementation has the following behavior.<br>
     * For ByteBuffers backed by an accessible byte array.
     * <pre>{@code
     * update(buffer.array(),
     *        buffer.position() + buffer.arrayOffset(),
     *        buffer.remaining());
     * }</pre>
     * For ByteBuffers not backed by an accessible byte array.
     * <pre>{@code
     * byte[] b = new byte[Math.min(buffer.remaining(), 4096)];
     * while (buffer.hasRemaining()) {
     *     int length = Math.min(buffer.remaining(), b.length);
     *     buffer.get(b, 0, length);
     *     update(b, 0, length);
     * }
     * }</pre>
     *
     * @param buffer the ByteBuffer to update the checksum with
     *
     * @throws NullPointerException
     *         if {@code buffer} is {@code null}
     *
     * @since 9
     */
    default public void update(ByteBuffer buffer) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\zip\CRC32C.java
/**
 * A class that can be used to compute the CRC-32C of a data stream.
 *
 * <p>
 * CRC-32C is defined in <a href="http://www.ietf.org/rfc/rfc3720.txt">RFC
 * 3720</a>: Internet Small Computer Systems Interface (iSCSI).
 * </p>
 *
 * <p>
 * Passing a {@code null} argument to a method in this class will cause a
 * {@link NullPointerException} to be thrown.
 * </p>
 *
 * @since 9
 */
public final class CRC32C implements Checksum {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\java\util\zip\ZipEntry.java
    /**
     * Sets the last modification time of the entry in local date-time.
     *
     * <p> If the entry is output to a ZIP file or ZIP file formatted
     * output stream the last modification time set by this method will
     * be stored into the {@code date and time fields} of the zip file
     * entry and encoded in standard {@code MS-DOS date and time format}.
     * If the date-time set is out of the range of the standard {@code
     * MS-DOS date and time format}, the time will also be stored into
     * zip file entry's extended timestamp fields in {@code optional
     * extra data} in UTC time. The {@link java.time.ZoneId#systemDefault()
     * system default TimeZone} is used to convert the local date-time
     * to UTC time.
     *
     * <p> {@code LocalDateTime} uses a precision of nanoseconds, whereas
     * this class uses a precision of milliseconds. The conversion will
     * truncate any excess precision information as though the amount in
     * nanoseconds was subject to integer division by one million.
     *
     * @param  time
     *         The last modification time of the entry in local date-time
     *
     * @see #getTimeLocal()
     * @since 9
     */
    public void setTimeLocal(LocalDateTime time) {

    /**
     * Returns the last modification time of the entry in local date-time.
     *
     * <p> If the entry is read from a ZIP file or ZIP file formatted
     * input stream, this is the last modification time from the zip
     * file entry's {@code optional extra data} if the extended timestamp
     * fields are present. Otherwise, the last modification time is read
     * from entry's standard MS-DOS formatted {@code date and time fields}.
     *
     * <p> The {@link java.time.ZoneId#systemDefault() system default TimeZone}
     * is used to convert the UTC time to local date-time.
     *
     * @return  The last modification time of the entry in local date-time
     *
     * @see #setTimeLocal(LocalDateTime)
     * @since 9
     */
    public LocalDateTime getTimeLocal() {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\accessibility\AccessibilityProvider.java
/**
 * Service Provider Interface (SPI) for Assistive Technology.
 * <p>
 * This service provider class provides mappings from the platform
 * specific accessibility APIs to the Java Accessibility API.
 * <p>
 * Each service provider implementation is named and can be activated via the
 * {@link #activate} method. Service providers can be loaded when the default
 * {@link java.awt.Toolkit toolkit} is initialized.
 *
 * @apiNote There will typically be one provider per platform, such as Windows
 * or Linux, to support accessibility for screen readers and magnifiers.  However,
 * more than one service provider can be activated.  For example, a test tool
 * which provides visual results obtained by interrogating the Java Accessibility
 * API can be activated along with the activation of the support for screen readers
 * and screen magnifiers.
 *
 * @see java.awt.Toolkit#getDefaultToolkit
 * @see java.util.ServiceLoader
 * @since 9
 */
public abstract class AccessibilityProvider {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\annotation\processing\RoundEnvironment.java
    /**
     * Returns the elements annotated with one or more of the given
     * annotation types.
     *
     * @apiNote This method may be useful when processing repeating
     * annotations by looking for an annotation type and its
     * containing annotation type at the same time.
     *
     * @implSpec The default implementation of this method creates an
     * empty result set, iterates over the annotations in the argument
     * array calling {@link #getElementsAnnotatedWith(TypeElement)} on
     * each annotation and adding those results to the result
     * set. Finally, the contents of the result set are returned as an
     * unmodifiable set.
     *
     * @param annotations  annotation types being requested
     * @return the elements annotated with one or more of the given
     * annotation types, or an empty set if there are none
     * @throws IllegalArgumentException if the any elements of the
     * argument set do not represent an annotation type
     * @jls 9.6.3 Repeatable Annotation Types
     * @since 9
     */
    default Set<? extends Element> getElementsAnnotatedWithAny(TypeElement... annotations){

    /**
     * Returns the elements annotated with one or more of the given
     * annotation types.
     *
     * @apiNote This method may be useful when processing repeating
     * annotations by looking for an annotation type and its
     * containing annotation type at the same time.
     *
     * @implSpec The default implementation of this method creates an
     * empty result set, iterates over the annotations in the argument
     * set calling {@link #getElementsAnnotatedWith(Class)} on
     * each annotation and adding those results to the result
     * set. Finally, the contents of the result set are returned as an
     * unmodifiable set.
     *
     * @param annotations  annotation types being requested
     * @return the elements annotated with one or more of the given
     * annotation types, or an empty set if there are none
     * @throws IllegalArgumentException if the any elements of the
     * argument set do not represent an annotation type
     * @jls 9.6.3 Repeatable Annotation Types
     * @since 9
     */
    default Set<? extends Element> getElementsAnnotatedWithAny(Set<Class<? extends Annotation>> annotations){

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\imageio\plugins\tiff\BaselineTIFFTagSet.java
/**
 * A class representing the set of tags found in the baseline TIFF
 * specification as well as some common additional tags.
 *
 * <p> The non-baseline tags included in this class are:
 * <ul>
 * <li> {@link #TAG_JPEG_TABLES JPEGTables}
 * <li> {@link #TAG_ICC_PROFILE ICC&nbsp;Profile}
 * </ul>
 *
 * <p> The non-baseline values of baseline tags included in this class are
 * <ul>
 * <li>{@link #TAG_COMPRESSION Compression} tag values:
 * <ul>
 * <li>{@link #COMPRESSION_JPEG JPEG-in-TIFF&nbsp;compression}</li>
 * <li>{@link #COMPRESSION_ZLIB Zlib-in-TIFF&nbsp;compression}</li>
 * <li>{@link #COMPRESSION_DEFLATE Deflate&nbsp;compression}</li>
 * </ul>
 * </li>
 * <li>{@link #TAG_PHOTOMETRIC_INTERPRETATION PhotometricInterpretation}
 * tag values:
 * <ul>
 * <li>{@link #PHOTOMETRIC_INTERPRETATION_ICCLAB ICCLAB&nbsp;
 * photometric&nbsp;interpretation}</li>
 * </ul>
 * </li>
 * </ul>
 *
 * @since 9
 * @see   <a href="http://partners.adobe.com/public/developer/en/tiff/TIFF6.pdf">  TIFF 6.0 Specification</a>
 */
public final class BaselineTIFFTagSet extends TIFFTagSet {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\imageio\plugins\tiff\ExifGPSTagSet.java
/**
 * A class representing the tags found in an Exif GPS Info IFD.
 *
 * <p> The definitions of the data types referenced by the field
 * definitions may be found in the {@link TIFFTag TIFFTag} class.
 *
 * @since 9
 * @see   ExifTIFFTagSet
 */
public final class ExifGPSTagSet extends TIFFTagSet {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\imageio\plugins\tiff\ExifInteroperabilityTagSet.java
/**
 * A class representing the tags found in an Exif Interoperability IFD.
 *
 * @since 9
 * @see   ExifTIFFTagSet
 */
public final class ExifInteroperabilityTagSet extends TIFFTagSet {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\imageio\plugins\tiff\ExifParentTIFFTagSet.java
/**
 * A class containing the TIFF tags used to reference the Exif and GPS IFDs.
 * This tag set should be added to the root tag set by means of the
 * {@link TIFFImageReadParam#addAllowedTagSet(TIFFTagSet)
 * TIFFImageReadParam.addAllowedTagSet} method if Exif
 * support is desired.
 *
 * @since 9
 */
public final class ExifParentTIFFTagSet extends TIFFTagSet {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\imageio\plugins\tiff\ExifTIFFTagSet.java
/**
 * A class representing the tags found in an Exif IFD.  Exif is a
 * standard for annotating images used by most digital camera
 * manufacturers.  The Exif specification may be found at
 * <a href="http://www.exif.org/Exif2-2.PDF">
 * {@code http://www.exif.org/Exif2-2.PDF}
 * </a>.
 *
 * <p> The definitions of the data types referenced by the field
 * definitions may be found in the {@link TIFFTag TIFFTag} class.
 *
 * @since 9
 */
public final class ExifTIFFTagSet extends TIFFTagSet {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\imageio\plugins\tiff\FaxTIFFTagSet.java
/**
 * A class representing the extra tags found in a
 * <a href="http://tools.ietf.org/html/rfc2306"> TIFF-F</a> (RFC 2036) file.
 *
 * @since 9
 */
public final class FaxTIFFTagSet extends TIFFTagSet {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\imageio\plugins\tiff\GeoTIFFTagSet.java
/**
 * A class representing the tags found in a GeoTIFF IFD.  GeoTIFF is a
 * standard for annotating georeferenced or geocoded raster imagery.
 * The GeoTIFF specification may be found at <a
 * href="http://www.remotesensing.org/geotiff/spec/geotiffhome.html">
 * {@code http://www.remotesensing.org/geotiff/spec/geotiffhome.html}
 * </a>. This class does <i>not</i> handle the <i>GeoKey</i>s referenced
 * from a <i>GeoKeyDirectoryTag</i> as those are not TIFF tags per se.
 *
 * <p>The definitions of the data types referenced by the field
 * definitions may be found in the {@link TIFFTag TIFFTag} class.</p>
 *
 * @since 9
 */
public final class GeoTIFFTagSet extends TIFFTagSet {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\imageio\plugins\tiff\TIFFDirectory.java
/**
 * A convenience class for simplifying interaction with TIFF native
 * image metadata. A TIFF image metadata tree represents an Image File
 * Directory (IFD) from a TIFF 6.0 stream. An IFD consists of a number of
 * IFD Entries each of which associates an identifying tag number with
 * a compatible value. A {@code TIFFDirectory} instance corresponds
 * to an IFD and contains a set of {@link TIFFField}s each of which
 * corresponds to an IFD Entry in the IFD.
 *
 * <p>When reading, a {@code TIFFDirectory} may be created by passing
 * the value returned by {@link javax.imageio.ImageReader#getImageMetadata
 * ImageReader.getImageMetadata()} to {@link #createFromMetadata
 * createFromMetadata()}. The {@link TIFFField}s in the directory may then
 * be obtained using the accessor methods provided in this class.</p>
 *
 * <p>When writing, an {@link IIOMetadata} object for use by one of the
 * {@code write()} methods of {@link javax.imageio.ImageWriter} may be
 * created from a {@code TIFFDirectory} by {@link #getAsMetadata()}.
 * The {@code TIFFDirectory} itself may be created by construction or
 * from the {@code IIOMetadata} object returned by
 * {@link javax.imageio.ImageWriter#getDefaultImageMetadata
 * ImageWriter.getDefaultImageMetadata()}. The {@code TIFFField}s in the
 * directory may be set using the mutator methods provided in this class.</p>
 *
 * <p>A {@code TIFFDirectory} is aware of the tag numbers in the
 * group of {@link TIFFTagSet}s associated with it. When
 * a {@code TIFFDirectory} is created from a native image metadata
 * object, these tag sets are derived from the <tt>tagSets</tt> attribute
 * of the <tt>TIFFIFD</tt> node.</p>
 *
 * <p>A {@code TIFFDirectory} might also have a parent {@link TIFFTag}.
 * This will occur if the directory represents an IFD other than the root
 * IFD of the image. The parent tag is the tag of the IFD Entry which is a
 * pointer to the IFD represented by this {@code TIFFDirectory}. The
 * {@link TIFFTag#isIFDPointer} method of this parent {@code TIFFTag}
 * must return {@code true}.  When a {@code TIFFDirectory} is
 * created from a native image metadata object, the parent tag set is set
 * from the <tt>parentTagName</tt> attribute of the corresponding
 * <tt>TIFFIFD</tt> node. Note that a {@code TIFFDirectory} instance
 * which has a non-{@code null} parent tag will be contained in the
 * data field of a {@code TIFFField} instance which has a tag field
 * equal to the contained directory's parent tag.</p>
 *
 * <p>As an example consider an Exif image. The {@code TIFFDirectory}
 * instance corresponding to the Exif IFD in the Exif stream would have parent
 * tag {@link ExifParentTIFFTagSet#TAG_EXIF_IFD_POINTER TAG_EXIF_IFD_POINTER}
 * and would include {@link ExifTIFFTagSet} in its group of known tag sets.
 * The {@code TIFFDirectory} corresponding to this Exif IFD will be
 * contained in the data field of a {@code TIFFField} which will in turn
 * be contained in the {@code TIFFDirectory} corresponding to the primary
 * IFD of the Exif image which will itself have a {@code null}-valued
 * parent tag.</p>
 *
 * <p><b>Note that this implementation is not synchronized. </b>If multiple
 * threads use a {@code TIFFDirectory} instance concurrently, and at
 * least one of the threads modifies the directory, for example, by adding
 * or removing {@code TIFFField}s or {@code TIFFTagSet}s, it
 * <i>must</i> be synchronized externally.</p>
 *
 * @since 9
 * @see   IIOMetadata
 * @see   TIFFField
 * @see   TIFFTag
 * @see   TIFFTagSet
 */
public class TIFFDirectory implements Cloneable {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\imageio\plugins\tiff\TIFFField.java
/**
 * A class representing a field in a TIFF 6.0 Image File Directory.
 *
 * <p> A field in a TIFF Image File Directory (IFD) is defined as a
 * tag number accompanied by a sequence of values of identical data type.
 * TIFF 6.0 defines 12 data types; a 13th type {@code IFD} is
 * defined in TIFF Tech Note 1 of TIFF Specification Supplement 1. These
 * TIFF data types are referred to by Java constants and mapped internally
 * onto Java language data types and type names as follows:
 *
 * <br>
 * <br>
 * <table border="1">
 * <caption>TIFF Data Type to Java Data Type Mapping</caption>
 *
 * <tr>
 * <th>
 * <b>TIFF Data Type</b>
 * </th>
 * <th>
 * <b>Java Constant</b>
 * </th>
 * <th>
 * <b>Java Data Type</b>
 * </th>
 * <th>
 * <b>Java Type Name</b>
 * </th>
 * </tr>
 *
 * <tr>
 * <td>
 * <tt>BYTE</tt>
 * </td>
 * <td>
 * {@link TIFFTag#TIFF_BYTE}
 * </td>
 * <td>
 * {@code byte}
 * </td>
 * <td>
 * {@code "Byte"}
 * </td>
 * </tr>
 *
 * <tr>
 * <td>
 * <tt>ASCII</tt>
 * </td>
 * <td>
 * {@link TIFFTag#TIFF_ASCII}
 * </td>
 * <td>
 * {@code String}
 * </td>
 * <td>
 * {@code "Ascii"}
 * </td>
 * </tr>
 *
 * <tr>
 * <td>
 * <tt>SHORT</tt>
 * </td>
 * <td>
 * {@link TIFFTag#TIFF_SHORT}
 * </td>
 * <td>
 * {@code char}
 * </td>
 * <td>
 * {@code "Short"}
 * </td>
 * </tr>
 *
 * <tr>
 * <td>
 * <tt>LONG</tt>
 * </td>
 * <td>
 * {@link TIFFTag#TIFF_LONG}
 * </td>
 * <td>
 * {@code long}
 * </td>
 * <td>
 * {@code "Long"}
 * </td>
 * </tr>
 *
 * <tr>
 * <td>
 * <tt>RATIONAL</tt>
 * </td>
 * <td>
 * {@link TIFFTag#TIFF_RATIONAL}
 * </td>
 * <td>
 * {@code long[2]} {numerator, denominator}
 * </td>
 * <td>
 * {@code "Rational"}
 * </td>
 * </tr>
 *
 * <tr>
 * <td>
 * <tt>SBYTE</tt>
 * </td>
 * <td>
 * {@link TIFFTag#TIFF_SBYTE}
 * </td>
 * <td>
 * {@code byte}
 * </td>
 * <td>
 * {@code "SByte"}
 * </td>
 * </tr>
 *
 * <tr>
 * <td>
 * <tt>UNDEFINED</tt>
 * </td>
 * <td>
 * {@link TIFFTag#TIFF_UNDEFINED}
 * </td>
 * <td>
 * {@code byte}
 * </td>
 * <td>
 * {@code "Undefined"}
 * </td>
 * </tr>
 *
 * <tr>
 * <td>
 * <tt>SSHORT</tt>
 * </td>
 * <td>
 * {@link TIFFTag#TIFF_SSHORT}
 * </td>
 * <td>
 * {@code short}
 * </td>
 * <td>
 * {@code "SShort"}
 * </td>
 * </tr>
 *
 * <tr>
 * <td>
 * <tt>SLONG</tt>
 * </td>
 * <td>
 * {@link TIFFTag#TIFF_SLONG}
 * </td>
 * <td>
 * {@code int}
 * </td>
 * <td>
 * {@code "SLong"}
 * </td>
 * </tr>
 *
 * <tr>
 * <td>
 * <tt>SRATIONAL</tt>
 * </td>
 * <td>
 * {@link TIFFTag#TIFF_SRATIONAL}
 * </td>
 * <td>
 * {@code int[2]} {numerator, denominator}
 * </td>
 * <td>
 * {@code "SRational"}
 * </td>
 * </tr>
 *
 * <tr>
 * <td>
 * <tt>FLOAT</tt>
 * </td>
 * <td>
 * {@link TIFFTag#TIFF_FLOAT}
 * </td>
 * <td>
 * {@code float}
 * </td>
 * <td>
 * {@code "Float"}
 * </td>
 * </tr>
 *
 * <tr>
 * <td>
 * <tt>DOUBLE</tt>
 * </td>
 * <td>
 * {@link TIFFTag#TIFF_DOUBLE}
 * </td>
 * <td>
 * {@code double}
 * </td>
 * <td>
 * {@code "Double"}
 * </td>
 * </tr>
 *
 * <tr>
 * <td>
 * <tt>IFD</tt>
 * </td>
 * <td>
 * {@link TIFFTag#TIFF_IFD_POINTER}
 * </td>
 * <td>
 * {@code long}
 * </td>
 * <td>
 * {@code "IFDPointer"}
 * </td>
 * </tr>
 *
 * </table>
 *
 * @since 9
 * @see   TIFFDirectory
 * @see   TIFFTag
 */
public class TIFFField implements Cloneable {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\imageio\plugins\tiff\TIFFImageReadParam.java
/**
 * A subclass of {@link ImageReadParam} allowing control over
 * the TIFF reading process.
 *
 * <p> Because TIFF is an extensible format, the reader requires
 * information about any tags used by TIFF extensions in order to emit
 * meaningful metadata.  Also, TIFF extensions may define new
 * compression types.  Both types of information about extensions may
 * be provided by this interface.
 *
 * <p> Additional TIFF tags must be organized into
 * {@code TIFFTagSet}s.  A {@code TIFFTagSet} may be
 * provided to the reader by means of the
 * {@code addAllowedTagSet} method.  By default, the tag sets
 * {@code BaselineTIFFTagSet}, {@code FaxTIFFTagSet},
 * {@code ExifParentTIFFTagSet}, and {@code GeoTIFFTagSet}
 * are included.
 *
 * @since 9
 */
public class TIFFImageReadParam extends ImageReadParam {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\imageio\plugins\tiff\TIFFTag.java
/**
 * A class defining the notion of a TIFF tag.  A TIFF tag is a key
 * that may appear in an Image File Directory (IFD).  In the IFD
 * each tag has some data associated with it, which may consist of zero
 * or more values of a given data type. The combination of a tag and a
 * value is known as an IFD Entry or TIFF Field.
 *
 * <p> The actual tag values used in the root IFD of a standard ("baseline")
 * tiff stream are defined in the {@link BaselineTIFFTagSet
 * BaselineTIFFTagSet} class.
 *
 * @since 9
 * @see   BaselineTIFFTagSet
 * @see   TIFFField
 * @see   TIFFTagSet
 */
public class TIFFTag {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\imageio\plugins\tiff\TIFFTagSet.java
/**
 * A class representing a set of TIFF tags.  Each tag in the set must have
 * a unique number (this is a limitation of the TIFF specification itself).
 *
 * <p> This class and its subclasses are responsible for mapping
 * between raw tag numbers and {@code TIFFTag} objects, which
 * contain additional information about each tag, such as the tag's
 * name, legal data types, and mnemonic names for some or all of its
 * data values.
 *
 * @since 9
 * @see   TIFFTag
 */
public class TIFFTagSet {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\lang\model\element\ElementKind.java
    /**
     * A module.
     * @since 9
     */
     MODULE;

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\lang\model\element\ElementVisitor.java
    /**
     * Visits a module element.
     * @param e  the element to visit
     * @param p  a visitor-specified parameter
     * @return a visitor-specified result
     * @since 9
     */
    R visitModule(ModuleElement e, P p);

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\lang\model\element\ModuleElement.java
/**
 * Represents a module program element.  Provides access to information
 * about the module and its members.
 *
 * @see javax.lang.model.util.Elements#getModuleOf
 * @since 9
 */  // TODO: add @jls to module section
public interface ModuleElement extends Element, QualifiedNameable {

    /**
     * The {@code kind} of a directive.
     *
     * <p>Note that it is possible additional directive kinds will be added
     * to accommodate new, currently unknown, language structures added to
     * future versions of the Java&trade; programming language.
     *
     * @since 9
     */
    enum DirectiveKind {

    /**
     * Represents a "module statement" within the declaration of this module.
     *
     * @since 9
     *
     */ // TODO: add jls to Module Statement
    interface Directive {

    /**
     * A dependency of a module.
     * @since 9
     */
    interface RequiresDirective extends Directive {

    /**
     * An exported package of a module.
     * @since 9
     */
    interface ExportsDirective extends Directive {

    /**
     * An implementation of a service provided by a module.
     * @since 9
     */
    interface ProvidesDirective extends Directive {

    /**
     * A reference to a service used by a module.
     * @since 9
     */
    interface UsesDirective extends Directive {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\lang\model\SourceVersion.java
    /**
     * The version recognized by the Java Platform, Standard Edition
     * 9.
     *
     * Additions in this release include modules and removal of a
     * single underscore from the set of legal identifier names.
     *
     * @since 9
     */
     RELEASE_9;

    /**
     * Returns whether or not {@code name} is a syntactically valid
     * qualified name in the given source version.  Unlike {@link
     * #isIdentifier isIdentifier}, this method returns {@code false}
     * for keywords, boolean literals, and the null literal.
     *
     * @param name the string to check
     * @param version the version to use
     * @return {@code true} if this string is a
     * syntactically valid name, {@code false} otherwise.
     * @jls 6.2 Names and Identifiers
     * @since 9
     */
    public static boolean isName(CharSequence name, SourceVersion version) {

    /**
     * Returns whether or not {@code s} is a keyword, boolean literal,
     * or null literal in the given source version.
     *
     * @param s the string to check
     * @param version the version to use
     * @return {@code true} if {@code s} is a keyword, or boolean
     * literal, or null literal, {@code false} otherwise.
     * @jls 3.9 Keywords
     * @jls 3.10.3 Boolean Literals
     * @jls 3.10.7 The Null Literal
     * @since 9
     */
    public static boolean isKeyword(CharSequence s, SourceVersion version) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\lang\model\type\TypeKind.java
    /**
     * A pseudo-type corresponding to a module element.
     * @see NoType
     * @since 9
     */
    MODULE;

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\lang\model\util\AbstractAnnotationValueVisitor9.java
/**
 * A skeletal visitor for annotation values with default behavior
 * appropriate for the {@link SourceVersion#RELEASE_9 RELEASE_9}
 * source version.
 *
 * <p> <b>WARNING:</b> The {@code AnnotationValueVisitor} interface
 * implemented by this class may have methods added to it in the
 * future to accommodate new, currently unknown, language structures
 * added to future versions of the Java&trade; programming language.
 * Therefore, methods whose names begin with {@code "visit"} may be
 * added to this class in the future; to avoid incompatibilities,
 * classes which extend this class should not declare any instance
 * methods with names beginning with {@code "visit"}.
 *
 * <p>When such a new visit method is added, the default
 * implementation in this class will be to call the {@link
 * #visitUnknown visitUnknown} method.  A new abstract annotation
 * value visitor class will also be introduced to correspond to the
 * new language level; this visitor will have different default
 * behavior for the visit method in question.  When the new visitor is
 * introduced, all or portions of this visitor may be deprecated.
 *
 * @param <R> the return type of this visitor's methods
 * @param <P> the type of the additional parameter to this visitor's methods.
 *
 * @see AbstractAnnotationValueVisitor6
 * @see AbstractAnnotationValueVisitor7
 * @see AbstractAnnotationValueVisitor8
 * @since 9
 */
@SupportedSourceVersion(RELEASE_9)
public abstract class AbstractAnnotationValueVisitor9<R, P> extends AbstractAnnotationValueVisitor8<R, P> {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\lang\model\util\AbstractElementVisitor6.java
    /**
     * {@inheritDoc}
     *
     * @implSpec Visits a {@code ModuleElement} by calling {@code
     * visitUnknown}.
     *
     * @param e  {@inheritDoc}
     * @param p  {@inheritDoc}
     * @return the result of {@code visitUnknown}
     *
     * @since 9
     */
    @Override
    public R visitModule(ModuleElement e, P p) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\lang\model\util\AbstractElementVisitor9.java
/**
 * A skeletal visitor of program elements with default behavior
 * appropriate for the {@link SourceVersion#RELEASE_9 RELEASE_9}
 * source version.
 *
 * <p> <b>WARNING:</b> The {@code ElementVisitor} interface
 * implemented by this class may have methods added to it in the
 * future to accommodate new, currently unknown, language structures
 * added to future versions of the Java&trade; programming language.
 * Therefore, methods whose names begin with {@code "visit"} may be
 * added to this class in the future; to avoid incompatibilities,
 * classes which extend this class should not declare any instance
 * methods with names beginning with {@code "visit"}.
 *
 * <p>When such a new visit method is added, the default
 * implementation in this class will be to call the {@link
 * #visitUnknown visitUnknown} method.  A new abstract element visitor
 * class will also be introduced to correspond to the new language
 * level; this visitor will have different default behavior for the
 * visit method in question.  When the new visitor is introduced, all
 * or portions of this visitor may be deprecated.
 *
 * @param <R> the return type of this visitor's methods.  Use {@link
 *            Void} for visitors that do not need to return results.
 * @param <P> the type of the additional parameter to this visitor's
 *            methods.  Use {@code Void} for visitors that do not need an
 *            additional parameter.
 *
 * @see AbstractElementVisitor6
 * @see AbstractElementVisitor7
 * @see AbstractElementVisitor8
 * @since 9
 */
@SupportedSourceVersion(RELEASE_9)
public abstract class AbstractElementVisitor9<R, P> extends AbstractElementVisitor8<R, P> {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\lang\model\util\AbstractTypeVisitor9.java
/**
 * A skeletal visitor of types with default behavior appropriate for
 * the {@link javax.lang.model.SourceVersion#RELEASE_9 RELEASE_9}
 * source version.
 *
 * <p> <b>WARNING:</b> The {@code TypeVisitor} interface implemented
 * by this class may have methods added to it in the future to
 * accommodate new, currently unknown, language structures added to
 * future versions of the Java&trade; programming language.
 * Therefore, methods whose names begin with {@code "visit"} may be
 * added to this class in the future; to avoid incompatibilities,
 * classes which extend this class should not declare any instance
 * methods with names beginning with {@code "visit"}.
 *
 * <p>When such a new visit method is added, the default
 * implementation in this class will be to call the {@link
 * #visitUnknown visitUnknown} method.  A new abstract type visitor
 * class will also be introduced to correspond to the new language
 * level; this visitor will have different default behavior for the
 * visit method in question.  When the new visitor is introduced, all
 * or portions of this visitor may be deprecated.
 *
 * @param <R> the return type of this visitor's methods.  Use {@link
 *            Void} for visitors that do not need to return results.
 * @param <P> the type of the additional parameter to this visitor's
 *            methods.  Use {@code Void} for visitors that do not need an
 *            additional parameter.
 *
 * @see AbstractTypeVisitor6
 * @see AbstractTypeVisitor7
 * @see AbstractTypeVisitor8
 * @since 9
 */
@SupportedSourceVersion(RELEASE_9)
public abstract class AbstractTypeVisitor9<R, P> extends AbstractTypeVisitor8<R, P> {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\lang\model\util\ElementFilter.java
    /**
     * Returns a list of modules in {@code elements}.
     * @return a list of modules in {@code elements}
     * @param elements the elements to filter
     * @since 9
     */
    public static List<ModuleElement>
            modulesIn(Iterable<? extends Element> elements) {

    /**
     * Returns a set of modules in {@code elements}.
     * @return a set of modules in {@code elements}
     * @param elements the elements to filter
     * @since 9
     */
    public static Set<ModuleElement>
            modulesIn(Set<? extends Element> elements) {

    /**
     * Returns a list of export directives in {@code directives}.
     * @return a list of export directives in {@code directives}
     * @param directives the directives to filter
     * @since 9
     */
    public static List<ExportsDirective>
            exportsIn(Iterable<? extends Directive> directives) {

    /**
     * Returns a list of provides directives in {@code directives}.
     * @return a list of provides directives in {@code directives}
     * @param directives the directives to filter
     * @since 9
     */
    public static List<ProvidesDirective>
            providesIn(Iterable<? extends Directive> directives) {

    /**
     * Returns a list of requires directives in {@code directives}.
     * @return a list of requires directives in {@code directives}
     * @param directives the directives to filter
     * @since 9
     */
    public static List<RequiresDirective>
            requiresIn(Iterable<? extends Directive> directives) {

    /**
     * Returns a list of uses directives in {@code directives}.
     * @return a list of uses directives in {@code directives}
     * @param directives the directives to filter
     * @since 9
     */
    public static List<UsesDirective>
            usesIn(Iterable<? extends Directive> directives) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\lang\model\util\ElementKindVisitor9.java
/**
 * A visitor of program elements based on their {@linkplain
 * ElementKind kind} with default behavior appropriate for the {@link
 * SourceVersion#RELEASE_9 RELEASE_9} source version.  For {@linkplain
 * Element elements} <tt><i>XYZ</i></tt> that may have more than one
 * kind, the <tt>visit<i>XYZ</i></tt> methods in this class delegate
 * to the <tt>visit<i>XYZKind</i></tt> method corresponding to the
 * first argument's kind.  The <tt>visit<i>XYZKind</i></tt> methods
 * call {@link #defaultAction defaultAction}, passing their arguments
 * to {@code defaultAction}'s corresponding parameters.
 *
 * <p> Methods in this class may be overridden subject to their
 * general contract.  Note that annotating methods in concrete
 * subclasses with {@link java.lang.Override @Override} will help
 * ensure that methods are overridden as intended.
 *
 * <p> <b>WARNING:</b> The {@code ElementVisitor} interface
 * implemented by this class may have methods added to it or the
 * {@code ElementKind} {@code enum} used in this case may have
 * constants added to it in the future to accommodate new, currently
 * unknown, language structures added to future versions of the
 * Java&trade; programming language.  Therefore, methods whose names
 * begin with {@code "visit"} may be added to this class in the
 * future; to avoid incompatibilities, classes which extend this class
 * should not declare any instance methods with names beginning with
 * {@code "visit"}.
 *
 * <p>When such a new visit method is added, the default
 * implementation in this class will be to call the {@link
 * #visitUnknown visitUnknown} method.  A new abstract element kind
 * visitor class will also be introduced to correspond to the new
 * language level; this visitor will have different default behavior
 * for the visit method in question.  When the new visitor is
 * introduced, all or portions of this visitor may be deprecated.
 *
 * @param <R> the return type of this visitor's methods.  Use {@link
 *            Void} for visitors that do not need to return results.
 * @param <P> the type of the additional parameter to this visitor's
 *            methods.  Use {@code Void} for visitors that do not need an
 *            additional parameter.
 *
 * @see ElementKindVisitor6
 * @see ElementKindVisitor7
 * @see ElementKindVisitor8
 * @since 9
 */
@SupportedSourceVersion(RELEASE_9)
public class ElementKindVisitor9<R, P> extends ElementKindVisitor8<R, P> {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\lang\model\util\Elements.java
    /**
     * Returns a package given its fully qualified name, as seen from the given module.
     *
     * @param name  fully qualified package name, or an empty string for an unnamed package
     * @param module module relative to which the lookup should happen
     * @return the named package, or {@code null} if it cannot be found
     * @since 9
     */
    PackageElement getPackageElement(ModuleElement module, CharSequence name);

    /**
     * Returns a type element given its canonical name, as seen from the given module.
     *
     * @param name  the canonical name
     * @param module module relative to which the lookup should happen
     * @return the named type element, or {@code null} if it cannot be found
     * @since 9
     */
    TypeElement getTypeElement(ModuleElement module, CharSequence name);

    /**
     * Returns a module element given its fully qualified name.
     *
     * @param name  the name
     * @return the named module element, or {@code null} if it cannot be found
     * @since 9
     */
    ModuleElement getModuleElement(CharSequence name);

    /**
     * Returns the module of an element.  The module of a module is
     * itself.
     *
     * @param type the element being examined
     * @return the module of an element
     * @since 9
     */
    ModuleElement getModuleOf(Element type);

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\lang\model\util\ElementScanner9.java
/**
 * A scanning visitor of program elements with default behavior
 * appropriate for the {@link SourceVersion#RELEASE_9 RELEASE_9}
 * source version.  The <tt>visit<i>XYZ</i></tt> methods in this
 * class scan their component elements by calling {@code scan} on
 * their {@linkplain Element#getEnclosedElements enclosed elements},
 * {@linkplain ExecutableElement#getParameters parameters}, etc., as
 * indicated in the individual method specifications.  A subclass can
 * control the order elements are visited by overriding the
 * <tt>visit<i>XYZ</i></tt> methods.  Note that clients of a scanner
 * may get the desired behavior be invoking {@code v.scan(e, p)} rather
 * than {@code v.visit(e, p)} on the root objects of interest.
 *
 * <p>When a subclass overrides a <tt>visit<i>XYZ</i></tt> method, the
 * new method can cause the enclosed elements to be scanned in the
 * default way by calling <tt>super.visit<i>XYZ</i></tt>.  In this
 * fashion, the concrete visitor can control the ordering of traversal
 * over the component elements with respect to the additional
 * processing; for example, consistently calling
 * <tt>super.visit<i>XYZ</i></tt> at the start of the overridden
 * methods will yield a preorder traversal, etc.  If the component
 * elements should be traversed in some other order, instead of
 * calling <tt>super.visit<i>XYZ</i></tt>, an overriding visit method
 * should call {@code scan} with the elements in the desired order.
 *
 * <p> Methods in this class may be overridden subject to their
 * general contract.  Note that annotating methods in concrete
 * subclasses with {@link java.lang.Override @Override} will help
 * ensure that methods are overridden as intended.
 *
 * <p> <b>WARNING:</b> The {@code ElementVisitor} interface
 * implemented by this class may have methods added to it in the
 * future to accommodate new, currently unknown, language structures
 * added to future versions of the Java&trade; programming language.
 * Therefore, methods whose names begin with {@code "visit"} may be
 * added to this class in the future; to avoid incompatibilities,
 * classes which extend this class should not declare any instance
 * methods with names beginning with {@code "visit"}.
 *
 * <p>When such a new visit method is added, the default
 * implementation in this class will be to call the {@link
 * #visitUnknown visitUnknown} method.  A new element scanner visitor
 * class will also be introduced to correspond to the new language
 * level; this visitor will have different default behavior for the
 * visit method in question.  When the new visitor is introduced, all
 * or portions of this visitor may be deprecated.
 *
 * @param <R> the return type of this visitor's methods.  Use {@link
 *            Void} for visitors that do not need to return results.
 * @param <P> the type of the additional parameter to this visitor's
 *            methods.  Use {@code Void} for visitors that do not need an
 *            additional parameter.
 *
 * @see ElementScanner6
 * @see ElementScanner7
 * @see ElementScanner8
 * @since 9
 */
@SupportedSourceVersion(RELEASE_9)
public class ElementScanner9<R, P> extends ElementScanner8<R, P> {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\lang\model\util\SimpleAnnotationValueVisitor9.java
/**
 * A simple visitor for annotation values with default behavior
 * appropriate for the {@link SourceVersion#RELEASE_9 RELEASE_9}
 * source version.  Visit methods call {@link #defaultAction
 * defaultAction} passing their arguments to {@code defaultAction}'s
 * corresponding parameters.
 *
 * <p> Methods in this class may be overridden subject to their
 * general contract.  Note that annotating methods in concrete
 * subclasses with {@link java.lang.Override @Override} will help
 * ensure that methods are overridden as intended.
 *
 * <p> <b>WARNING:</b> The {@code AnnotationValueVisitor} interface
 * implemented by this class may have methods added to it in the
 * future to accommodate new, currently unknown, language structures
 * added to future versions of the Java&trade; programming language.
 * Therefore, methods whose names begin with {@code "visit"} may be
 * added to this class in the future; to avoid incompatibilities,
 * classes which extend this class should not declare any instance
 * methods with names beginning with {@code "visit"}.
 *
 * <p>When such a new visit method is added, the default
 * implementation in this class will be to call the {@link
 * #visitUnknown visitUnknown} method.  A new simple annotation
 * value visitor class will also be introduced to correspond to the
 * new language level; this visitor will have different default
 * behavior for the visit method in question.  When the new visitor is
 * introduced, all or portions of this visitor may be deprecated.
 *
 * @param <R> the return type of this visitor's methods
 * @param <P> the type of the additional parameter to this visitor's methods.
 *
 * @see SimpleAnnotationValueVisitor6
 * @see SimpleAnnotationValueVisitor7
 * @see SimpleAnnotationValueVisitor8
 * @since 9
 */
@SupportedSourceVersion(RELEASE_9)
public class SimpleAnnotationValueVisitor9<R, P> extends SimpleAnnotationValueVisitor8<R, P> {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\lang\model\util\SimpleElementVisitor9.java
/**
 * A simple visitor of program elements with default behavior
 * appropriate for the {@link SourceVersion#RELEASE_9 RELEASE_9}
 * source version.
 *
 * Visit methods corresponding to {@code RELEASE_9} and earlier
 * language constructs call {@link #defaultAction defaultAction},
 * passing their arguments to {@code defaultAction}'s corresponding
 * parameters.
 *
 * <p> Methods in this class may be overridden subject to their
 * general contract.  Note that annotating methods in concrete
 * subclasses with {@link java.lang.Override @Override} will help
 * ensure that methods are overridden as intended.
 *
 * <p> <b>WARNING:</b> The {@code ElementVisitor} interface
 * implemented by this class may have methods added to it in the
 * future to accommodate new, currently unknown, language structures
 * added to future versions of the Java&trade; programming language.
 * Therefore, methods whose names begin with {@code "visit"} may be
 * added to this class in the future; to avoid incompatibilities,
 * classes which extend this class should not declare any instance
 * methods with names beginning with {@code "visit"}.
 *
 * <p>When such a new visit method is added, the default
 * implementation in this class will be to call the {@link
 * #visitUnknown visitUnknown} method.  A new simple element visitor
 * class will also be introduced to correspond to the new language
 * level; this visitor will have different default behavior for the
 * visit method in question.  When the new visitor is introduced, all
 * or portions of this visitor may be deprecated.
 *
 * @param <R> the return type of this visitor's methods.  Use {@code Void}
 *             for visitors that do not need to return results.
 * @param <P> the type of the additional parameter to this visitor's methods.  Use {@code Void}
 *              for visitors that do not need an additional parameter.
 *
 * @see SimpleElementVisitor6
 * @see SimpleElementVisitor7
 * @see SimpleElementVisitor8
 * @since 9
 */
@SupportedSourceVersion(RELEASE_9)
public class SimpleElementVisitor9<R, P> extends SimpleElementVisitor8<R, P> {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\lang\model\util\TypeKindVisitor9.java
/**
 * A visitor of types based on their {@linkplain TypeKind kind} with
 * default behavior appropriate for the {@link SourceVersion#RELEASE_9
 * RELEASE_9} source version.  For {@linkplain
 * TypeMirror types} <tt><i>XYZ</i></tt> that may have more than one
 * kind, the <tt>visit<i>XYZ</i></tt> methods in this class delegate
 * to the <tt>visit<i>XYZKind</i></tt> method corresponding to the
 * first argument's kind.  The <tt>visit<i>XYZKind</i></tt> methods
 * call {@link #defaultAction defaultAction}, passing their arguments
 * to {@code defaultAction}'s corresponding parameters.
 *
 * <p> Methods in this class may be overridden subject to their
 * general contract.  Note that annotating methods in concrete
 * subclasses with {@link java.lang.Override @Override} will help
 * ensure that methods are overridden as intended.
 *
 * <p> <b>WARNING:</b> The {@code TypeVisitor} interface implemented
 * by this class may have methods added to it in the future to
 * accommodate new, currently unknown, language structures added to
 * future versions of the Java&trade; programming language.
 * Therefore, methods whose names begin with {@code "visit"} may be
 * added to this class in the future; to avoid incompatibilities,
 * classes which extend this class should not declare any instance
 * methods with names beginning with {@code "visit"}.
 *
 * <p>When such a new visit method is added, the default
 * implementation in this class will be to call the {@link
 * #visitUnknown visitUnknown} method.  A new type kind visitor class
 * will also be introduced to correspond to the new language level;
 * this visitor will have different default behavior for the visit
 * method in question.  When the new visitor is introduced, all or
 * portions of this visitor may be deprecated.
 *
 * @param <R> the return type of this visitor's methods.  Use {@link
 *            Void} for visitors that do not need to return results.
 * @param <P> the type of the additional parameter to this visitor's
 *            methods.  Use {@code Void} for visitors that do not need an
 *            additional parameter.
 *
 * @see TypeKindVisitor6
 * @see TypeKindVisitor7
 * @see TypeKindVisitor8
 * @since 9
 */
@SupportedSourceVersion(RELEASE_9)
public class TypeKindVisitor9<R, P> extends TypeKindVisitor8<R, P> {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\management\ConstructorParameters.java
/**
 * <p>
 * An annotation on a constructor that shows how the parameters of
 * that constructor correspond to the constructed object's getter
 * methods.  For example:
 * </p>
 * <blockquote>
 *     <pre>
 *         public class MemoryUsage {
 *             // standard JavaBean conventions with getters
 *             <b>@ConstructorParameters({"init", "used", "committed", "max"})</b>
 *             public MemoryUsage(long init, long used,
 *                                long committed, long max) {...}
 *             public long getInit() {...}
 *             public long getUsed() {...}
 *             public long getCommitted() {...}
 *             public long getMax() {...}
 *         }
 *     </pre>
 * </blockquote>
 * <p>
 * The annotation shows that the first parameter of the constructor
 * can be retrieved with the {@code getInit()} method, the second one with
 * the {@code getUsed()} method, and so on. Since parameter names are not in
 * general available at runtime, without the annotation there would be
 * no way of knowing which parameter corresponds to which property.
 * </p>
 * <p>
 * If a constructor is annotated by the both {@code @java.beans.ConstructorProperties}
 * and {@code @javax.management.ConstructorParameters} annotations
 * the JMX introspection will give an absolute precedence to the latter one.
 * </p>
 *
 * @since 9
 */
@Documented @Target(CONSTRUCTOR) @Retention(RUNTIME)
public @interface ConstructorParameters {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\security\auth\kerberos\EncryptionKey.java
/**
 * This class encapsulates an EncryptionKey used in Kerberos.<p>
 *
 * An EncryptionKey is defined in Section 4.2.9 of the Kerberos Protocol
 * Specification (<a href=http://www.ietf.org/rfc/rfc4120.txt>RFC 4120</a>) as:
 * <pre>
 *     EncryptionKey   ::= SEQUENCE {
 *             keytype         [0] Int32 -- actually encryption type --,
 *             keyvalue        [1] OCTET STRING
 *     }
 * </pre>
 * The key material of an {@code EncryptionKey} is defined as the value
 * of the {@code keyValue} above.
 *
 * @since 9
 */
public final class EncryptionKey implements SecretKey {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\security\auth\kerberos\KerberosCredMessage.java
/**
 * This class encapsulates a Kerberos 5 KRB_CRED message which can be used to
 * send Kerberos credentials from one principal to another.<p>
 *
 * A KRB_CRED message is defined in Section 5.8.1 of the Kerberos Protocol
 * Specification (<a href=http://www.ietf.org/rfc/rfc4120.txt>RFC 4120</a>) as:
 * <pre>
 *    KRB-CRED        ::= [APPLICATION 22] SEQUENCE {
 *            pvno            [0] INTEGER (5),
 *            msg-type        [1] INTEGER (22),
 *            tickets         [2] SEQUENCE OF Ticket,
 *            enc-part        [3] EncryptedData -- EncKrbCredPart
 *    }
 * </pre>
 *
 * @since 9
 */
public final class KerberosCredMessage implements Destroyable {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\sql\CommonDataSource.java
    /**
     * Creates a new {@code ShardingKeyBuilder} instance
     * @implSpec
     * The default implementation will throw a {@code SQLFeatureNotSupportedException}.
     * @return The ShardingKeyBuilder instance that was created
     * @throws SQLException if an error occurs creating the builder
     * @throws SQLFeatureNotSupportedException if the driver does not support this method
     * @since 9
     * @see ShardingKeyBuilder
    */
    default ShardingKeyBuilder createShardingKeyBuilder() throws SQLException {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\sql\ConnectionPoolDataSource.java
  /**
   * Creates a new {@code PooledConnectionBuilder} instance
   * @implSpec
   * The default implementation will throw a {@code SQLFeatureNotSupportedException}.
   * @return The ConnectionBuilder instance that was created
   * @throws SQLException if an error occurs creating the builder
   * @throws SQLFeatureNotSupportedException if the driver does not support sharding
   * @since 9
   * @see PooledConnectionBuilder
   */
  default PooledConnectionBuilder createPooledConnectionBuilder() throws SQLException {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\sql\DataSource.java
  /**
   * Create a new {@code ConnectionBuilder} instance
   * @implSpec
   * The default implementation will throw a {@code SQLFeatureNotSupportedException}
   * @return The ConnectionBuilder instance that was created
   * @throws SQLException if an error occurs creating the builder
   * @throws SQLFeatureNotSupportedException if the driver does not support sharding
   * @since 9
   * @see ConnectionBuilder
   */
  default ConnectionBuilder createConnectionBuilder() throws SQLException {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\sql\PooledConnectionBuilder.java
/**
 * A builder created from a {@code ConnectionPoolDataSource} object,
 * used to establish a connection to the database that the
 * {@code data source} object represents.  The connection
 * properties that were specified for the {@code data source} are used as the
 * default values by the {@code PooledConnectionBuilder}.
 * <p>The following example illustrates the use of {@code PooledConnectionBuilder}
 * to create a {@link XAConnection}:
 *
 * <pre>{@code
 *     ConnectionPoolDataSource ds = new MyConnectionPoolDataSource();
 *     ShardingKey superShardingKey = ds.createShardingKeyBuilder()
 *                           .subkey("EASTERN_REGION", JDBCType.VARCHAR)
 *                           .build();
 *     ShardingKey shardingKey = ds.createShardingKeyBuilder()
 *                           .subkey("PITTSBURGH_BRANCH", JDBCType.VARCHAR)
 *                           .build();
 *     PooledConnection con = ds.createPooledConnectionBuilder()
 *                       .user("rafa")
 *                       .password("tennis")
 *                       .setShardingKey(shardingKey)
 *                       .setSuperShardingKey(superShardingKey)
 *                       .build();
 * }</pre>
 *
 * @since 9
 *
 */
public interface PooledConnectionBuilder  {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\sql\XAConnectionBuilder.java
/**
 * A builder created from a {@code XADataSource} object,
 * used to establish a connection to the database that the
 * {@code data source} object represents.  The connection
 * properties that were specified for the {@code data source} are used as the
 * default values by the {@code XAConnectionBuilder}.
 * <p>The following example illustrates the use of {@code XAConnectionBuilder}
 * to create a {@link XAConnection}:
 *
 * <pre>{@code
 *     XADataSource ds = new MyXADataSource();
 *     ShardingKey superShardingKey = ds.createShardingKeyBuilder()
 *                           .subkey("EASTERN_REGION", JDBCType.VARCHAR)
 *                           .build();
 *     ShardingKey shardingKey = ds.createShardingKeyBuilder()
 *                           .subkey("PITTSBURGH_BRANCH", JDBCType.VARCHAR)
 *                           .build();
 *     XAConnection con = ds.createXAConnectionBuilder()
 *                       .user("rafa")
 *                       .password("tennis")
 *                       .setShardingKey(shardingKey)
 *                       .setSuperShardingKey(superShardingKey)
 *                       .build();
 * }</pre>
 *
 * @since 9
 *
 */
public interface XAConnectionBuilder  {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\sql\XADataSource.java
  /**
   * Creates a new {@code XAConnectionBuilder} instance
   * @implSpec
   * The default implementation will throw a {@code SQLFeatureNotSupportedException}.
   * @return The XAConnectionBuilder instance that was created
   * @throws SQLException if an error occurs creating the builder
   * @throws SQLFeatureNotSupportedException if the driver does not support sharding
   * @since 9
   * @see XAConnectionBuilder
   */
  default XAConnectionBuilder createXAConnectionBuilder() throws SQLException {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\swing\filechooser\FileSystemView.java
    /**
     * Returns an array of files representing the values to show by default in
     * the file chooser selector.
     *
     * @return an array of {@code File} objects.
     * @throws SecurityException if the caller does not have necessary
     *                           permissions
     * @since 9
     */
    public File[] getChooserComboBoxFiles() {

    /**
     * Returns whether the specified file denotes a shell interpreted link which
     * can be obtained by the {@link #getLinkLocation(File)}.
     *
     * @param file a file
     * @return whether this is a link
     * @throws NullPointerException if {@code file} equals {@code null}
     * @throws SecurityException if the caller does not have necessary
     *                           permissions
     * @see #getLinkLocation(File)
     * @since 9
     */
    public boolean isLink(File file) {

    /**
     * Returns the regular file referenced by the specified link file if
     * the specified file is a shell interpreted link.
     * Returns {@code null} if the specified file is not
     * a shell interpreted link.
     *
     * @param file a file
     * @return the linked file or {@code null}.
     * @throws FileNotFoundException if the linked file does not exist
     * @throws NullPointerException if {@code file} equals {@code null}
     * @throws SecurityException if the caller does not have necessary
     *                           permissions
     * @since 9
     */
    public File getLinkLocation(File file) throws FileNotFoundException {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\swing\InputVerifier.java
    /**
     * Checks whether the target JComponent that will be receiving the focus
     * is ready to accept it. This method should be over-ridden only if it is
     * necessary to validate the target of the focus transfer.
     * This method should have no side effects. It returns a boolean
     * indicating the status of the argument's input.
     *
     * @implSpec By default this method returns {@code true}.
     *
     * @param target the target JComponent to verify
     * @return {@code true} when valid, {@code false} when invalid
     * @see JComponent#setInputVerifier
     * @see JComponent#getInputVerifier
     * @since 9
     */
    public boolean verifyTarget(JComponent target) {

    /**
     * Is called by Swing if this {@code InputVerifier} is assigned to the
     * {@code source} Swing component to check whether the requested focus
     * transfer from the {@code source} to {@code target} is allowed.
     * This method can have side effects.
     * If this method returns {@code true}, then the focus is transferred
     * normally; if it returns {@code false}, then the focus remains in
     * the first argument component.
     *
     * @implSpec The basic implementation of this method returns the conjunction
     * of results obtained from {@code verify(input)} and
     * {@code verifyTarget(input)} to ensure that both the source and the target
     * components are in valid state.
     *
     * @param source the source JComponent of the focus transfer
     * @param target the target JComponent of the focus transfer
     * @return {@code true} when valid, {@code false} when invalid
     * @see JComponent#setInputVerifier
     * @see JComponent#getInputVerifier
     * @since 9
     */
    public boolean shouldYieldFocus(JComponent source, JComponent target) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\swing\JComponent.java
    /**
     * Returns the look and feel delegate that renders this component.
     *
     * @return the {@code ComponentUI} object that renders this component
     * @since 9
     */
    @Transient
    public ComponentUI getUI() {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\swing\JList.java
            /**
             * {@inheritDoc}
             * @implSpec Returns the AccessibleAction for this AccessibleJListChild
             * as follows:  First getListCellRendererComponent of the ListCellRenderer
             * for the component at the "index in parent" of this child is called.
             * Then its AccessibleContext is fetched and that AccessibleContext's
             * AccessibleAction is returned.  Note that if an AccessibleAction
             * is not found using this process then this object with its implementation
             * of the AccessibleAction interface is returned.
             * @since 9
             */
            @Override
            public AccessibleAction getAccessibleAction() {

            /**
             * {@inheritDoc}
             * @implSpec If i == 0 selects this AccessibleJListChild by calling
             * JList.this.setSelectedIndex(indexInParent) and then returns true;
             * otherwise returns false.
             * @since 9
             */
            @Override
            public boolean doAccessibleAction(int i) {

            /**
             * {@inheritDoc}
             * @implSpec If i == 0 returns the action description fetched from
             * UIManager.getString("AbstractButton.clickText");
             * otherwise returns null.
             * @since 9
             */
            @Override
            public String getAccessibleActionDescription(int i) {

            /**
             * {@inheritDoc}
             * @implSpec Returns 1, i.e. there is only one action.
             * @since 9
             */
            @Override
            public int getAccessibleActionCount() {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\swing\plaf\basic\BasicGraphicsUtils.java
    /**
     * Draws the given string at the specified location using text properties
     * and anti-aliasing hints from the provided component.
     * Nothing is drawn for the null string.
     *
     * @param c the component that will display the string, may be null
     * @param g the graphics context, must not be null
     * @param string the string to display, may be null
     * @param x the x coordinate to draw the text at
     * @param y the y coordinate to draw the text at
     * @throws NullPointerException if the specified {@code g} is {@code null}
     *
     * @since 9
     */
    public static void drawString(JComponent c, Graphics2D g, String string,
                                  float x, float y) {

    /**
     * Draws the given string at the specified location underlining
     * the specified character. The provided component is used to query text
     * properties and anti-aliasing hints.
     * <p>
     * The {@code underlinedIndex} parameter points to a char value
     * (Unicode code unit) in the given string.
     * If the char value specified at the underlined index is in
     * the high-surrogate range and the char value at the following index is in
     * the low-surrogate range then the supplementary character corresponding
     * to this surrogate pair is underlined.
     * <p>
     * No character is underlined if the index is negative or greater
     * than the string length {@code (index < 0 || index >= string.length())}
     * or if the char value specified at the given index
     * is in the low-surrogate range.
     *
     * @param c the component that will display the string, may be null
     * @param g the graphics context, must not be null
     * @param string the string to display, may be null
     * @param underlinedIndex index of a a char value (Unicode code unit)
     *        in the string to underline
     * @param x the x coordinate to draw the text at
     * @param y the y coordinate to draw the text at
     * @throws NullPointerException if the specified {@code g} is {@code null}
     *
     * @see #getStringWidth
     *
     * @since 9
     */
    public static void drawStringUnderlineCharAt(JComponent c, Graphics2D g,
            String string, int underlinedIndex, float x, float y) {

    /**
     * Clips the passed in string to the space provided.
     * The provided component is used to query text properties and anti-aliasing hints.
     * The unchanged string is returned if the space provided is greater than
     * the string width.
     *
     * @param c the component, may be null
     * @param fm the FontMetrics used to measure the string width, must be
     *           obtained from the correct font and graphics. Must not be null.
     * @param string the string to clip, may be null
     * @param availTextWidth the amount of space that the string can be drawn in
     * @return the clipped string that fits in the provided space, an empty
     *         string if the given string argument is {@code null} or empty
     * @throws NullPointerException if the specified {@code fm} is {@code null}
     *
     * @see #getStringWidth
     *
     * @since 9
     */
    public static String getClippedString(JComponent c, FontMetrics fm,
                                          String string, int availTextWidth) {

    /**
     * Returns the width of the passed in string using text properties
     * and anti-aliasing hints from the provided component.
     * If the passed string is {@code null}, returns zero.
     *
     * @param c the component, may be null
     * @param fm the FontMetrics used to measure the advance string width, must
     *           be obtained from the correct font and graphics. Must not be null.
     * @param string the string to get the advance width of, may be null
     * @return the advance width of the specified string, zero is returned for
     *         {@code null} string
     * @throws NullPointerException if the specified {@code fm} is {@code null}
     *
     * @since 9
     */
    public static float getStringWidth(JComponent c, FontMetrics fm, String string) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\swing\plaf\TextUI.java
    /**
     * Converts the given location in the model to a place in
     * the view coordinate system.
     *
     * @implSpec This implementation calls
     * {@link #modelToView(JTextComponent, int, Position.Bias) modelToView(t, pos, bias)}.
     *
     * @param t the text component for which this UI is installed
     * @param pos  the local location in the model to translate {@code >= 0}
     * @param bias the bias for the position
     * @return the coordinates as a {@code Rectangle2D}
     * @exception BadLocationException  if the given position does not
     *            represent a valid location in the associated document
     *
     * @since 9
     */
    public Rectangle2D modelToView2D(JTextComponent t, int pos, Position.Bias bias)
            throws BadLocationException {

    /**
     * Provides a mapping from the view coordinate space to the logical
     * coordinate space of the model.
     *
     * @implSpec This implementation calls
     * {@link #viewToModel(JTextComponent, Point, Position.Bias[])
     * viewToModel(t, new Point((int) pt.getX(), (int) pt.getY()),
     *             biasReturn)}.
     *
     * @param t the text component for which this UI is installed
     * @param pt the location in the view to translate.
     * @param biasReturn
     *           filled in by this method to indicate whether
     *           the point given is closer to the previous or the next
     *           character in the model
     *
     * @return the location within the model that best represents the
     *         given point in the view {@code >= 0}
     *
     * @since 9
     */
    public int viewToModel2D(JTextComponent t, Point2D pt,
                             Position.Bias[] biasReturn) {

    /**
     * Returns the string to be used as the tooltip at the passed in location.
     *
     * @implSpec This implementation calls
     * {@link #getToolTipText(JTextComponent, Point)
     *     getToolTipText(t, new Point((int) pt.getX(), (int) pt.getY())))}.
     *
     * @param t  the text component for which this UI is installed
     * @param pt a {@code Point} specifying location for which to get a tooltip
     * @return a {@code String} containing the tooltip
     *
     * @see javax.swing.text.JTextComponent#getToolTipText
     *
     * @since 9
     */
    public String getToolTipText2D(JTextComponent t, Point2D pt) {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\swing\SwingContainer.java
/**
 * An annotation used to specify some swing-related information
 * for the automatically generated {@code BeanInfo} classes.
 * This annotation is not used if the annotated class
 * has a corresponding user-defined {@code BeanInfo} class,
 * which does not imply the automatic analysis.
 * <p>
 * The {@code isContainer} {@link java.beans.BeanDescriptor#getValue
 * feature attribute} was introduced primarily for the Swing library.
 * All Swing components extend the {@link java.awt.Container Container}
 * class by design, so the builder tool assumes that all Swing components
 * are containers.  The {@link java.beans.BeanInfo BeanInfo} classes
 * with the {@code isContainer} attribute allow to directly specify
 * whether a Swing component is a container or not.
 *
 * @since 9
 *
 * @author Sergey A. Malenkov
 */
@Target({TYPE})
@Retention(RUNTIME)
public @interface SwingContainer {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\swing\text\AbstractDocument.java
        /**
         * {@inheritDoc}
         * @since 9
         */
        @Override
        public void lockEdit() {

        /**
         * {@inheritDoc}
         * @since 9
         */
        @Override
        public void unlockEdit() {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\swing\UIClientPropertyKey.java
/**
 * This interface is used only for tagging keys for client properties for
 * {@code JComponent} set by UI which needs to be cleared on {@literal L&F}
 * change and serialization.
 * <p>
 * All such keys are removed from client properties in
 * {@code JComponent.setUI()} method after uninstalling old UI and before
 * installing the new one. They are also removed prior to serialization.
 *
 * @author Igor Kushnirskiy
 * @since 9
 */
public interface UIClientPropertyKey {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\swing\UIManager.java
    /**
     * Creates a supported built-in Java {@code LookAndFeel} specified
     * by the given {@code L&F name} name.
     *
     * @param name a {@code String} specifying the name of the built-in
     *             look and feel
     * @return the built-in {@code LookAndFeel} object
     * @throws NullPointerException if {@code name} is {@code null}
     * @throws UnsupportedLookAndFeelException if the built-in Java {@code L&F}
     *         is not found for the given name or it is not supported by the
     *         underlying platform
     *
     * @see LookAndFeel#getName
     * @see LookAndFeel#isSupportedLookAndFeel
     *
     * @since 9
     */
    public static LookAndFeel createLookAndFeel(String name)
            throws UnsupportedLookAndFeelException {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\tools\FileManagerUtils.java
/**
 * Package-private utility methods to convert between files and paths.
 *
 * @since 9
 */
class FileManagerUtils {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\tools\JavaFileManager.java
        /**
         * Indicates if this location is expected to contain modules,
         * as compared to a location which contains packages and classes.
         *
         * @return true if this location is expected to contain modules
         * @since 9
         */
        default boolean isModuleLocation() {

    /**
     * Gets a location for a named module within a module-oriented location.
     *
     * @param location the module-oriented location
     * @param moduleName the name of the module to be found
     * @return the location for the named module
     *
     * @throws IOException if an I/O error occurred
     * @throws UnsupportedOperationException if this operation if not supported by this file manager
     * @since 9
     */ // TODO: describe failure modes
    default Location getModuleLocation(Location location, String moduleName) throws IOException {

    /**
     * Gets a location for the module containing a specific file representing a Java
     * source or class.
     *
     * @param location a module-oriented location
     * @param fo the file
     * @param pkgName the package name for the class(es) defined in this file
     * @return the module containing the file
     *
     * @throws IOException if an I/O error occurred
     * @throws UnsupportedOperationException if this operation if not supported by this file manager
     * @since 9
     */ // TODO: describe failure modes
    default Location getModuleLocation(Location location, JavaFileObject fo, String pkgName) throws IOException {

    /**
     * Get a service loader for a specific service class from a given location.
     *
     * @param location the location
     * @param service  the {@code Class} object of the service class
     * @param <S> the service class
     * @return a service loader for the given service class
     *
     * @throws IOException if an I/O error occurred
     * @throws UnsupportedOperationException if this operation if not supported by this file manager
     * @since 9
     */ // TODO: describe failure modes
    default <S> ServiceLoader<S> getServiceLoader(Location location, Class<S> service) throws  IOException {

    /**
     * Infer the name of the module from its location, as returned by
     * getModuleLocation or listModuleLocations.
     *
     * @param location a location representing a module
     * @return the name of the module
     *
     * @throws IOException if an I/O error occurred
     * @throws UnsupportedOperationException if this operation if not supported by this file manager
     * @since 9
     */ // TODO: describe failure modes
    default String inferModuleName(Location location) throws IOException {

    /**
     * Lists the modules in a module-oriented location.
     *
     * @param location  the location for which to list the modules
     * @return  a series of sets of locations containing modules
     *
     * @throws IOException if an I/O error occurred
     * @throws UnsupportedOperationException if this operation if not supported by this file manager
     * @since 9
     */ // TODO: describe failure modes
    default Iterable<Set<Location>> listModuleLocations(Location location) throws IOException {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\tools\StandardJavaFileManager.java
    /**
     * Returns file objects representing the given paths.
     *
     * @implSpec
     * The default implementation converts each path to a file and calls
     * {@link #getJavaFileObjectsFromFiles getJavaObjectsFromFiles}.
     * IllegalArgumentException will be thrown if any of the paths
     * cannot be converted to a file.
     *
     * @param paths a list of paths
     * @return a list of file objects
     * @throws IllegalArgumentException if the list of paths includes
     * a directory or if this file manager does not support any of the
     * given paths.
     *
     * @since 9
     */
    default Iterable<? extends JavaFileObject> getJavaFileObjectsFromPaths(
            Iterable<? extends Path> paths) {

    /**
     * Returns file objects representing the given paths.
     * Convenience method equivalent to:
     *
     * <pre>
     *     getJavaFileObjectsFromPaths({@linkplain java.util.Arrays#asList Arrays.asList}(paths))
     * </pre>
     *
     * @param paths an array of paths
     * @return a list of file objects
     * @throws IllegalArgumentException if the array of files includes
     * a directory
     * @throws NullPointerException if the given array contains null
     * elements
     *
     * @since 9
     */
    default Iterable<? extends JavaFileObject> getJavaFileObjects(Path... paths) {

    /**
     * Associates the given search path with the given location.  Any
     * previous value will be discarded.
     *
     * @apiNote
     * The type of the {@code paths} parameter is a {@code Collection}
     * and not {@code Iterable}. This is to prevent the possibility of
     * accidentally calling the method with a single {@code Path} as
     * the second argument, because although {@code Path} implements
     * {@code Iterable<Path>}, it would almost never be correct to call
     * this method with a single {@code Path} and have it be treated as
     * an {@code Iterable} of its components.
     *
     *
     * @implSpec
     * The default implementation converts each path to a file and calls
     * {@link #getJavaFileObjectsFromFiles getJavaObjectsFromFiles}.
     * IllegalArgumentException will be thrown if any of the paths
     * cannot be converted to a file.
     *
     * @param location a location
     * @param paths a list of paths, if {@code null} use the default
     * search path for this location
     * @see #getLocation
     * @throws IllegalArgumentException if {@code location} is an output
     * location and {@code paths} does not contain exactly one element
     * or if this file manager does not support any of the given paths
     * @throws IOException if {@code location} is an output location and
     * {@code paths} does not represent an existing directory
     *
     * @since 9
     */
    default void setLocationFromPaths(Location location, Collection<? extends Path> paths)
            throws IOException {

    /**
     * Returns the search path associated with the given location.
     *
     * @implSpec
     * The default implementation calls {@link #getLocation getLocation}
     * and then returns an {@code Iterable} formed by calling {@code toPath()}
     * on each {@code File} returned from {@code getLocation}.
     *
     * @param location a location
     * @return a list of paths or {@code null} if this location has no
     * associated search path
     *
     * @see #setLocationFromPaths
     * @since 9
     */
    default Iterable<? extends Path> getLocationAsPaths(Location location) {

    /**
     * Returns the path, if any, underlying this file object (optional operation).
     * File objects derived from a {@link java.nio.file.FileSystem FileSystem},
     * including the default file system, typically have a corresponding underlying
     * {@link java.nio.file.Path Path} object. In such cases, this method may be
     * used to access that object.
     *
     * @implSpec
     * The default implementation throws {@link UnsupportedOperationException}
     * for all files.
     *
     * @param file a file object
     * @return a path representing the same underlying file system artifact
     * @throws IllegalArgumentException if the file object does not have an underlying path
     * @throws UnsupportedOperationException if the operation is not supported by this file manager
     *
     * @since 9
     */
    default Path asPath(FileObject file) {

    /**
     * Factory to create {@code Path} objects from strings.
     *
     * @since 9
     */
    interface PathFactory {

     /**
      * Specify a factory that can be used to generate a path from a string, or series of strings.
      *
      * If this method is not called, a factory whose {@code getPath} method is
      * equivalent to calling
      * {@link java.nio.file.Paths#get(String, String...) java.nio.file.Paths.get(first, more)}
      * will be used.
      *
      * @implSpec
      * The default implementation of this method ignores the factory that is provided.
      *
      * @param f  the factory
      *
      * @since 9

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\tools\StandardLocation.java
    /**
     * Location to search for modules containing annotation processors.
     * @since 9
     */
    ANNOTATION_PROCESSOR_MODULE_PATH,

    /**
     * Location to search for platform classes.  Sometimes called
     * the boot class path.
     */
    PLATFORM_CLASS_PATH,

    /**
     * Location of new native header files.
     * @since 1.8
     */
    NATIVE_HEADER_OUTPUT,

    /**
     * Location to search for the source code of modules.
     * @since 9
     */
    MODULE_SOURCE_PATH,

    /**
     * Location to search for upgradeable system modules.
     * @since 9
     */
    UPGRADE_MODULE_PATH,

    /**
     * Location to search for system modules.
     * @since 9
     */
    SYSTEM_MODULES,

    /**
     * Location to search for precompiled user modules.
     * @since 9
     */
    MODULE_PATH;

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\xml\bind\JAXBContextFactory.java
/**
 * <p>Factory that creates new <code>JAXBContext</code> instances.
 *
 * JAXBContextFactory can be located using {@link java.util.ServiceLoader#load(Class)}
 *
 * @since 9, JAXB 2.3
 */
public interface JAXBContextFactory {

    /**
     * <p>
     * Create a new instance of a {@code JAXBContext} class.
     *
     * <p>
     * For semantics see {@link javax.xml.bind.JAXBContext#newInstance(Class[], java.util.Map)}
     *
     * @param classesToBeBound
     *      list of java classes to be recognized by the new {@link JAXBContext}.
     *      Can be empty, in which case a {@link JAXBContext} that only knows about
     *      spec-defined classes will be returned.
     * @param properties
     *      provider-specific properties. Can be null, which means the same thing as passing
     *      in an empty map.
     *
     * @return
     *      A new instance of a {@code JAXBContext}.
     *
     * @throws JAXBException
     *      if an error was encountered while creating the
     *      {@code JAXBContext}. See {@link JAXBContext#newInstance(Class[], Map)} for details.
     *
     * @throws IllegalArgumentException
     *      if the parameter contains {@code null} (i.e., {@code newInstance(null,someMap);})
     *
     * @since 9, JAXB 2.3
     */
    JAXBContext createContext(Class<?>[] classesToBeBound,
                              Map<String, ?> properties ) throws JAXBException;

    /**
     * <p>
     * Create a new instance of a {@code JAXBContext} class.
     *
     * <p>
     * For semantics see {@link javax.xml.bind.JAXBContext#newInstance(String, ClassLoader, java.util.Map)}
     *
     * <p>
     * The interpretation of properties is up to implementations. Implementations must
     * throw {@code JAXBException} if it finds properties that it doesn't understand.
     *
     * @param contextPath list of java package names that contain schema derived classes
     * @param classLoader
     *      This class loader will be used to locate the implementation classes.
     * @param properties
     *      provider-specific properties. Can be null, which means the same thing as passing
     *      in an empty map.
     *
     * @return a new instance of a {@code JAXBContext}
     * @throws JAXBException if an error was encountered while creating the
     *      {@code JAXBContext}. See {@link JAXBContext#newInstance(String, ClassLoader, Map)} for details.
     *
     * @since 9, JAXB 2.3
     */
    JAXBContext createContext(String contextPath,
                              ClassLoader classLoader,
                              Map<String, ?> properties ) throws JAXBException;

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\xml\catalog\AltCatalog.java
/**
 * Represents an alternative catalog entry.
 *
 * @since 9
 */
class AltCatalog extends BaseEntry {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\xml\catalog\BaseEntry.java
/**
 * Represents a general Catalog entry.
 *
 * @since 9
 */
abstract class BaseEntry {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\xml\catalog\Catalog.java
/**
 * The Catalog class represents an entity Catalog as defined by
 * <a
 * href="https://www.oasis-open.org/committees/download.php/14809/xml-catalogs.html">
 * XML Catalogs, OASIS Standard V1.1, 7 October 2005</a>.
 * <p>
 * A catalog is an XML file that contains a root {@code catalog} entry with a list
 * of catalog entries. The entries can also be grouped with a {@code group} entry.
 * The catalog and group entries may specify {@code prefer} and {@code xml:base}
 * attributes that set preference of public or system type of entries and base URI
 * to resolve relative URIs.
 *
 * <p>
 * A catalog can be used in two situations:
 * <ul>
 * <li>Locate the external resources with a public or system identifier;
 * </li>
 * <li>Locate an alternate URI reference with an URI.
 * </li>
 * </ul>
 * <p>
 * For case 1, the standard defines 6 External Identifier Entries:<br>
 * {@code public, system, rewriteSystem, systemSuffix, delegatePublic, and
 * delegateSystem}.
 * <p>
 * While for case 2, it defines 4 URI Entries:<br>
 * {@code uri, rewriteURI, uriSuffix and delegateURI}.
 * <p>
 * In addition to the above entry types, a catalog may define nextCatalog
 * entries to add additional catalog entry files.
 * <p>
 *
 * @since 9
 */
public interface Catalog {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\xml\catalog\CatalogEntry.java
/**
 * Represents the catalog element or entry of a catalog file
 *
 * @since 9
 */
class CatalogEntry extends GroupEntry {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\xml\catalog\CatalogException.java
/**
 * The exception class handles errors that may happen while processing or using
 * a catalog.
 *
 * @since 9
 */
public class CatalogException extends RuntimeException {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\xml\catalog\CatalogFeatures.java
/**
 * The CatalogFeatures holds a collection of features and properties.
 * <p>
 *
 * <center><h2><a name="CatalogFeatures">Catalog Features</a></h2></center></p>
 *
 * <table border="1">
 * <thead>
 * <tr>
 * <th rowspan="2">Feature</th>
 * <th rowspan="2">Description</th>
 * <th rowspan="2">Property Name</th>
 * <th rowspan="2">System Property [1]</th>
 * <th rowspan="2">jaxp.properties [1]</th>
 * <th colspan="2" align="center">Value [2]</th>
 * <th rowspan="2">Action</th>
 * </tr>
 * <tr>
 * <th>Type</th>
 * <th>Value</th>
 * </tr>
 * </thead>
 * <tbody>
 *
 * <tr>
 * <td><a name="FILES">FILES</a></td>
 * <td>A semicolon-delimited list of catalog files. Relative file paths are
 * considered relative to ${user.dir}.
 * </td>
 * <td>javax.xml.catalog.files</td>
 * <td>javax.xml.catalog.files</td>
 * <td>javax.xml.catalog.files</td>
 * <td>String</td>
 * <td>File paths</td>
 * <td>
 * Reads the first catalog as the current catalog; Loads others if no match
 * is found in the current catalog including delegate catalogs if any.
 * </td>
 * </tr>
 *
 * <tr>
 * <td rowspan="2"><a name="PREFER">PREFER</a></td>
 * <td rowspan="2">Indicates the preference between the public and system
 * identifiers. The default value is public [3].</td>
 * <td rowspan="2">javax.xml.catalog.prefer</td>
 * <td rowspan="2">N/A</td>
 * <td rowspan="2">N/A</td>
 * <td rowspan="2">String</td>
 * <td>{@code system}</td>
 * <td>Searches system entries for a match; Searches public entries when
 * external identifier specifies only a public identifier</td>
 * </tr>
 * <tr>
 * <td>{@code public}</td>
 * <td>Searches system entries for a match; Searches public entries when
 * there is no matching system entry.</td>
 * </tr>
 *
 * <tr>
 * <td rowspan="2"><a name="DEFER">DEFER</a></td>
 * <td rowspan="2">Indicates that the alternative catalogs including those
 * specified in delegate entries or nextCatalog are not read until they are
 * needed. The default value is true.</td>
 * <td rowspan="2">javax.xml.catalog.defer [4]</td>
 * <td rowspan="2">javax.xml.catalog.defer</td>
 * <td rowspan="2">javax.xml.catalog.defer</td>
 * <td rowspan="2">String</td>
 * <td>{@code true}</td>
 * <td>Loads alternative catalogs as needed.
 * </td>
 * </tr>
 * <tr>
 * <td>{@code false}</td>
 * <td>Loads all catalogs[5]. </td>
 * </tr>
 *
 * <tr>
 * <td rowspan="3"><a name="RESOLVE">RESOLVE</a></td>
 * <td rowspan="3">Determines the action if there is no matching entry found after
 * all of the specified catalogs are exhausted. The default is strict.</td>
 * <td rowspan="3">javax.xml.catalog.resolve [4]</td>
 * <td rowspan="3">javax.xml.catalog.resolve</td>
 * <td rowspan="3">javax.xml.catalog.resolve</td>
 * <td rowspan="3">String</td>
 * <td>{@code strict}</td>
 * <td>Throws CatalogException if there is no match.
 * </td>
 * </tr>
 * <tr>
 * <td>{@code continue}</td>
 * <td>Allows the XML parser to continue as if there is no match.
 * </td>
 * </tr>
 * <tr>
 * <td>{@code ignore}</td>
 * <td>Tells the XML parser to skip the external references if there no match.
 * </td>
 * </tr>
 *
 * </tbody>
 * </table>
 * <p>
 * <b>[1]</b> There is no System property for the features that marked as "N/A".
 *
 * <p>
 * <b>[2]</b> The value shall be exactly as listed in this table, case-sensitive.
 * Any unspecified value will result in {@link IllegalArgumentException}.
 * <p>
 * <b>[3]</b> The Catalog specification defined complex rules on
 * <a href="https://www.oasis-open.org/committees/download.php/14809/xml-catalogs.html#attrib.prefer">
 * the prefer attribute</a>. Although the prefer can be public or system, the
 * specification actually made system the preferred option, that is, no matter
 * the option, a system entry is always used if found. Public entries are only
 * considered if the prefer is public and system entries are not found. It is
 * therefore recommended that the prefer attribute be set as public
 * (which is the default).
 * <p>
 * <b>[4]</b> Although non-standard attributes in the OASIS Catalog specification,
 * {@code defer} and {@code resolve} are recognized by the Java Catalog API the
 * same as the {@code prefer} as being an attribute in the catalog entry of the
 * main catalog. Note that only the attributes specified for the catalog entry
 * of the main Catalog file will be used.
  * <p>
 * <b>[5]</b> If the intention is to share an entire catalog store, it may be desirable to
 * set the property {@code javax.xml.catalog.defer} to false to allow the entire
 * catalog to be pre-loaded.
 * <p>
 * <h3>Scope and Order</h3>
 * Features and properties can be set through the catalog file, the Catalog API,
 * system properties, and {@code jaxp.properties}, with a preference in the same order.
 * <p>
 * Properties that are specified as attributes in the catalog file for the
 * catalog and group entries shall take preference over any of the other settings.
 * For example, if a {@code prefer} attribute is set in the catalog file as in
 * {@code <catalog prefer="public">}, any other input for the "prefer" property
 * is not necessary or will be ignored.
 * <p>
 * Properties set through the Catalog API override those that may have been set
 * by system properties and/or in {@code jaxp.properties}. In case of multiple
 * interfaces, the latest in a procedure shall take preference. For
 * {@link Feature#FILES}, this means that the path(s) specified through the methods
 * of the {@link CatalogManager} will override any that may have been entered
 * through the {@link Builder}.
 *
 * <p>
 * System properties when set shall override those in {@code jaxp.properties}.
 * <p>
 * The {@code jaxp.properties} file is typically in the conf directory of the Java
 * installation. The file is read only once by the JAXP implementation and
 * its values are then cached for future use. If the file does not exist
 * when the first attempt is made to read from it, no further attempts are
 * made to check for its existence. It is not possible to change the value
 * of any properties in {@code jaxp.properties} after it has been read.
 * <p>
 * A CatalogFeatures instance can be created through its builder as illustrated
 * in the following sample code:
 * <pre>{@code
                CatalogFeatures f = CatalogFeatures.builder()
                        .with(Feature.FILES, "catalog.xml")
                        .with(Feature.PREFER, "public")
                        .with(Feature.DEFER, "true")
                        .with(Feature.RESOLVE, "ignore")
                        .build();
 * }</pre>
 *
 * <p>
 * <h3>JAXP XML Processor Support</h3>
 * The Catalog Features are supported throughout the JAXP processors, including
 * SAX and DOM ({@link javax.xml.parsers}), and StAX parsers ({@link javax.xml.stream}),
 * Schema Validation ({@link javax.xml.validation}), and XML Transformation
 * ({@link javax.xml.transform}). The features described above can be set through JAXP
 * factories or processors that define a setProperty or setAttribute interface.
 * For example, the following code snippet sets a path to a catalog file on a SAX
 * parser through the {@code javax.xml.catalog.files} property:
 * <p>
 * <pre>{@code
 *      SAXParserFactory spf = SAXParserFactory.newInstance();
 *      spf.setFeature(XMLConstants.USE_CATALOG, true); [1]
 *      SAXParser parser = spf.newSAXParser();
 *      parser.setProperty(CatalogFeatures.Feature.FILES.getPropertyName(), "catalog.xml");
 * }</pre>
 * <p>
 * [1] Note that this statement is not required since the default value of
 * {@link javax.xml.XMLConstants#USE_CATALOG USE_CATALOG} is true.
 *
 * <p>
 * The JAXP Processors' support for Catalog depends on both the
 * {@link javax.xml.XMLConstants#USE_CATALOG USE_CATALOG} feature and the
 * existence of valid Catalog file(s). A JAXP processor will use the Catalog
 * only when the feature is true and valid Catalog file(s) are specified through
 * the {@code javax.xml.catalog.files} property. It will make no attempt to use
 * the Catalog if either {@link javax.xml.XMLConstants#USE_CATALOG USE_CATALOG}
 * is set to false, or there is no Catalog file specified.
 *
 * <p>
 * The JAXP processors will observe the default settings of the
 * {@link javax.xml.catalog.CatalogFeatures}. The processors, for example, will
 * report an Exception by default when no matching entry is found since the
 * default value of the {@code javax.xml.catalog.resolve} property is strict.
 *
 * <p>
 * The JAXP processors give preference to user-specified custom resolvers. If such
 * a resolver is registered, it will be used over the CatalogResolver. If it returns
 * null however, the processors will continue resolving with the CatalogResolver.
 * If it returns an empty source, no attempt will be made by the CatalogResolver.
 *
 * <p>
 * The Catalog support is available for any process in the JAXP library that
 * supports a resolver. The following table lists all such processes.
 *
 * <p>
 * <center><h3><a name="CatalogFeatures">Processes with Catalog Support</a></h3></center></p>
 *
 * <table border="1">
 * <thead>
 * <tr>
 * <th>Process</th>
 * <th>Catalog Entry Type</th>
 * <th>Example</th>
 * </tr>
 * </thead>
 * <tbody>
 * <tr>
 * <td>DTDs and external entities</td>
 * <td>public, system</td>
 * <td>
 * <pre>{@literal
   The following DTD reference:
   <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

   Can be resolved using the following Catalog entry:
   <public publicId="-//W3C//DTD XHTML 1.0 Strict//EN" uri="catalog/xhtml1-strict.dtd"/>
   or
   <systemSuffix systemIdSuffix="html1-strict.dtd" uri="catalog/xhtml1-strict.dtd"/>
 * }</pre>
 * </td>
 * </tr>
 * <tr>
 * <td>XInclude</td>
 * <td>uri</td>
 * <td>
 * <pre>{@literal
   The following XInclude element:
   <xi:include href="http://openjdk.java.net/xml/disclaimer.xml"/>

   can be resolved using an uri entry:
   <uri name="http://openjdk.java.net/xml/disclaimer.xml" uri="file:///pathto/local/disclaimer.xml"/>
   or
   <uriSuffix uriSuffix="disclaimer.xml" uri="file:///pathto/local/disclaimer.xml"/>
 * }</pre>
 * </td>
 * </tr>
 * <tr>
 * <td>XSD import</td>
 * <td>uri</td>
 * <td>
 * <pre>{@literal
   The following import element:
    <xsd:import namespace="http://openjdk.java.net/xsd/XSDImport_person"
                schemaLocation="http://openjdk.java.net/xsd/XSDImport_person.xsd"/>

   can be resolved using an uri entry:
   <uri name="http://openjdk.java.net/xsd/XSDImport_person.xsd" uri="file:///pathto/local/XSDImport_person.xsd"/>
   or
   <uriSuffix uriSuffix="XSDImport_person.xsd" uri="file:///pathto/local/XSDImport_person.xsd"/>
   or
   <uriSuffix uriSuffix="http://openjdk.java.net/xsd/XSDImport_person" uri="file:///pathto/local/XSDImport_person.xsd"/>
 * }</pre>
 * </td>
 * </tr>
 * <tr>
 * <td>XSD include</td>
 * <td>uri</td>
 * <td>
 * <pre>{@literal
   The following include element:
   <xsd:include schemaLocation="http://openjdk.java.net/xsd/XSDInclude_person.xsd"/>

   can be resolved using an uri entry:
   <uri name="http://openjdk.java.net/xsd/XSDInclude_person.xsd" uri="file:///pathto/local/XSDInclude_person.xsd"/>
   or
   <uriSuffix uriSuffix="XSDInclude_person.xsd" uri="file:///pathto/local/XSDInclude_person.xsd"/>
 * }</pre>
 * </td>
 * </tr>
 * <tr>
 * <td>XSL import and include</td>
 * <td>uri</td>
 * <td>
 * <pre>{@literal
   The following include element:
   <xsl:include href="http://openjdk.java.net/xsl/include.xsl"/>

   can be resolved using an uri entry:
   <uri name="http://openjdk.java.net/xsl/include.xsl" uri="file:///pathto/local/include.xsl"/>
   or
   <uriSuffix uriSuffix="include.xsl" uri="file:///pathto/local/include.xsl"/>
 * }</pre>
 * </td>
 * </tr>
 * <tr>
 * <td>XSL document function</td>
 * <td>uri</td>
 * <td>
 * <pre>{@literal
   The document in the following element:
   <xsl:variable name="dummy" select="document('http://openjdk.java.net/xsl/list.xml')"/>

   can be resolved using an uri entry:
   <uri name="http://openjdk.java.net/xsl/list.xml" uri="file:///pathto/local/list.xml"/>
   or
   <uriSuffix uriSuffix="list.xml" uri="file:///pathto/local/list.xml"/>
 * }</pre>
 * </td>
 * </tr>
 * </tbody>
 * </table>
 *
 * @since 9
 */
public class CatalogFeatures {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\xml\catalog\CatalogImpl.java
/**
 * Implementation of the Catalog.
 *
 * @since 9
 */
class CatalogImpl extends GroupEntry implements Catalog {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\xml\catalog\CatalogManager.java
/**
 * The Catalog Manager manages the creation of XML Catalogs and Catalog Resolvers.
 *
 * @since 9
 */
public final class CatalogManager {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\xml\catalog\CatalogMessages.java
/**
 * Catalog Error messages
 *
 * @since 9
 */
final class CatalogMessages {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\xml\catalog\CatalogReader.java
/**
 * CatalogReader handles SAX events while parsing through a catalog file to
 * create a catalog object.
 *
 * @since 9
 */
class CatalogReader extends DefaultHandler implements EntityResolver, URIResolver {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\xml\catalog\CatalogResolver.java
/**
 * A Catalog Resolver that implements SAX {@link org.xml.sax.EntityResolver},
 * StAX {@link javax.xml.stream.XMLResolver},
 * DOM LS {@link org.w3c.dom.ls.LSResourceResolver} used by Schema Validation, and
 * Transform {@link javax.xml.transform.URIResolver}, and resolves
 * external references using catalogs.
 * <p>
 * The <a href="https://www.oasis-open.org/committees/download.php/14809/xml-catalogs.html">
 * Catalog Standard</a> distinguished {@code external identifiers} from {@code uri entries}
 * as being used to solely identify DTDs, while {@code uri entries} for
 * other resources such as stylesheets and schema. The Java APIs, such as
 * {@link javax.xml.stream.XMLResolver} and {@link org.w3c.dom.ls.LSResourceResolver}
 * however, make no such distinction.
 * In consistent with the existing Java API, this CatalogResolver recognizes a
 * system identifier as an URI and will search both {@code system} and {@code uri}
 * entries in a catalog in order to find a matching entry.
 * <p>
 * The search is started in the current catalog. If a match is found,
 * no further attempt will be made. Only if there is no match in the current
 * catalog, will alternate catalogs including delegate and next catalogs be considered.
 * <p>
 * <h3>Search Order</h3>
 * The resolver will first search the system-type of entries with the specified
 * {@code systemId}. The system entries include {@code system},
 * {@code rewriteSystem} and {@code systemSuffix} entries.
 * <p>
 * If no match is found, {@code public} entries may be searched in accordance with
 * the {@code prefer} attribute.
 * <p>
 * <b>The {@code prefer} attribute</b>: if the {@code prefer} is public,
 * and there is no match found through the system entries, {@code public} entries
 * will be considered. If it is not specified, the {@code prefer} is public
 * by default (Note that by the OASIS standard, system entries will always
 * be considered before public entries. Prefer public means that public entries
 * will be matched when both system and public identifiers are specified.
 * In general therefore, prefer public is recommended.)
 * <p>
 * If no match is found with the {@code systemId} and {@code public} identifier,
 * the resolver will continue searching {@code uri} entries
 * with the specified {@code systemId} or {@code href}. The {@code uri} entries
 * include {@code uri}, {@code rewriteURI}, and {@code uriSuffix} entries.
 *
 * <p>
 * <h3>Error Handling</h3>
 * The interfaces that the CatalogResolver extend specified checked exceptions, including:
 * <ul>
 * <li>
 * {@link org.xml.sax.SAXException} and {@link java.io.IOException} by
 * {@link org.xml.sax.EntityResolver#resolveEntity(java.lang.String, java.lang.String)}
 * </li>
 * <li>
 * {@link javax.xml.stream.XMLStreamException} by
 * {@link javax.xml.stream.XMLResolver#resolveEntity(java.lang.String, java.lang.String, java.lang.String, java.lang.String)}
 * </li>
 * <li>
 * {@link javax.xml.transform.TransformerException} by
 * {@link javax.xml.transform.URIResolver#resolve(java.lang.String, java.lang.String)}
 * </li>
 * </ul>
 * <p>
 * The CatalogResolver however, will throw {@link javax.xml.catalog.CatalogException}
 * only when {@code javax.xml.catalog.resolve} is specified as {@code strict}.
 * For applications that expect to handle the checked Exceptions, it may be
 * necessary to use a custom resolver to wrap the CatalogResolver or implement it
 * with a {@link javax.xml.catalog.Catalog} object.
 *
 * @since 9
 */
public interface CatalogResolver extends EntityResolver, XMLResolver,
        URIResolver, LSResourceResolver {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\xml\catalog\CatalogResolverImpl.java
/**
 * Implements CatalogResolver.
 *
 * <p>
 * This class implements a SAX EntityResolver, StAX XMLResolver,
 * Schema Validation LSResourceResolver and Transform URIResolver.
 *
 *
 * @since 9
 */
final class CatalogResolverImpl implements CatalogResolver {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\xml\catalog\DelegatePublic.java
/**
 * Represents a delegatePublic entry.
 *
 * @since 9
 */
final class DelegatePublic extends AltCatalog {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\xml\catalog\DelegateSystem.java
/**
 * Represents a delegateSystem entry.
 *
 * @since 9
 */
final class DelegateSystem extends AltCatalog {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\xml\catalog\DelegateUri.java
/**
 * Represents a delegateURI entry.
 *
 * @since 9
 */
final class DelegateUri extends AltCatalog {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\xml\catalog\GroupEntry.java
/**
 * Represents a group entry.
 *
 * @since 9
 */
class GroupEntry extends BaseEntry {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\xml\catalog\NextCatalog.java
/**
 * Represents a nextCatalog entry.
 *
 * @since 9
 */
final class NextCatalog extends AltCatalog {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\xml\catalog\Normalizer.java
/**
 * The Normalizer is responsible for normalizing Public and System Identifiers
 * as specified in section 6.2, 6.3 and 6.4 of the specification
 *  * <a
 * href="https://www.oasis-open.org/committees/download.php/14809/xml-catalogs.html">
 * XML Catalogs, OASIS Standard V1.1, 7 October 2005</a>.
 *
 * @since 9
 */
class Normalizer {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\xml\catalog\PublicEntry.java
/**
 * Represents a public entry.
 *
 * @since 9
 */
final class PublicEntry extends BaseEntry {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\xml\catalog\RewriteSystem.java
/**
 * Represents a rewriteSystem entry.
 *
 * @since 9
 */
final class RewriteSystem extends BaseEntry {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\xml\catalog\RewriteUri.java
/**
 * Represents a rewriteURI entry.
 *
 * @since 9
 */
final class RewriteUri extends BaseEntry {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\xml\catalog\SystemEntry.java
/**
 * Represents a system entry.
 *
 * @since 9
 */
final class SystemEntry extends BaseEntry {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\xml\catalog\SystemSuffix.java
/**
 * Represents a systemSuffix entry.
 *
 * @since 9
 */
final class SystemSuffix extends BaseEntry {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\xml\catalog\UriEntry.java
/**
 * Represents an uriEntry entry.
 *
 * @since 9
 */
final class UriEntry extends BaseEntry {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\xml\catalog\UriSuffix.java
/**
 * Represents a uriSuffix entry.
 *
 * @since 9
 */
final class UriSuffix extends BaseEntry {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\xml\catalog\Util.java
/**
 *
 * @since 9
 */
class Util {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\xml\XMLConstants.java
        /**
         * Feature: useCatalog
         *
         * <p>
         * Instructs XML processors to use XML Catalogs to resolve entity references.
         * Catalogs may be set through JAXP factories, system properties, or
         * jaxp.properties by using the {@code javax.xml.catalog.files} property
         * defined in {@link javax.xml.catalog.CatalogFeatures}.
         * The following code enables Catalog on SAX parser:
         * <pre>{@code
         *      SAXParserFactory spf = SAXParserFactory.newInstance();
         *      spf.setFeature(XMLConstants.USE_CATALOG, true);
         *      SAXParser parser = spf.newSAXParser();
         *      parser.setProperty(CatalogFeatures.Feature.FILES.getPropertyName(), "catalog.xml");
         * }</pre>
         *
         * <p>
         * <b>Value:</b> a boolean. If the value is true, and a catalog is set,
         * the XML parser will resolve external references using
         * {@link javax.xml.catalog.CatalogResolver}. If the value is false,
         * XML Catalog is ignored even if one is set. The default value is true.
         *
         * <p>
         * <b>System Property:</b> The value of this property can be set or overridden by
         * system property {@code javax.xml.useCatalog}
         *
         * <p>
         * <b>jaxp.properties:</b> This configuration file is in standard
         * {@link java.util.Properties} format and typically located in the {@code conf}
         * directory of the Java installation. If the file exists and the system
         * property is specified, its value will be used to override the default
         * value of the property.
         *
         * @since 9
         */
        public static final String USE_CATALOG = "http://javax.xml.XMLConstants/feature/useCatalog";

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\xml\xpath\XPath.java
    /**
     * Evaluate an XPath expression in the specified context and return
     * the result with the type specified through the {@code class type}
     *
     * <p>
     * The parameter {@code item} represents the context the XPath expression
     * will be operated on. The type of the context is implementation-dependent.
     * If the value is {@code null}, the operation must have no dependency on
     * the context, otherwise an XPathExpressionException will be thrown.
     *
     * @implNote
     * The type of the context is usually {@link org.w3c.dom.Node}.
     *
     * @implSpec
     * The default implementation in the XPath API is equivalent to:
     * <pre> {@code
     *     (T)evaluate(expression, item,
     *           XPathEvaluationResult.XPathResultType.getQNameType(type));
     * }</pre>
     *
     * Since the {@code evaluate} method does not support the
     * {@link XPathEvaluationResult.XPathResultType#ANY ANY} type, specifying
     * XPathEvaluationResult as the type will result in IllegalArgumentException.
     * Any implementation supporting the
     * {@link XPathEvaluationResult.XPathResultType#ANY ANY} type must override
     * this method.
     *
     * @param <T> The class type that will be returned by the XPath expression.
     * @param expression The XPath expression.
     * @param item The context the XPath expression will be evaluated in.
     * @param type The class type expected to be returned by the XPath expression.
     *
     * @return The result of evaluating the expression.
     *
     * @throws XPathExpressionException If the expression cannot be evaluated.
     * @throws IllegalArgumentException If {@code type} is not of the types
     * corresponding to the types defined in the {@link XPathEvaluationResult.XPathResultType},
     * or XPathEvaluationResult is specified as the type but an implementation supporting the
     * {@link XPathEvaluationResult.XPathResultType#ANY ANY} type is not available.
     * @throws NullPointerException If {@code expression or type} is {@code null}.
     *
     * @since 9
     */
    default <T>T evaluateExpression(String expression, Object item, Class<T> type)
        throws XPathExpressionException {

    /**
     * Evaluate an XPath expression in the specified context. This is equivalent to
     * calling {@link #evaluateExpression(String expression, Object item, Class type)}
     * with type {@link XPathEvaluationResult}:
     * <pre> {@code
     *     evaluateExpression(expression, item, XPathEvaluationResult.class);
     * }</pre>
     * <p>
     * The parameter {@code item} represents the context the XPath expression
     * will be operated on. The type of the context is implementation-dependent.
     * If the value is {@code null}, the operation must have no dependency on
     * the context, otherwise an XPathExpressionException will be thrown.
     *
     * @implNote
     * The type of the context is usually {@link org.w3c.dom.Node}.
     *
     * @implSpec
     * The default implementation in the XPath API is equivalent to:
     * <pre> {@code
     *     evaluateExpression(expression, item, XPathEvaluationResult.class);
     * }</pre>
     *
     * Since the {@code evaluate} method does not support the
     * {@link XPathEvaluationResult.XPathResultType#ANY ANY}
     * type, the default implementation of this method will always throw an
     * IllegalArgumentException. Any implementation supporting the
     * {@link XPathEvaluationResult.XPathResultType#ANY ANY} type must therefore
     * override this method.
     *
     * @param expression The XPath expression.
     * @param item The context the XPath expression will be evaluated in.
     *
     * @return The result of evaluating the expression.
     *
     * @throws XPathExpressionException If the expression cannot be evaluated.
     * @throws IllegalArgumentException If the implementation of this method
     * does not support the
     * {@link XPathEvaluationResult.XPathResultType#ANY ANY} type.
     * @throws NullPointerException If {@code expression} is {@code null}.
     *
     * @since 9
     */
    default XPathEvaluationResult<?> evaluateExpression(String expression, Object item)
        throws XPathExpressionException
    {

    /**
     * Evaluate an XPath expression in the context of the specified {@code source}
     * and return the result as specified.
     * <p>
     * This method builds a data model for the {@link InputSource} and calls
     * {@link #evaluateExpression(String expression, Object item, Class type)}
     * on the resulting document object. The data model is usually
     * {@link org.w3c.dom.Document}
     *
     * @implSpec
     * The default implementation in the XPath API is equivalent to:
     * <pre> {@code
           (T)evaluate(expression, source,
                XPathEvaluationResult.XPathResultType.getQNameType(type));
     * }</pre>
     *
     * Since the {@code evaluate} method does not support the
     * {@link XPathEvaluationResult.XPathResultType#ANY ANY} type, specifying
     * XPathEvaluationResult as the type will result in IllegalArgumentException.
     * Any implementation supporting the
     * {@link XPathEvaluationResult.XPathResultType#ANY ANY} type must override
     * this method.
     *
     * @param <T> The class type that will be returned by the XPath expression.
     * @param expression The XPath expression.
     * @param source The input source of the document to evaluate over.
     * @param type The class type expected to be returned by the XPath expression.
     *
     * @return The result of evaluating the expression.
     *
     * @throws XPathExpressionException If the expression cannot be evaluated.
     * @throws IllegalArgumentException If {@code type} is not of the types
     * corresponding to the types defined in the {@link XPathEvaluationResult.XPathResultType
     * XPathResultType}, or XPathEvaluationResult is specified as the type but an
     * implementation supporting the
     * {@link XPathEvaluationResult.XPathResultType#ANY ANY} type is not available.
     * @throws NullPointerException If {@code expression, source or type}is {@code null}.
     *
     * @since 9
     */
    default <T>T evaluateExpression(String expression, InputSource source, Class<T> type)
        throws XPathExpressionException
    {

    /**
     * Evaluate an XPath expression in the specified context. This is equivalent to
     * calling {@link #evaluateExpression(String expression, Object item, Class type)}
     * with type {@link XPathEvaluationResult}:
     * <pre> {@code
     *     evaluateExpression(expression, item, XPathEvaluationResult.class);
     * }</pre>
     *
     * @implSpec
     * The default implementation in the XPath API is equivalent to:
     * <pre> {@code
     *     evaluateExpression(expression, source, XPathEvaluationResult.class);
     * }</pre>
     *
     * Since the {@code evaluate} method does not support the
     * {@link XPathEvaluationResult.XPathResultType#ANY ANY}
     * type, the default implementation of this method will always throw an
     * IllegalArgumentException. Any implementation supporting the
     * {@link XPathEvaluationResult.XPathResultType#ANY ANY} type must therefore
     * override this method.
     *
     * @param expression The XPath expression.
     * @param source The input source of the document to evaluate over.
     *
     * @return The result of evaluating the expression.
     *
     * @throws XPathExpressionException If the expression cannot be evaluated.
     * @throws IllegalArgumentException If the implementation of this method
     * does not support the
     * {@link XPathEvaluationResult.XPathResultType#ANY ANY} type.
     * @throws NullPointerException If {@code expression or source} is {@code null}.
     *
     * @since 9
     */
    default XPathEvaluationResult<?> evaluateExpression(String expression, InputSource source)
        throws XPathExpressionException
    {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\xml\xpath\XPathEvaluationResult.java
/**
 * The {@code XPathEvaluationResult} interface represents the result of the
 * evaluation of an XPath expression within the context of a particular node.
 * The evaluation of an XPath expression can result in various result types as
 * defined in XML Path Language (XPath) Version 1.0.
 *
 * @param <T> the object type returned by the XPath evaluation.
 * @see <a href="http://www.w3.org/TR/xpath">XML Path Language (XPath) Version
 * 1.0</a>
 *
 * @since 9
 */
public interface XPathEvaluationResult<T> {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\xml\xpath\XPathExpression.java
    /**
     * Evaluate the compiled XPath expression in the specified context, and return
     * the result with the type specified through the {@code class type}.
     *
     * <p>
     * The parameter {@code item} represents the context the XPath expression
     * will be operated on. The type of the context is implementation-dependent.
     * If the value is {@code null}, the operation must have no dependency on
     * the context, otherwise an XPathExpressionException will be thrown.
     *
     * @implNote
     * The type of the context is usually {@link org.w3c.dom.Node}.
     *
     * @implSpec
     * The default implementation in the XPath API is equivalent to:
     * <pre> {@code
     *     (T)evaluate(item, XPathEvaluationResult.XPathResultType.getQNameType(type));
     * }</pre>
     *
     * Since the {@code evaluate} method does not support the
     * {@link XPathEvaluationResult.XPathResultType#ANY ANY} type, specifying
     * XPathEvaluationResult as the type will result in IllegalArgumentException.
     * Any implementation supporting the
     * {@link XPathEvaluationResult.XPathResultType#ANY ANY} type must override
     * this method.
     *
     * @param <T> The class type that will be returned by the XPath expression.
     * @param item The context the XPath expression will be evaluated in.
     * @param type The class type expected to be returned by the XPath expression.
     *
     * @return The result of evaluating the expression.
     *
     * @throws XPathExpressionException If the expression cannot be evaluated.
     * @throws IllegalArgumentException If {@code type} is not of the types
     * corresponding to the types defined in the {@link XPathEvaluationResult.XPathResultType
     * XPathResultType}, or XPathEvaluationResult is specified as the type but an
     * implementation supporting the
     * {@link XPathEvaluationResult.XPathResultType#ANY ANY} type is not available.
     * @throws NullPointerException If {@code type} is {@code null}.
     *
     * @since 9
     */
    default <T>T evaluateExpression(Object item, Class<T> type)
        throws XPathExpressionException
    {

    /**
     * Evaluate the compiled XPath expression in the specified context. This is
     * equivalent to calling {@link #evaluateExpression(Object item, Class type)}
     * with type {@link XPathEvaluationResult}:
     * <pre> {@code
     *     evaluateExpression(item, XPathEvaluationResult.class);
     * }</pre>
     * <p>
     * The parameter {@code item} represents the context the XPath expression
     * will be operated on. The type of the context is implementation-dependent.
     * If the value is {@code null}, the operation must have no dependency on
     * the context, otherwise an XPathExpressionException will be thrown.
     *
     * @implNote
     * The type of the context is usually {@link org.w3c.dom.Node}.
     *
     * @implSpec
     * The default implementation in the XPath API is equivalent to:
     * <pre> {@code
     *     evaluateExpression(item, XPathEvaluationResult.class);
     * }</pre>
     *
     * Since the {@code evaluate} method does not support the
     * {@link XPathEvaluationResult.XPathResultType#ANY ANY}
     * type, the default implementation of this method will always throw an
     * IllegalArgumentException. Any implementation supporting the
     * {@link XPathEvaluationResult.XPathResultType#ANY ANY} type must therefore
     * override this method.
     *
     * @param item The context the XPath expression will be evaluated in.
     *
     * @return The result of evaluating the expression.
     *
     * @throws XPathExpressionException If the expression cannot be evaluated.
     * @throws IllegalArgumentException If the implementation of this method
     * does not support the
     * {@link XPathEvaluationResult.XPathResultType#ANY ANY} type.
     *
     * @since 9
     */
    default XPathEvaluationResult<?> evaluateExpression(Object item)
        throws XPathExpressionException
    {

    /**
     * Evaluate the compiled XPath expression in the specified context,
     * and return the result with the type specified through the {@code class type}
     * <p>
     * This method builds a data model for the {@link InputSource} and calls
     * {@link #evaluateExpression(Object item, Class type)} on the resulting
     * document object.
     * <P>
     * By default, the JDK's data model is {@link org.w3c.dom.Document}.
     *
     * @implSpec
     * The default implementation in the XPath API is equivalent to:
     * <pre> {@code
           (T)evaluate(source, XPathEvaluationResult.XPathResultType.getQNameType(type));
     * }</pre>
     *
     * Since the {@code evaluate} method does not support the
     * {@link XPathEvaluationResult.XPathResultType#ANY ANY} type, specifying
     * XPathEvaluationResult as the type will result in IllegalArgumentException.
     * Any implementation supporting the
     * {@link XPathEvaluationResult.XPathResultType#ANY ANY} type must override
     * this method.
     *
     * @param <T> The class type that will be returned by the XPath expression.
     * @param source The {@code InputSource} of the document to evaluate over.
     * @param type The class type expected to be returned by the XPath expression.
     *
     * @return The result of evaluating the expression.
     *
     * @throws XPathExpressionException If the expression cannot be evaluated.
     * @throws IllegalArgumentException If {@code type} is not of the types
     * corresponding to the types defined in the {@link XPathEvaluationResult.XPathResultType
     * XPathResultType}, or XPathEvaluationResult is specified as the type but an
     * implementation supporting the
     * {@link XPathEvaluationResult.XPathResultType#ANY ANY} type
     * is not available.
     * @throws NullPointerException If {@code source or type} is {@code null}.
     *
     * @since 9
     */
    default <T>T evaluateExpression(InputSource source, Class<T> type)
        throws XPathExpressionException
    {

    /**
     * Evaluate the compiled XPath expression in the specified context. This is
     * equivalent to calling {@link #evaluateExpression(InputSource source, Class type)}
     * with type {@link XPathEvaluationResult}:
     * <pre> {@code
     *     evaluateExpression(source, XPathEvaluationResult.class);
     * }</pre>
     *
     * @implSpec
     * The default implementation in the XPath API is equivalent to:
     * <pre> {@code
     *     (XPathEvaluationResult)evaluateExpression(source, XPathEvaluationResult.class);
     * }</pre>
     *
     * Since the {@code evaluate} method does not support the
     * {@link XPathEvaluationResult.XPathResultType#ANY ANY}
     * type, the default implementation of this method will always throw an
     * IllegalArgumentException. Any implementation supporting the
     * {@link XPathEvaluationResult.XPathResultType#ANY ANY} type must therefore
     * override this method.
     *
     * @param source The {@code InputSource} of the document to evaluate over.
     *
     * @return The result of evaluating the expression.
     *
     * @throws XPathExpressionException If the expression cannot be evaluated.
     * @throws IllegalArgumentException If the implementation of this method
     * does not support the
     * {@link XPathEvaluationResult.XPathResultType#ANY ANY} type.
     * @throws NullPointerException If {@code source} is {@code null}.
     *
     * @since 9
     */
    default XPathEvaluationResult<?> evaluateExpression(InputSource source)
        throws XPathExpressionException
    {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\javax\xml\xpath\XPathNodes.java
/**
 * XPathNodes represents a set of nodes selected by a location path as specified
 * in <a href="http://www.w3.org/TR/xpath/#node-sets">XML Path Language (XPath)
 * Version 1.0, 3.3 Node-sets</a>.
 *
 * @since 9
 */
public interface XPathNodes extends Iterable<Node> {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\org\w3c\dom\ElementTraversal.java
/**
 * The {@code ElementTraversal} interface is a set of read-only attributes
 * which allow an author to easily navigate between elements in a document.
 * <p>
 * In conforming implementations of Element Traversal, all objects that
 * implement {@link Element} must also implement the {@code ElementTraversal}
 * interface. Four of the methods,
 * {@link #getFirstElementChild}, {@link #getLastElementChild},
 * {@link #getPreviousElementSibling}, and {@link #getNextElementSibling},
 * each provides a live reference to another element with the defined
 * relationship to the current element, if the related element exists. The
 * fifth method, {@link #getChildElementCount}, exposes the number of child
 * elements of an element, for preprocessing before navigation.
 *
 * @see
 * <a href='http://www.w3.org/TR/ElementTraversal/'><cite>Element Traversal Specification</cite></a>
 *
 * @since 9
 */
public interface ElementTraversal {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\org\w3c\dom\ranges\DocumentRange.java
/**
 * <p>See also the <a href='http://www.w3.org/TR/2000/REC-DOM-Level-2-Traversal-Range-20001113'>Document Object Model (DOM) Level 2 Traversal and Range Specification</a>.
 * @since 9, DOM Level 2
 */
public interface DocumentRange {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\org\w3c\dom\ranges\Range.java
/**
 * <p>See also the <a href='http://www.w3.org/TR/2000/REC-DOM-Level-2-Traversal-Range-20001113'>Document Object Model (DOM) Level 2 Traversal and Range Specification</a>.
 * @since 9, DOM Level 2
 */
public interface Range {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\org\w3c\dom\ranges\RangeException.java
/**
 * Range operations may throw a <code>RangeException</code> as specified in
 * their method descriptions.
 * <p>See also the <a href='http://www.w3.org/TR/2000/REC-DOM-Level-2-Traversal-Range-20001113'>Document Object Model (DOM) Level 2 Traversal and Range Specification</a>.
 * @since 9, DOM Level 2
 */
public class RangeException extends RuntimeException {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\org\w3c\dom\traversal\DocumentTraversal.java
/**
 * <code>DocumentTraversal</code> contains methods that create
 * <code>NodeIterators</code> and <code>TreeWalkers</code> to traverse a
 * node and its children in document order (depth first, pre-order
 * traversal, which is equivalent to the order in which the start tags occur
 * in the text representation of the document). In DOMs which support the
 * Traversal feature, <code>DocumentTraversal</code> will be implemented by
 * the same objects that implement the Document interface.
 * <p>See also the <a href='http://www.w3.org/TR/2000/REC-DOM-Level-2-Traversal-Range-20001113'>Document Object Model (DOM) Level 2 Traversal and Range Specification</a>.
 * @since 9, DOM Level 2
 */
public interface DocumentTraversal {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\org\w3c\dom\traversal\NodeFilter.java
/**
 * Filters are objects that know how to "filter out" nodes. If a
 * <code>NodeIterator</code> or <code>TreeWalker</code> is given a
 * <code>NodeFilter</code>, it applies the filter before it returns the next
 * node. If the filter says to accept the node, the traversal logic returns
 * it; otherwise, traversal looks for the next node and pretends that the
 * node that was rejected was not there.
 * <p>The DOM does not provide any filters. <code>NodeFilter</code> is just an
 * interface that users can implement to provide their own filters.
 * <p><code>NodeFilters</code> do not need to know how to traverse from node
 * to node, nor do they need to know anything about the data structure that
 * is being traversed. This makes it very easy to write filters, since the
 * only thing they have to know how to do is evaluate a single node. One
 * filter may be used with a number of different kinds of traversals,
 * encouraging code reuse.
 * <p>See also the <a href='http://www.w3.org/TR/2000/REC-DOM-Level-2-Traversal-Range-20001113'>Document Object Model (DOM) Level 2 Traversal and Range Specification</a>.
 * @since 9, DOM Level 2
 */
public interface NodeFilter {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\org\w3c\dom\traversal\NodeIterator.java
/**
 * <code>NodeIterators</code> are used to step through a set of nodes, e.g.
 * the set of nodes in a <code>NodeList</code>, the document subtree
 * governed by a particular <code>Node</code>, the results of a query, or
 * any other set of nodes. The set of nodes to be iterated is determined by
 * the implementation of the <code>NodeIterator</code>. DOM Level 2
 * specifies a single <code>NodeIterator</code> implementation for
 * document-order traversal of a document subtree. Instances of these
 * <code>NodeIterators</code> are created by calling
 * <code>DocumentTraversal</code><code>.createNodeIterator()</code>.
 * <p>See also the <a href='http://www.w3.org/TR/2000/REC-DOM-Level-2-Traversal-Range-20001113'>Document Object Model (DOM) Level 2 Traversal and Range Specification</a>.
 * @since 9, DOM Level 2
 */
public interface NodeIterator {

-------------------------------------------------------------------------------------------------------------
c:\temp\jdk9\org\w3c\dom\traversal\TreeWalker.java
/**
 * <code>TreeWalker</code> objects are used to navigate a document tree or
 * subtree using the view of the document defined by their
 * <code>whatToShow</code> flags and filter (if any). Any function which
 * performs navigation using a <code>TreeWalker</code> will automatically
 * support any view defined by a <code>TreeWalker</code>.
 * <p>Omitting nodes from the logical view of a subtree can result in a
 * structure that is substantially different from the same subtree in the
 * complete, unfiltered document. Nodes that are siblings in the
 * <code>TreeWalker</code> view may be children of different, widely
 * separated nodes in the original view. For instance, consider a
 * <code>NodeFilter</code> that skips all nodes except for Text nodes and
 * the root node of a document. In the logical view that results, all text
 * nodes will be siblings and appear as direct children of the root node, no
 * matter how deeply nested the structure of the original document.
 * <p>See also the <a href='http://www.w3.org/TR/2000/REC-DOM-Level-2-Traversal-Range-20001113'>Document Object Model (DOM) Level 2 Traversal and Range Specification</a>.
 * @since 9, DOM Level 2
 */
public interface TreeWalker {

